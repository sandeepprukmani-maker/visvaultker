# Enhanced Workflow Sample Output

This document shows exactly what the enhanced workflow produces: an intelligent prompt with validated element locators, and the clean AI-generated script.

---

## Example Task
**User Request:** "Go to hackernews and upvote the first story"

---

## STEP 1: Intelligent Prompt with Validated Locators

The **Enhanced Prompt Generator** analyzes the page and creates this detailed prompt with real element locators:

```
BROWSER AUTOMATION TASK
=======================

Objective: Go to hackernews and upvote the first story

Target URL: https://news.ycombinator.com

Page Context:
- Title: Hacker News
- Total Interactive Elements: 47
- Validation Confidence: 92%

Validated Elements and Locators:
---------------------------------

1. FIRST STORY UPVOTE BUTTON
   - Type: link
   - Text: "upvote"
   - Validated Locators:
     * CSS Selector: #up_39285711 (Confidence: 95%)
     * XPath: //a[@id='up_39285711'] (Confidence: 95%)
     * Alternative CSS: .votearrow (Confidence: 70%)
   - Context: First upvote arrow in the story list
   - Accessibility: aria-label="upvote"
   - Visible: Yes
   - Interactive: Yes

2. FIRST STORY TITLE
   - Type: link  
   - Text: "Show HN: I built an AI browser automation tool"
   - Validated Locators:
     * CSS Selector: .titleline > a:first-child (Confidence: 90%)
     * XPath: //span[@class='titleline']/a[1] (Confidence: 90%)
     * Text Match: text="Show HN: I built an AI browser automation tool" (Confidence: 85%)
   - Context: First story title in the main list
   - Visible: Yes
   - Interactive: Yes

3. LOGIN LINK (if needed)
   - Type: link
   - Text: "login"
   - Validated Locators:
     * CSS Selector: a[href='login'] (Confidence: 100%)
     * XPath: //a[contains(@href, 'login')] (Confidence: 100%)
   - Context: Top navigation bar
   - Visible: Yes

Step-by-Step Instructions:
---------------------------

Step 1: Navigate to Target
   Action: goto
   Target: https://news.ycombinator.com
   Expected Result: Page loads successfully
   Validation: Page title contains "Hacker News"

Step 2: Locate First Upvote Button
   Action: locate_element
   Preferred Locator: CSS Selector "#up_39285711"
   Fallback Locators: 
     - .votearrow (first element)
     - //a[@class='votearrow'][1]
   Expected Result: Upvote button is visible and interactive
   Validation: Element exists and is clickable

Step 3: Click Upvote Button
   Action: click
   Target: First upvote button
   Locator: #up_39285711
   Expected Result: Vote is registered or login page appears
   Validation: Button state changes or navigation occurs

Important Notes:
----------------
- The upvote button ID (#up_39285711) is dynamic and may change for different stories
- If not logged in, clicking upvote will redirect to login page
- Use the .votearrow class selector as fallback if ID doesn't match
- Wait for page load before attempting to locate elements
- Verify element visibility before clicking

Confidence Assessment:
----------------------
Overall Task Confidence: 92%
- Page accessibility: 100%
- Element detection: 95%
- Locator accuracy: 90%
- Success probability: 85% (login may be required)

Recommended Approach:
---------------------
1. Use the dynamic ID selector first (#up_39285711) with error handling
2. Fall back to class selector (.votearrow:first-of-type) if ID fails
3. Add wait conditions to ensure elements are loaded
4. Include error handling for login requirement
5. Verify action completion before proceeding
```

---

## STEP 2: AI-Generated Clean Script

The **AI Script Generator** takes the above prompt and creates this clean Playwright script:

```python
"""
Auto-generated Playwright script
Task: Go to hackernews and upvote the first story
Generated by: AI Script Generator (using Claude/GPT/Groq)
"""

from playwright.sync_api import sync_playwright, Page
import time


def upvote_first_story(page: Page):
    """
    Upvotes the first story on Hacker News
    
    Returns:
        dict: Result with success status and message
    """
    try:
        # Navigate to Hacker News
        print("üìç Navigating to Hacker News...")
        page.goto("https://news.ycombinator.com", wait_until="networkidle")
        
        # Verify page loaded
        assert "Hacker News" in page.title(), "Failed to load Hacker News"
        print("‚úÖ Page loaded successfully")
        
        # Wait for content to load
        page.wait_for_selector(".votearrow", state="visible", timeout=10000)
        
        # Locate first upvote button using validated locators
        upvote_button = None
        
        # Try primary locator (dynamic ID)
        try:
            upvote_button = page.locator("#up_39285711")
            if not upvote_button.is_visible():
                upvote_button = None
        except:
            upvote_button = None
        
        # Fallback to class selector
        if not upvote_button:
            print("‚ö†Ô∏è  Dynamic ID not found, using fallback locator...")
            upvote_button = page.locator(".votearrow").first
        
        # Verify button is visible and clickable
        upvote_button.wait_for(state="visible", timeout=5000)
        print("üéØ Found upvote button")
        
        # Click the upvote button
        upvote_button.click()
        print("‚úÖ Clicked upvote button")
        
        # Wait for response
        page.wait_for_timeout(1000)
        
        # Check if redirected to login
        current_url = page.url
        if "login" in current_url:
            return {
                "success": False,
                "message": "Login required to upvote. Please log in first.",
                "requires_login": True
            }
        
        # Verify vote was registered
        # The upvote arrow should change state or disappear
        time.sleep(0.5)
        
        return {
            "success": True,
            "message": "Successfully upvoted the first story!",
            "url": current_url
        }
        
    except Exception as e:
        return {
            "success": False,
            "message": f"Error during automation: {str(e)}",
            "error": str(e)
        }


def main():
    """Main execution function"""
    with sync_playwright() as p:
        # Launch browser
        browser = p.chromium.launch(headless=False)  # Set to True for headless
        context = browser.new_context(
            viewport={"width": 1280, "height": 720}
        )
        page = context.new_page()
        
        try:
            # Execute the automation
            result = upvote_first_story(page)
            
            # Print result
            if result["success"]:
                print(f"\n‚úÖ SUCCESS: {result['message']}")
            else:
                print(f"\n‚ùå FAILED: {result['message']}")
            
            return result
            
        finally:
            # Cleanup
            browser.close()


if __name__ == "__main__":
    main()
```

---

## Key Benefits of Enhanced Workflow

### ‚úÖ Intelligent Prompt Includes:
- **Real validated locators** from actual page scraping
- **Multiple fallback strategies** (CSS, XPath, text matching)
- **Confidence scores** for each locator
- **Element context** (visibility, interactivity)
- **Step-by-step instructions** with validation points
- **Important notes** about dynamic elements and edge cases

### ‚úÖ AI-Generated Script Features:
- **Clean, readable code** without unnecessary complexity
- **Proper error handling** with try-except blocks  
- **Fallback locators** for robustness
- **Wait conditions** to handle dynamic content
- **Verification steps** to ensure actions succeed
- **Clear logging** for debugging
- **Structured functions** for maintainability

---

## How to Use This in Your App

1. **User enters task**: "Go to hackernews and upvote the first story"

2. **System generates prompt**: Enhanced Prompt Generator creates the detailed prompt above

3. **AI generates code**: AI Script Generator (using Claude/GPT/Groq) produces the clean script

4. **Display in UI**: Show both the prompt and the generated script to the user

5. **Execute**: Run the script and use Dynamic Healer if it fails

---

## No Legacy Code Generation Needed

The enhanced workflow **completely replaces** the legacy agent-based code generation:

- ‚ùå **OLD**: Legacy agents generate verbose, complex code
- ‚úÖ **NEW**: AI generates clean, simple code from validated prompts

The legacy workflow is only used as a **fallback** if:
- AI API keys are not configured
- Enhanced workflow fails for some reason
- User explicitly disables enhanced mode

