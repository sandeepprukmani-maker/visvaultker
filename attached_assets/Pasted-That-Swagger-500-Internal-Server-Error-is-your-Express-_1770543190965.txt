That Swagger “500 Internal Server Error” is **your Express server returning a generic error**, not necessarily UWM returning 500. Right now your proxy is swallowing the real upstream details.

Let’s turn this into something debuggable in 5 minutes.

---

## What’s *most likely* happening

For `POST /api/uwm/instantpricequote/v1/pricequote`, one of these is failing:

1. **Tunnel isn’t actually up** (or died after startup) → your proxy call fails
2. **Auth token fetch failed** → you’re forwarding without a valid `Authorization: Bearer ...`
3. **Your request body is empty/incorrect** (Swagger sending form-data / missing JSON / missing required keys)
4. **Your proxy code is not passing through UWM’s error response**, so you only see “Internal Server Error”

We fix #4 first, then the real cause will be obvious.

---

# 1) Make the proxy return UWM’s real status + body (critical)

In your route handler that proxies to UWM (the `pricequote` one), change the error handling to:

* log upstream status
* read response as text
* return it to Swagger

Use this exact pattern:

```ts
// after you do the uwmFetch(...)
const uwmRes = await uwmFetch("/instantpricequote/v1/pricequote", {
  method: "POST",
  headers: {
    "Authorization": `Bearer ${accessToken}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify(req.body),
});

const raw = await uwmRes.text();

if (!uwmRes.ok) {
  console.error("UWM pricequote error", {
    status: uwmRes.status,
    body: raw.slice(0, 2000),
  });

  // Return upstream details to Swagger
  res.status(uwmRes.status).type("text/plain").send(raw);
  return;
}

// success: try json
try {
  res.json(JSON.parse(raw));
} catch {
  res.type("text/plain").send(raw);
}
```

Do the same for the **auth token** call too.

✅ After this, Swagger will show the real reason (401, 403, validation error, etc.) instead of generic 500.

---

# 2) Quick test: does auth work through your proxy?

Hit your auth proxy endpoint directly (whatever you wired it to), or add a quick temporary route:

```ts
app.get("/api/uwm/_debug/token", async (_req, res) => {
  const t = await getAccessTokenSomehow();
  res.json({ ok: !!t, tokenPrefix: t?.slice(0, 10) });
});
```

If token isn’t coming back, pricequote will fail.

---

# 3) The single most common Swagger gotcha: body isn’t JSON

Swagger UI sometimes sends an empty body if your schema is wrong or you didn’t click “Try it out” properly.

On the server, add this log at the start of the pricequote handler:

```ts
console.log("Incoming pricequote body keys:", Object.keys(req.body || {}));
```

If it prints `[]`, you’re sending nothing.

Also make sure you have:

```ts
app.use(express.json({ limit: "2mb" }));
```

before routes.

---

# 4) Confirm tunnel is still alive when the request happens

Even if it starts, it can die.

Add SSH process logging (super important on Replit):

```ts
sshProcess.stderr?.on("data", d => console.error("[ssh]", d.toString()));
sshProcess.on("exit", code => console.error("[ssh exit]", code));
```

If you see `[ssh exit] 255` or similar → tunnel is dead → UWM calls fail.

---

## What I need from you (1 paste)

After you apply #1 (pass-through), try the Swagger call again and paste **the response body** you get (it will likely be a UWM JSON error or a Cloudflare 403/401).

That one response will tell us immediately which path we’re on:

* **401** → token issue
* **403 cloudflare** → tunnel/Host/SNI path issue
* **4xx validation** → missing required keys in request body
* **5xx** → upstream outage or invalid environment

If you want, upload your updated zip (or point me to the handler file) and I’ll tell you exactly where to paste the changes.
