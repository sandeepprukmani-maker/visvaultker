{"file_contents":{"main.py":{"content":"\"\"\"\nMain entry point for the AI Browser Automation web application\n\"\"\"\nimport os\nimport sys\nfrom dotenv import load_dotenv\nfrom app import create_app\n\n# Force unbuffered output for better logging\nif hasattr(sys.stdout, 'reconfigure'):\n    sys.stdout.reconfigure(line_buffering=True)  # type: ignore\nos.environ['PYTHONUNBUFFERED'] = '1'\n\n# Skip Playwright browser downloads permanently\nos.environ['PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD'] = '1'\n\n# Load .env file and override any existing environment variables\nload_dotenv(override=True)\n\napp = create_app()\n\nif __name__ == '__main__':\n    print(\"=\"*80)\n    print(\"üöÄ AI BROWSER AUTOMATION - STARTING UP\")\n    print(\"=\"*80)\n    \n    # Validate OAuth configuration\n    required_oauth_vars = [\n        \"OAUTH_TOKEN_URL\",\n        \"OAUTH_CLIENT_ID\",\n        \"OAUTH_CLIENT_SECRET\",\n        \"OAUTH_GRANT_TYPE\",\n        \"OAUTH_SCOPE\",\n        \"GW_BASE_URL\"\n    ]\n    \n    missing_vars = [var for var in required_oauth_vars if not os.environ.get(var)]\n    \n    if missing_vars:\n        print(f\"\\n‚ö†Ô∏è  WARNING: Missing OAuth environment variables: {', '.join(missing_vars)}\")\n        print(\"   The application will start but AI features will not work.\")\n        print(\"   Please set the required OAuth variables in your environment.\\n\")\n    else:\n        print(\"‚úÖ OAuth configuration found\")\n        print(f\"‚úÖ Gateway URL: {os.environ.get('GW_BASE_URL')}\")\n    \n    sys.stdout.flush()\n\n    print(\"\\nüåê Starting Flask web server on port 5000...\")\n    print(\"=\"*80)\n    print(\"\\nüí° TIP: Keep this console window open to see automation logs\\n\")\n    sys.stdout.flush()\n\n    # Start the web app with debug mode for better console output\n    app.run(host='0.0.0.0', port=5000, debug=True, use_reloader=False)\n","size_bytes":1750},"app/engines/browser_use/advanced_features.py":{"content":"\"\"\"\nAdvanced Browser Automation Features\nProvides screenshot capture, PDF generation, cookie management, and more\n\"\"\"\nimport os\nimport json\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nfrom datetime import datetime\nfrom browser_use import Browser\n\nlogger = logging.getLogger(__name__)\n\n\nclass AdvancedBrowserFeatures:\n    \"\"\"\n    Advanced capabilities for browser automation\n    Handles screenshots, PDFs, cookies, sessions, and more\n    \"\"\"\n    \n    def __init__(self, output_dir: str = \"automation_outputs\"):\n        \"\"\"\n        Initialize advanced browser features\n        \n        Args:\n            output_dir: Directory to save screenshots, PDFs, etc.\n        \"\"\"\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(exist_ok=True)\n        \n        self.screenshots_dir = self.output_dir / \"screenshots\"\n        self.pdfs_dir = self.output_dir / \"pdfs\"\n        self.cookies_dir = self.output_dir / \"cookies\"\n        \n        self.screenshots_dir.mkdir(exist_ok=True)\n        self.pdfs_dir.mkdir(exist_ok=True)\n        self.cookies_dir.mkdir(exist_ok=True)\n        \n        logger.info(f\"üìÅ Advanced features initialized with output dir: {self.output_dir}\")\n    \n    async def capture_screenshot(self, page, name: Optional[str] = None, full_page: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Capture screenshot of current page\n        \n        Args:\n            page: Playwright page object\n            name: Optional custom name for screenshot\n            full_page: Capture full scrollable page\n            \n        Returns:\n            Dictionary with screenshot path and metadata\n        \"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"{name}_{timestamp}.png\" if name else f\"screenshot_{timestamp}.png\"\n            filepath = self.screenshots_dir / filename\n            \n            await page.screenshot(path=str(filepath), full_page=full_page)\n            \n            logger.info(f\"üì∏ Screenshot saved: {filepath}\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"filename\": filename,\n                \"full_page\": full_page,\n                \"timestamp\": timestamp,\n                \"url\": page.url\n            }\n        except Exception as e:\n            logger.error(f\"‚ùå Screenshot capture failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def generate_pdf(self, page, name: Optional[str] = None, \n                          landscape: bool = False, \n                          print_background: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Generate PDF of current page\n        \n        Args:\n            page: Playwright page object\n            name: Optional custom name for PDF\n            landscape: Use landscape orientation\n            print_background: Include background graphics\n            \n        Returns:\n            Dictionary with PDF path and metadata\n        \"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"{name}_{timestamp}.pdf\" if name else f\"page_{timestamp}.pdf\"\n            filepath = self.pdfs_dir / filename\n            \n            await page.pdf(\n                path=str(filepath),\n                format='A4',\n                landscape=landscape,\n                print_background=print_background,\n                margin={'top': '20px', 'right': '20px', 'bottom': '20px', 'left': '20px'}\n            )\n            \n            logger.info(f\"üìÑ PDF generated: {filepath}\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"filename\": filename,\n                \"landscape\": landscape,\n                \"timestamp\": timestamp,\n                \"url\": page.url\n            }\n        except Exception as e:\n            logger.error(f\"‚ùå PDF generation failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def save_cookies(self, context, session_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Save browser cookies for session persistence\n        \n        Args:\n            context: Playwright browser context\n            session_name: Name for this session\n            \n        Returns:\n            Dictionary with save status and path\n        \"\"\"\n        try:\n            cookies = await context.cookies()\n            \n            filepath = self.cookies_dir / f\"{session_name}_cookies.json\"\n            \n            with open(filepath, 'w', encoding='utf-8') as f:\n                json.dump(cookies, f, indent=2)\n            \n            logger.info(f\"üç™ Cookies saved: {filepath} ({len(cookies)} cookies)\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"session_name\": session_name,\n                \"cookie_count\": len(cookies)\n            }\n        except Exception as e:\n            logger.error(f\"‚ùå Cookie save failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def load_cookies(self, context, session_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Load previously saved cookies to restore session\n        \n        Args:\n            context: Playwright browser context\n            session_name: Name of session to restore\n            \n        Returns:\n            Dictionary with load status\n        \"\"\"\n        try:\n            filepath = self.cookies_dir / f\"{session_name}_cookies.json\"\n            \n            if not filepath.exists():\n                return {\n                    \"success\": False,\n                    \"error\": f\"Session '{session_name}' not found\"\n                }\n            \n            with open(filepath, 'r', encoding='utf-8') as f:\n                cookies = json.load(f)\n            \n            await context.add_cookies(cookies)\n            \n            logger.info(f\"üç™ Cookies loaded: {filepath} ({len(cookies)} cookies)\")\n            \n            return {\n                \"success\": True,\n                \"session_name\": session_name,\n                \"cookie_count\": len(cookies)\n            }\n        except Exception as e:\n            logger.error(f\"‚ùå Cookie load failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def get_local_storage(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract localStorage data from page\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with localStorage contents\n        \"\"\"\n        try:\n            storage_data = await page.evaluate(\"\"\"() => {\n                let data = {};\n                for (let i = 0; i < localStorage.length; i++) {\n                    let key = localStorage.key(i);\n                    data[key] = localStorage.getItem(key);\n                }\n                return data;\n            }\"\"\")\n            \n            logger.info(f\"üíæ LocalStorage extracted: {len(storage_data)} items\")\n            \n            return {\n                \"success\": True,\n                \"data\": storage_data,\n                \"item_count\": len(storage_data)\n            }\n        except Exception as e:\n            logger.error(f\"‚ùå LocalStorage extraction failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def set_local_storage(self, page, data: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"\n        Set localStorage data on page\n        \n        Args:\n            page: Playwright page object\n            data: Dictionary of key-value pairs to set\n            \n        Returns:\n            Dictionary with operation status\n        \"\"\"\n        try:\n            for key, value in data.items():\n                await page.evaluate(f\"\"\"() => {{\n                    localStorage.setItem('{key}', '{value}');\n                }}\"\"\")\n            \n            logger.info(f\"üíæ LocalStorage set: {len(data)} items\")\n            \n            return {\n                \"success\": True,\n                \"item_count\": len(data)\n            }\n        except Exception as e:\n            logger.error(f\"‚ùå LocalStorage set failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    def list_sessions(self) -> List[str]:\n        \"\"\"\n        List all saved cookie sessions\n        \n        Returns:\n            List of session names\n        \"\"\"\n        sessions = []\n        for file in self.cookies_dir.glob(\"*_cookies.json\"):\n            session_name = file.stem.replace(\"_cookies\", \"\")\n            sessions.append(session_name)\n        \n        return sessions\n    \n    def cleanup_old_files(self, days: int = 7):\n        \"\"\"\n        Clean up old screenshots and PDFs\n        \n        Args:\n            days: Delete files older than this many days\n        \"\"\"\n        from datetime import timedelta\n        cutoff = datetime.now() - timedelta(days=days)\n        \n        deleted_count = 0\n        for directory in [self.screenshots_dir, self.pdfs_dir]:\n            for file in directory.glob(\"*\"):\n                if file.stat().st_mtime < cutoff.timestamp():\n                    file.unlink()\n                    deleted_count += 1\n        \n        logger.info(f\"üóëÔ∏è  Cleaned up {deleted_count} old files\")\n        return deleted_count\n","size_bytes":9646},"app/engines/playwright_mcp/__init__.py":{"content":"\"\"\"\nPlaywright MCP Engine for AI-powered browser automation\n\"\"\"\nfrom .engine_mcp import PlaywrightMCPEngine\n\n__all__ = ['PlaywrightMCPEngine']\n","size_bytes":143},"app/utils/logging_config.py":{"content":"\"\"\"\nCentralized logging configuration for the application\n\"\"\"\nimport logging\nimport configparser\nimport sys\nfrom pathlib import Path\n\n\nclass LoggingConfigurator:\n    \"\"\"Configure logging based on config.ini settings\"\"\"\n    \n    def __init__(self, config_path: str = 'config/config.ini'):\n        self.config = configparser.ConfigParser()\n        self.config.read(config_path)\n        \n        # Get logging settings\n        self.detailed_logging_enabled = self.config.getboolean('logging', 'enable_detailed_logging', fallback=False)\n        self.app_log_level = self.config.get('logging', 'app_log_level', fallback='INFO')\n        self.browser_use_log_level = self.config.get('logging', 'browser_use_log_level', fallback='INFO')\n        self.agent_log_level = self.config.get('logging', 'agent_log_level', fallback='INFO')\n        self.llm_log_level = self.config.get('logging', 'llm_log_level', fallback='INFO')\n        self.playwright_log_level = self.config.get('logging', 'playwright_log_level', fallback='WARNING')\n        \n        self.log_llm_requests = self.config.getboolean('logging', 'log_llm_requests', fallback=False)\n        self.log_llm_responses = self.config.getboolean('logging', 'log_llm_responses', fallback=False)\n        self.log_browser_actions = self.config.getboolean('logging', 'log_browser_actions', fallback=False)\n        self.log_page_state = self.config.getboolean('logging', 'log_page_state', fallback=False)\n        self.log_performance = self.config.getboolean('logging', 'log_performance', fallback=False)\n    \n    def configure(self):\n        \"\"\"Apply logging configuration\"\"\"\n        if not self.detailed_logging_enabled:\n            # Simple logging\n            logging.basicConfig(\n                level=logging.INFO,\n                format='%(levelname)s:%(name)s:%(message)s',\n                handlers=[logging.StreamHandler(sys.stdout)]\n            )\n            return\n        \n        # Detailed logging with timestamps\n        log_format = '%(asctime)s [%(name)s] %(levelname)s: %(message)s'\n        date_format = '%Y-%m-%d %H:%M:%S'\n        \n        logging.basicConfig(\n            level=getattr(logging, self.app_log_level, logging.INFO),\n            format=log_format,\n            datefmt=date_format,\n            handlers=[logging.StreamHandler(sys.stdout)],\n            force=True  # Override any existing configuration\n        )\n        \n        # Configure specific loggers\n        logging.getLogger('app').setLevel(getattr(logging, self.app_log_level, logging.INFO))\n        logging.getLogger('browser_use').setLevel(getattr(logging, self.browser_use_log_level, logging.INFO))\n        logging.getLogger('Agent').setLevel(getattr(logging, self.agent_log_level, logging.INFO))\n        logging.getLogger('service').setLevel(getattr(logging, self.agent_log_level, logging.INFO))\n        logging.getLogger('tools').setLevel(getattr(logging, self.agent_log_level, logging.INFO))\n        logging.getLogger('BrowserSession').setLevel(getattr(logging, self.browser_use_log_level, logging.INFO))\n        logging.getLogger('openai').setLevel(getattr(logging, self.llm_log_level, logging.INFO))\n        logging.getLogger('httpx').setLevel(getattr(logging, self.llm_log_level, logging.INFO))\n        logging.getLogger('playwright').setLevel(getattr(logging, self.playwright_log_level, logging.WARNING))\n        \n        # Log configuration status\n        root_logger = logging.getLogger()\n        root_logger.info(\"=\" * 80)\n        root_logger.info(\"üîß DETAILED LOGGING ENABLED\")\n        root_logger.info(\"=\" * 80)\n        root_logger.info(f\"App Log Level: {self.app_log_level}\")\n        root_logger.info(f\"Browser-Use Log Level: {self.browser_use_log_level}\")\n        root_logger.info(f\"Agent Log Level: {self.agent_log_level}\")\n        root_logger.info(f\"LLM Log Level: {self.llm_log_level}\")\n        root_logger.info(f\"Playwright Log Level: {self.playwright_log_level}\")\n        root_logger.info(f\"Log LLM Requests: {self.log_llm_requests}\")\n        root_logger.info(f\"Log LLM Responses: {self.log_llm_responses}\")\n        root_logger.info(f\"Log Browser Actions: {self.log_browser_actions}\")\n        root_logger.info(f\"Log Page State: {self.log_page_state}\")\n        root_logger.info(f\"Log Performance: {self.log_performance}\")\n        root_logger.info(\"=\" * 80)\n\n\n# Global configurator instance\n_configurator = None\n\n\ndef get_logging_config():\n    \"\"\"Get the global logging configurator\"\"\"\n    global _configurator\n    if _configurator is None:\n        _configurator = LoggingConfigurator()\n    return _configurator\n\n\ndef should_log_llm_requests():\n    \"\"\"Check if LLM requests should be logged\"\"\"\n    return get_logging_config().log_llm_requests\n\n\ndef should_log_llm_responses():\n    \"\"\"Check if LLM responses should be logged\"\"\"\n    return get_logging_config().log_llm_responses\n\n\ndef should_log_browser_actions():\n    \"\"\"Check if browser actions should be logged\"\"\"\n    return get_logging_config().log_browser_actions\n\n\ndef should_log_page_state():\n    \"\"\"Check if page state should be logged\"\"\"\n    return get_logging_config().log_page_state\n\n\ndef should_log_performance():\n    \"\"\"Check if performance metrics should be logged\"\"\"\n    return get_logging_config().log_performance\n","size_bytes":5229},"app/static/js/configuration.js":{"content":"// Initialize detection when script loads\ndetectClientEnvironment();\n\n// Also initialize on DOMContentLoaded for direct page loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    detectClientEnvironment();\n    initializeSettings();\n});\n\nfunction detectClientEnvironment() {\n    const userAgent = navigator.userAgent;\n    const platform = navigator.platform;\n    \n    // Detect Operating System\n    let os = 'Unknown';\n    if (platform.indexOf('Win') !== -1) {\n        os = 'Windows';\n    } else if (platform.indexOf('Mac') !== -1) {\n        os = 'macOS';\n    } else if (platform.indexOf('Linux') !== -1) {\n        os = 'Linux';\n    } else if (/Android/.test(userAgent)) {\n        os = 'Android';\n    } else if (/iPhone|iPad|iPod/.test(userAgent)) {\n        os = 'iOS';\n    }\n    \n    // Detect Browser\n    let browser = 'Unknown';\n    if (/Edg/.test(userAgent)) {\n        browser = 'Microsoft Edge';\n    } else if (/Chrome/.test(userAgent) && !/Edg/.test(userAgent)) {\n        browser = 'Google Chrome';\n    } else if (/Safari/.test(userAgent) && !/Chrome/.test(userAgent)) {\n        browser = 'Safari';\n    } else if (/Firefox/.test(userAgent)) {\n        browser = 'Firefox';\n    } else if (/MSIE|Trident/.test(userAgent)) {\n        browser = 'Internet Explorer';\n    }\n    \n    // Update the page\n    const osElement = document.getElementById('client-os');\n    const browserElement = document.getElementById('client-browser');\n    \n    if (osElement) {\n        osElement.textContent = os;\n    }\n    \n    if (browserElement) {\n        browserElement.textContent = browser;\n    }\n}\n\nfunction initializeSettings() {\n    // Load saved settings from localStorage\n    const savedMode = localStorage.getItem('browserMode') || 'headful';\n    const savedEngine = localStorage.getItem('automationEngine') || 'browser_use';\n    \n    // Initialize engine selection\n    const browserUseBtn = document.getElementById('browser-use-btn');\n    const playwrightMcpBtn = document.getElementById('playwright-mcp-btn');\n    const engineDescription = document.getElementById('engine-description');\n    \n    if (browserUseBtn && playwrightMcpBtn && engineDescription) {\n        // Set initial engine state\n        if (savedEngine === 'playwright_mcp') {\n            browserUseBtn.classList.remove('active');\n            playwrightMcpBtn.classList.add('active');\n            engineDescription.innerHTML = '<strong>Playwright MCP:</strong> Uses Playwright MCP server with AI agents for automation (advanced, requires Node.js)';\n        } else {\n            browserUseBtn.classList.add('active');\n            playwrightMcpBtn.classList.remove('active');\n            engineDescription.innerHTML = '<strong>Browser Use:</strong> Uses browser-use library with Playwright for AI-powered automation (default, best for most tasks)';\n        }\n        \n        browserUseBtn.addEventListener('click', () => {\n            localStorage.setItem('automationEngine', 'browser_use');\n            browserUseBtn.classList.add('active');\n            playwrightMcpBtn.classList.remove('active');\n            engineDescription.innerHTML = '<strong>Browser Use:</strong> Uses browser-use library with Playwright for AI-powered automation (default, best for most tasks)';\n        });\n        \n        playwrightMcpBtn.addEventListener('click', () => {\n            localStorage.setItem('automationEngine', 'playwright_mcp');\n            playwrightMcpBtn.classList.add('active');\n            browserUseBtn.classList.remove('active');\n            engineDescription.innerHTML = '<strong>Playwright MCP:</strong> Uses Playwright MCP server with AI agents for automation (advanced, requires Node.js)';\n        });\n    }\n    \n    // Initialize headless/headful toggle\n    const headlessBtn = document.getElementById('headless-btn');\n    const headfulBtn = document.getElementById('headful-btn');\n    \n    // Set initial states based on saved settings\n    if (headlessBtn && headfulBtn) {\n        if (savedMode === 'headless') {\n            headlessBtn.classList.add('active');\n            headfulBtn.classList.remove('active');\n        } else {\n            headfulBtn.classList.add('active');\n            headlessBtn.classList.remove('active');\n        }\n        \n        headlessBtn.addEventListener('click', () => {\n            localStorage.setItem('browserMode', 'headless');\n            headlessBtn.classList.add('active');\n            headfulBtn.classList.remove('active');\n        });\n        \n        headfulBtn.addEventListener('click', () => {\n            localStorage.setItem('browserMode', 'headful');\n            headfulBtn.classList.add('active');\n            headlessBtn.classList.remove('active');\n        });\n    }\n}\n\n// Make function globally available for manual calls\nwindow.detectClientEnvironment = detectClientEnvironment;\n","size_bytes":4804},"app/engines/playwright_mcp/config/__init__.py":{"content":"\"\"\"Configuration for Playwright MCP Engine\"\"\"\n","size_bytes":46},"app/models.py":{"content":"\"\"\"\nDatabase Models for AI Browser Automation\n\"\"\"\nimport json\nfrom datetime import datetime\nfrom flask_sqlalchemy import SQLAlchemy\nfrom sqlalchemy.orm import DeclarativeBase\nfrom app.utils.encryption import credential_encryption\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\ndb = SQLAlchemy(model_class=Base)\n\n\nclass AutomationPlan(db.Model):\n    \"\"\"Model for storing automation plans generated by Planner Agent\"\"\"\n    \n    __tablename__ = 'automation_plans'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, index=True)\n    execution_id = db.Column(db.Integer, db.ForeignKey('execution_history.id'), nullable=True)\n    \n    goal = db.Column(db.Text, nullable=False)\n    start_url = db.Column(db.Text, nullable=False)\n    plan_yaml = db.Column(db.Text, nullable=False)\n    validated_locators = db.Column(db.Text, nullable=True)\n    plan_metadata = db.Column(db.Text, nullable=True)\n    \n    def to_dict(self):\n        \"\"\"Convert model to dictionary\"\"\"\n        return {\n            'id': self.id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'execution_id': self.execution_id,\n            'goal': self.goal,\n            'start_url': self.start_url,\n            'plan_yaml': self.plan_yaml,\n            'validated_locators': self.validated_locators,\n            'plan_metadata': self.plan_metadata\n        }\n\n\nclass GeneratedScript(db.Model):\n    \"\"\"Model for storing Python Playwright scripts generated by Generator Agent\"\"\"\n    \n    __tablename__ = 'generated_scripts'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, index=True)\n    execution_id = db.Column(db.Integer, db.ForeignKey('execution_history.id'), nullable=True)\n    plan_id = db.Column(db.Integer, db.ForeignKey('automation_plans.id'), nullable=True)\n    \n    script_type = db.Column(db.String(20), nullable=False, default='original')\n    python_code = db.Column(db.Text, nullable=False)\n    script_hash = db.Column(db.String(64), nullable=True)\n    \n    is_healed = db.Column(db.Boolean, nullable=False, default=False)\n    healing_iterations = db.Column(db.Integer, nullable=True, default=0)\n    \n    def to_dict(self):\n        \"\"\"Convert model to dictionary\"\"\"\n        return {\n            'id': self.id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'execution_id': self.execution_id,\n            'plan_id': self.plan_id,\n            'script_type': self.script_type,\n            'python_code': self.python_code,\n            'script_hash': self.script_hash,\n            'is_healed': self.is_healed,\n            'healing_iterations': self.healing_iterations\n        }\n\n\nclass TraceFile(db.Model):\n    \"\"\"Model for storing Playwright trace files for Healer Agent\"\"\"\n    \n    __tablename__ = 'trace_files'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, index=True)\n    execution_id = db.Column(db.Integer, db.ForeignKey('execution_history.id'), nullable=True)\n    script_id = db.Column(db.Integer, db.ForeignKey('generated_scripts.id'), nullable=True)\n    \n    trace_path = db.Column(db.Text, nullable=False)\n    trace_analysis = db.Column(db.Text, nullable=True)\n    identified_issues = db.Column(db.Text, nullable=True)\n    \n    def to_dict(self):\n        \"\"\"Convert model to dictionary\"\"\"\n        return {\n            'id': self.id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'execution_id': self.execution_id,\n            'script_id': self.script_id,\n            'trace_path': self.trace_path,\n            'trace_analysis': self.trace_analysis,\n            'identified_issues': self.identified_issues\n        }\n\n\nclass ExecutionHistory(db.Model):\n    \"\"\"Model for storing automation execution history\"\"\"\n    \n    __tablename__ = 'execution_history'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, index=True)\n    \n    prompt = db.Column(db.Text, nullable=False)\n    engine = db.Column(db.String(50), nullable=False)\n    headless = db.Column(db.Boolean, nullable=False, default=False)\n    \n    success = db.Column(db.Boolean, nullable=False, default=False)\n    error_message = db.Column(db.Text, nullable=True)\n    \n    screenshot_path = db.Column(db.Text, nullable=True)  # JSON array of screenshot paths\n    execution_logs = db.Column(db.Text, nullable=True)\n    \n    iterations = db.Column(db.Integer, nullable=True)\n    execution_time = db.Column(db.Float, nullable=True)\n    \n    automation_plans = db.relationship('AutomationPlan', backref='execution', lazy=True)\n    generated_scripts = db.relationship('GeneratedScript', backref='execution', lazy=True)\n    trace_files = db.relationship('TraceFile', backref='execution', lazy=True)\n    \n    def to_dict(self):\n        \"\"\"Convert model to dictionary\"\"\"\n        screenshots = []\n        if self.screenshot_path:\n            try:\n                screenshots = json.loads(self.screenshot_path)\n            except (json.JSONDecodeError, TypeError):\n                screenshots = [self.screenshot_path] if self.screenshot_path else []\n        \n        # Get generated and healed scripts\n        generated_script = None\n        healed_script = None\n        \n        # Find the most recent generated script (non-healed)\n        for script in sorted(self.generated_scripts, key=lambda x: x.created_at, reverse=True):\n            if not script.is_healed and not generated_script:\n                generated_script = script.python_code\n            elif script.is_healed and not healed_script:\n                healed_script = script.python_code\n        \n        return {\n            'id': self.id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'prompt': self.prompt,\n            'engine': self.engine,\n            'headless': self.headless,\n            'success': self.success,\n            'error_message': self.error_message,\n            'screenshot_path': self.screenshot_path,\n            'screenshots': screenshots,\n            'execution_logs': self.execution_logs,\n            'iterations': self.iterations,\n            'execution_time': self.execution_time,\n            'generated_script': generated_script,\n            'healed_script': healed_script\n        }\n\n\nclass CredentialVault(db.Model):\n    \"\"\"Model for securely storing website credentials with encryption\"\"\"\n    \n    __tablename__ = 'credential_vault'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, index=True)\n    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    name = db.Column(db.String(100), nullable=False, unique=True, index=True)\n    service = db.Column(db.String(200), nullable=True)\n    url = db.Column(db.Text, nullable=True)\n    username = db.Column(db.String(200), nullable=True)\n    encrypted_value = db.Column(db.Text, nullable=False)\n    description = db.Column(db.Text, nullable=True)\n    \n    def set_credential(self, plaintext_value: str):\n        \"\"\"Encrypt and store a credential value\"\"\"\n        self.encrypted_value = credential_encryption.encrypt(plaintext_value)\n    \n    def get_credential(self) -> str:\n        \"\"\"Decrypt and return the credential value\"\"\"\n        return credential_encryption.decrypt(self.encrypted_value)\n    \n    def to_dict(self, include_value=False):\n        \"\"\"\n        Convert model to dictionary\n        \n        Args:\n            include_value: If True, include the decrypted credential value.\n                          Should only be True when actually using the credential.\n        \"\"\"\n        result = {\n            'id': self.id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None,\n            'name': self.name,\n            'service': self.service,\n            'url': self.url,\n            'username': self.username,\n            'description': self.description\n        }\n        \n        if include_value:\n            result['value'] = self.get_credential()\n        \n        return result\n","size_bytes":8439},"app/routes/api.py":{"content":"\"\"\"\nAPI Routes\nRESTful endpoints for browser automation with security and validation\n\"\"\"\nimport os\nimport json\nimport logging\nimport threading\nfrom queue import Queue\nfrom datetime import datetime\nfrom flask import Blueprint, render_template, request, jsonify, Response, stream_with_context, current_app\nfrom app.models import db, ExecutionHistory, GeneratedScript, CredentialVault\nfrom app.services.engine_orchestrator import EngineOrchestrator\nfrom app.middleware.security import (\n    require_api_key,\n    rate_limit,\n    validate_engine_type,\n    validate_instruction,\n    sanitize_error_message\n)\nfrom app.utils.timeout import run_with_timeout, TimeoutError\nfrom app.utils.credentials import replace_credential_placeholders\n\nlogger = logging.getLogger(__name__)\n\ndef save_execution_to_history(instruction, engine_type, headless, result):\n    \"\"\"\n    Save execution result to history database\n    \n    Args:\n        instruction: The automation instruction\n        engine_type: The engine used (browser_use)\n        headless: Whether execution was headless\n        result: The execution result dictionary\n    \"\"\"\n    try:\n        # Handle screenshot paths - convert array to JSON or handle single path\n        screenshot_paths = result.get('screenshot_paths', [])\n        screenshot_path_json = None\n        \n        if screenshot_paths and isinstance(screenshot_paths, list):\n            screenshot_path_json = json.dumps(screenshot_paths)\n        elif result.get('screenshot_path'):\n            # Handle legacy single screenshot path\n            screenshot_path_json = json.dumps([result.get('screenshot_path')])\n        \n        # Map 'steps' to 'history' for display - BrowserAgent returns steps, not history\n        execution_history = result.get('history') or result.get('steps', [])\n        \n        history_entry = ExecutionHistory(\n            prompt=instruction,\n            engine=engine_type,\n            headless=headless,\n            success=result.get('success', False),\n            error_message=result.get('error') or result.get('message') if not result.get('success') else None,\n            screenshot_path=screenshot_path_json,\n            execution_logs=json.dumps(execution_history) if execution_history else None,\n            iterations=result.get('iterations'),\n            execution_time=result.get('execution_time')\n        )\n        \n        db.session.add(history_entry)\n        db.session.flush()  # Flush to get the history_entry.id\n        \n        # Save generated Python code if available\n        python_code = result.get('playwright_code')\n        if python_code:\n            import hashlib\n            script_hash = hashlib.sha256(python_code.encode()).hexdigest()\n            \n            generated_script = GeneratedScript(\n                execution_id=history_entry.id,\n                python_code=python_code,\n                script_hash=script_hash,\n                is_healed=False,\n                healing_iterations=0\n            )\n            db.session.add(generated_script)\n            logger.info(f\"üíæ Saved generated Python script (hash: {script_hash[:8]}...)\")\n        \n        # Save healed code if available\n        if result.get('healed_code'):\n            import hashlib\n            healed_code = result.get('healed_code')\n            script_hash = hashlib.sha256(healed_code.encode()).hexdigest()\n            \n            healed_script = GeneratedScript(\n                execution_id=history_entry.id,\n                python_code=healed_code,\n                script_hash=script_hash,\n                is_healed=True,\n                healing_iterations=result.get('healing_iterations', 1)\n            )\n            db.session.add(healed_script)\n            logger.info(f\"üíæ Saved healed Python script (hash: {script_hash[:8]}...)\")\n        \n        db.session.commit()\n        \n        logger.info(f\"üíæ Saved execution to history (ID: {history_entry.id})\")\n        return history_entry.id\n        \n    except Exception as e:\n        db.session.rollback()\n        logger.error(f\"Failed to save execution to history: {str(e)}\", exc_info=True)\n        return None\n\n\ndef create_api_routes(orchestrator: EngineOrchestrator) -> Blueprint:\n    \"\"\"\n    Create API routes blueprint\n    \n    Args:\n        orchestrator: Engine orchestrator instance\n        \n    Returns:\n        Flask Blueprint with all routes\n    \"\"\"\n    api = Blueprint('api', __name__)\n    \n    @api.route('/')\n    def index():\n        \"\"\"Render dashboard page\"\"\"\n        return render_template('dashboard.html')\n    \n    @api.route('/history')\n    def history():\n        \"\"\"Render history page\"\"\"\n        return render_template('history.html')\n    \n    @api.route('/configuration')\n    def configuration():\n        \"\"\"Render configuration page\"\"\"\n        return render_template('configuration.html')\n    \n    @api.route('/credentials')\n    def credentials():\n        \"\"\"Render credentials manager page\"\"\"\n        return render_template('credentials.html')\n    \n    @api.route('/api/execute', methods=['POST'])\n    @require_api_key\n    @rate_limit\n    def execute_instruction():\n        \"\"\"Execute a browser automation instruction\"\"\"\n        try:\n            data = request.get_json()\n            \n            if not data:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid request',\n                    'message': 'Request body must be valid JSON'\n                }), 400\n            \n            instruction = data.get('instruction', '').strip()\n            engine_type = data.get('engine', 'browser_use')\n            headless = data.get('headless', False)\n            \n            is_valid, error_msg = validate_instruction(instruction)\n            if not is_valid:\n                logger.warning(f\"‚ö†Ô∏è  Invalid instruction: {error_msg}\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid instruction',\n                    'message': error_msg\n                }), 400\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                logger.warning(f\"‚ö†Ô∏è  Invalid engine type: {error_msg}\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            if not isinstance(headless, bool):\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid parameter',\n                    'message': 'headless must be a boolean'\n                }), 400\n            \n            # Store original instruction for database (with placeholders)\n            original_instruction = instruction\n            \n            # Replace credential placeholders with actual values\n            try:\n                processed_instruction, credentials_used = replace_credential_placeholders(instruction)\n                if credentials_used:\n                    logger.info(f\"üîê Using {len(credentials_used)} credential(s): {', '.join(credentials_used)}\")\n            except ValueError as e:\n                logger.warning(f\"‚ö†Ô∏è  Credential replacement failed: {str(e)}\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Missing credentials',\n                    'message': str(e)\n                }), 400\n            \n            logger.info(\"=\"*80)\n            logger.info(\"üì® NEW AUTOMATION REQUEST\")\n            logger.info(f\"üìù Instruction: {original_instruction}\")\n            logger.info(f\"üîß Engine: {engine_type}\")\n            logger.info(f\"üëÅÔ∏è  Headless: {headless}\")\n            logger.info(f\"üåê Client: {request.remote_addr}\")\n            logger.info(\"=\"*80)\n            \n            logger.info(\"üöÄ Starting automation execution...\")\n            \n            try:\n                result = run_with_timeout(\n                    orchestrator.execute_instruction,\n                    300,\n                    processed_instruction,\n                    engine_type,\n                    headless,\n                    None  # progress_callback\n                )\n            except TimeoutError as e:\n                logger.error(f\"‚è±Ô∏è  Automation timed out: {str(e)}\")\n                orchestrator.cleanup_after_timeout(engine_type, headless)\n                return jsonify({\n                    'success': False,\n                    'error': 'Timeout',\n                    'message': 'Operation timed out. The task took longer than 5 minutes to complete.',\n                    'timeout': True\n                }), 408\n            \n            if result.get('success'):\n                logger.info(f\"‚úÖ Automation completed successfully in {result.get('iterations', 0)} steps\")\n            else:\n                logger.error(f\"‚ùå Automation failed: {result.get('error', 'Unknown error')}\")\n            \n            save_execution_to_history(original_instruction, engine_type, headless, result)\n            \n            logger.info(\"=\"*80)\n            \n            return jsonify(result)\n            \n        except Exception as e:\n            logger.error(f\"üí• Exception in execute_instruction: {str(e)}\", exc_info=True)\n            \n            user_message = sanitize_error_message(e)\n            \n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': user_message\n            }), 500\n    \n    @api.route('/api/execute/stream', methods=['POST'])\n    @require_api_key\n    @rate_limit\n    def execute_instruction_stream():\n        \"\"\"Execute a browser automation instruction with Server-Sent Events streaming\"\"\"\n        def generate_progress():\n            \"\"\"Generator function for SSE streaming\"\"\"\n            try:\n                data = request.get_json()\n                \n                if not data:\n                    yield f\"data: {json.dumps({'type': 'error', 'error': 'Invalid request', 'message': 'Request body must be valid JSON'})}\\n\\n\"\n                    return\n                \n                instruction = data.get('instruction', '').strip()\n                engine_type = data.get('engine', 'browser_use')\n                headless = data.get('headless', False)\n                \n                # Validation\n                is_valid, error_msg = validate_instruction(instruction)\n                if not is_valid:\n                    logger.warning(f\"‚ö†Ô∏è  Invalid instruction: {error_msg}\")\n                    yield f\"data: {json.dumps({'type': 'error', 'error': 'Invalid instruction', 'message': error_msg})}\\n\\n\"\n                    return\n                \n                is_valid, error_msg = validate_engine_type(engine_type)\n                if not is_valid:\n                    logger.warning(f\"‚ö†Ô∏è  Invalid engine type: {error_msg}\")\n                    yield f\"data: {json.dumps({'type': 'error', 'error': 'Invalid engine type', 'message': error_msg})}\\n\\n\"\n                    return\n                \n                if not isinstance(headless, bool):\n                    yield f\"data: {json.dumps({'type': 'error', 'error': 'Invalid parameter', 'message': 'headless must be a boolean'})}\\n\\n\"\n                    return\n                \n                # Store original instruction for database (with placeholders)\n                original_instruction = instruction\n                \n                # Replace credential placeholders with actual values\n                try:\n                    processed_instruction, credentials_used = replace_credential_placeholders(instruction)\n                    if credentials_used:\n                        logger.info(f\"üîê Using {len(credentials_used)} credential(s): {', '.join(credentials_used)}\")\n                except ValueError as e:\n                    logger.warning(f\"‚ö†Ô∏è  Credential replacement failed: {str(e)}\")\n                    yield f\"data: {json.dumps({'type': 'error', 'error': 'Missing credentials', 'message': str(e)})}\\n\\n\"\n                    return\n                \n                logger.info(\"=\"*80)\n                logger.info(\"üì® NEW AUTOMATION REQUEST (STREAMING)\")\n                logger.info(f\"üìù Instruction: {original_instruction}\")\n                logger.info(f\"üîß Engine: {engine_type}\")\n                logger.info(f\"üëÅÔ∏è  Headless: {headless}\")\n                logger.info(f\"üåê Client: {request.remote_addr}\")\n                logger.info(\"=\"*80)\n                \n                # Send start event\n                yield f\"data: {json.dumps({'type': 'start', 'message': 'Starting automation...'})}\\n\\n\"\n                \n                # Create a queue for progress updates\n                progress_queue = Queue()\n                result_holder = {}\n                \n                # Capture the Flask app object for use in the thread\n                app = current_app._get_current_object()\n                \n                def progress_callback(event_type, data):\n                    \"\"\"Callback function to send progress updates\"\"\"\n                    progress_queue.put({'type': event_type, 'data': data})\n                \n                def execute_in_thread():\n                    \"\"\"Execute automation in a separate thread\"\"\"\n                    try:\n                        result = orchestrator.execute_instruction_with_progress(\n                            processed_instruction,\n                            engine_type,\n                            headless,\n                            progress_callback\n                        )\n                        result_holder['result'] = result\n                        # Use app context for database operations in thread\n                        with app.app_context():\n                            save_execution_to_history(original_instruction, engine_type, headless, result)\n                        progress_queue.put({'type': 'done', 'result': result})\n                    except Exception as e:\n                        logger.error(f\"üí• Exception in threaded execution: {str(e)}\", exc_info=True)\n                        result_holder['error'] = str(e)\n                        error_result = {\n                            'success': False,\n                            'error': str(e),\n                            'message': sanitize_error_message(e)\n                        }\n                        # Use app context for database operations in thread\n                        with app.app_context():\n                            save_execution_to_history(original_instruction, engine_type, headless, error_result)\n                        progress_queue.put({'type': 'error', 'error': str(e), 'message': sanitize_error_message(e)})\n                \n                # Start execution in thread\n                execution_thread = threading.Thread(target=execute_in_thread)\n                execution_thread.daemon = True\n                execution_thread.start()\n                \n                # Stream progress updates\n                while True:\n                    event = progress_queue.get()\n                    \n                    if event['type'] == 'done':\n                        # Send final result\n                        yield f\"data: {json.dumps(event)}\\n\\n\"\n                        logger.info(\"‚úÖ Streaming completed successfully\")\n                        break\n                    elif event['type'] == 'error':\n                        # Send error and stop\n                        yield f\"data: {json.dumps(event)}\\n\\n\"\n                        logger.error(f\"‚ùå Streaming failed: {event.get('error')}\")\n                        break\n                    else:\n                        # Send progress update\n                        yield f\"data: {json.dumps(event)}\\n\\n\"\n                \n                logger.info(\"=\"*80)\n                \n            except Exception as e:\n                logger.error(f\"üí• Exception in SSE streaming: {str(e)}\", exc_info=True)\n                yield f\"data: {json.dumps({'type': 'error', 'error': 'Internal error', 'message': sanitize_error_message(e)})}\\n\\n\"\n        \n        return Response(\n            stream_with_context(generate_progress()),\n            mimetype='text/event-stream',\n            headers={\n                'Cache-Control': 'no-cache',\n                'X-Accel-Buffering': 'no',\n                'Connection': 'keep-alive'\n            }\n        )\n    \n    @api.route('/api/tools', methods=['GET'])\n    def get_tools():\n        \"\"\"Get available browser tools\"\"\"\n        try:\n            engine_type = request.args.get('engine', 'browser_use')\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            tools = orchestrator.get_tools(engine_type)\n            \n            return jsonify({\n                'success': True,\n                'tools': tools,\n                'engine': engine_type\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error getting tools: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/reset', methods=['POST'])\n    @require_api_key\n    def reset_agent():\n        \"\"\"Reset the browser agent\"\"\"\n        try:\n            data = request.get_json() or {}\n            engine_type = data.get('engine', 'browser_use')\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            orchestrator.reset_agent(engine_type)\n            \n            return jsonify({\n                'success': True,\n                'message': 'Agent reset successfully',\n                'engine': engine_type\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error resetting agent: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/health', methods=['GET'])\n    def health_check():\n        \"\"\"Health check endpoint\"\"\"\n        try:\n            return jsonify({\n                'status': 'healthy',\n                'engines': {\n                    'browser_use': 'available'\n                },\n                'message': 'AI browser automation ready',\n                'security': {\n                    'authentication': 'enabled' if os.environ.get('API_KEY') else 'disabled',\n                    'rate_limiting': 'enabled'\n                }\n            })\n        except Exception as e:\n            logger.error(f\"Health check failed: {str(e)}\", exc_info=True)\n            return jsonify({\n                'status': 'unhealthy',\n                'error': 'Service unavailable'\n            }), 503\n    \n    @api.route('/api/history', methods=['GET'])\n    def get_history():\n        \"\"\"Get all execution history\"\"\"\n        try:\n            page = request.args.get('page', 1, type=int)\n            per_page = request.args.get('per_page', 20, type=int)\n            \n            history_query = ExecutionHistory.query.order_by(\n                ExecutionHistory.created_at.desc()\n            ).paginate(page=page, per_page=per_page, error_out=False)\n            \n            return jsonify({\n                'success': True,\n                'history': [item.to_dict() for item in history_query.items],\n                'total': history_query.total,\n                'page': page,\n                'pages': history_query.pages,\n                'per_page': per_page\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error getting history: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/history/<int:history_id>', methods=['GET'])\n    def get_history_item(history_id):\n        \"\"\"Get a specific execution history item\"\"\"\n        try:\n            item = ExecutionHistory.query.get(history_id)\n            \n            if not item:\n                return jsonify({\n                    'success': False,\n                    'error': 'Not found',\n                    'message': 'History item not found'\n                }), 404\n            \n            return jsonify({\n                'success': True,\n                'history': item.to_dict()\n            })\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error getting history item: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/history', methods=['DELETE'])\n    @require_api_key\n    def delete_all_history():\n        \"\"\"Delete all execution history\"\"\"\n        try:\n            count = ExecutionHistory.query.delete()\n            db.session.commit()\n            \n            logger.info(f\"üóëÔ∏è  Deleted {count} history items\")\n            \n            return jsonify({\n                'success': True,\n                'message': f'Deleted {count} history items',\n                'count': count\n            })\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error deleting history: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/history/<int:history_id>', methods=['DELETE'])\n    @require_api_key\n    def delete_history_item(history_id):\n        \"\"\"Delete a specific execution history item\"\"\"\n        try:\n            item = ExecutionHistory.query.get(history_id)\n            \n            if not item:\n                return jsonify({\n                    'success': False,\n                    'error': 'Not found',\n                    'message': 'History item not found'\n                }), 404\n            \n            db.session.delete(item)\n            db.session.commit()\n            \n            logger.info(f\"üóëÔ∏è  Deleted history item {history_id}\")\n            \n            return jsonify({\n                'success': True,\n                'message': 'History item deleted'\n            })\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error deleting history item: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/credentials', methods=['GET'])\n    def list_credentials():\n        \"\"\"\n        List all stored credentials (without values)\n        \"\"\"\n        try:\n            credentials = CredentialVault.query.order_by(CredentialVault.created_at.desc()).all()\n            return jsonify({\n                'success': True,\n                'credentials': [cred.to_dict(include_value=False) for cred in credentials]\n            })\n        except Exception as e:\n            logger.error(f\"Error listing credentials: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Failed to list credentials',\n                'message': str(e)\n            }), 500\n    \n    @api.route('/api/credentials', methods=['POST'])\n    def create_credential():\n        \"\"\"\n        Create a new credential\n        \n        Request body:\n            {\n                \"name\": \"gmail_password\",\n                \"service\": \"Gmail\",\n                \"username\": \"user@example.com\",\n                \"value\": \"secretPassword123\",\n                \"description\": \"My Gmail password\"\n            }\n        \"\"\"\n        try:\n            data = request.get_json()\n            \n            if not data:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid request',\n                    'message': 'Request body must be valid JSON'\n                }), 400\n            \n            name = data.get('name', '').strip()\n            value = data.get('value', '').strip()\n            \n            if not name:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid input',\n                    'message': 'Credential name is required'\n                }), 400\n            \n            if not value:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid input',\n                    'message': 'Credential value is required'\n                }), 400\n            \n            # Check if credential with this name already exists\n            existing = CredentialVault.query.filter_by(name=name).first()\n            if existing:\n                return jsonify({\n                    'success': False,\n                    'error': 'Credential exists',\n                    'message': f'A credential with name \"{name}\" already exists'\n                }), 409\n            \n            # Create new credential\n            credential = CredentialVault(\n                name=name,\n                service=data.get('service', '').strip() or None,\n                url=data.get('url', '').strip() or None,\n                username=data.get('username', '').strip() or None,\n                description=data.get('description', '').strip() or None\n            )\n            credential.set_credential(value)\n            \n            db.session.add(credential)\n            db.session.commit()\n            \n            logger.info(f\"‚úÖ Created new credential: {name}\")\n            \n            return jsonify({\n                'success': True,\n                'message': 'Credential created successfully',\n                'credential': credential.to_dict(include_value=False)\n            }), 201\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error creating credential: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Failed to create credential',\n                'message': str(e)\n            }), 500\n    \n    @api.route('/api/credentials/<int:credential_id>', methods=['GET'])\n    def get_credential(credential_id):\n        \"\"\"\n        Get a specific credential (without value)\n        \"\"\"\n        try:\n            credential = CredentialVault.query.get(credential_id)\n            \n            if not credential:\n                return jsonify({\n                    'success': False,\n                    'error': 'Not found',\n                    'message': 'Credential not found'\n                }), 404\n            \n            return jsonify({\n                'success': True,\n                'credential': credential.to_dict(include_value=False)\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error getting credential: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Failed to get credential',\n                'message': str(e)\n            }), 500\n    \n    @api.route('/api/credentials/<int:credential_id>', methods=['PUT'])\n    def update_credential(credential_id):\n        \"\"\"\n        Update an existing credential\n        \"\"\"\n        try:\n            credential = CredentialVault.query.get(credential_id)\n            \n            if not credential:\n                return jsonify({\n                    'success': False,\n                    'error': 'Not found',\n                    'message': 'Credential not found'\n                }), 404\n            \n            data = request.get_json()\n            \n            if not data:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid request',\n                    'message': 'Request body must be valid JSON'\n                }), 400\n            \n            # Update fields if provided\n            if 'name' in data and data['name'].strip():\n                new_name = data['name'].strip()\n                # Check if another credential has this name\n                existing = CredentialVault.query.filter_by(name=new_name).first()\n                if existing and existing.id != credential_id:\n                    return jsonify({\n                        'success': False,\n                        'error': 'Credential exists',\n                        'message': f'A credential with name \"{new_name}\" already exists'\n                    }), 409\n                credential.name = new_name\n            \n            if 'service' in data:\n                credential.service = data['service'].strip() or None\n            \n            if 'url' in data:\n                credential.url = data['url'].strip() or None\n            \n            if 'username' in data:\n                credential.username = data['username'].strip() or None\n            \n            if 'description' in data:\n                credential.description = data['description'].strip() or None\n            \n            if 'value' in data and data['value'].strip():\n                credential.set_credential(data['value'].strip())\n            \n            db.session.commit()\n            \n            logger.info(f\"‚úÖ Updated credential: {credential.name}\")\n            \n            return jsonify({\n                'success': True,\n                'message': 'Credential updated successfully',\n                'credential': credential.to_dict(include_value=False)\n            })\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error updating credential: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Failed to update credential',\n                'message': str(e)\n            }), 500\n    \n    @api.route('/api/credentials/<int:credential_id>', methods=['DELETE'])\n    def delete_credential(credential_id):\n        \"\"\"\n        Delete a credential\n        \"\"\"\n        try:\n            credential = CredentialVault.query.get(credential_id)\n            \n            if not credential:\n                return jsonify({\n                    'success': False,\n                    'error': 'Not found',\n                    'message': 'Credential not found'\n                }), 404\n            \n            credential_name = credential.name\n            db.session.delete(credential)\n            db.session.commit()\n            \n            logger.info(f\"üóëÔ∏è  Deleted credential: {credential_name}\")\n            \n            return jsonify({\n                'success': True,\n                'message': 'Credential deleted successfully'\n            })\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error deleting credential: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Failed to delete credential',\n                'message': str(e)\n            }), 500\n    \n    return api\n","size_bytes":31814},"app/engines/browser_use/engine_optimized.py":{"content":"\"\"\"\nOptimized Browser-Use Engine\nAI-powered browser automation with advanced features and optimizations\n\nNew Features:\n- Advanced browser capabilities (screenshots, PDFs, cookies, sessions)\n- Enhanced popup handling with configurable timeouts\n- Smart retry mechanism with exponential backoff\n- State management for complex workflows\n- Data extraction capabilities\n- Performance monitoring and metrics\n\"\"\"\nimport os\nimport asyncio\nimport configparser\nimport logging\nimport time\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# PRIVACY: Disable all external data transmission BEFORE importing browser-use\n# This prevents telemetry and cloud sync from being initialized\nos.environ.setdefault('ANONYMIZED_TELEMETRY', 'false')\nos.environ.setdefault('BROWSER_USE_CLOUD_SYNC', 'false')\nfrom browser_use import Agent, Browser\nfrom browser_use.llm import ChatOpenAI\nfrom auth.oauth_handler import get_oauth_token_with_retry\nfrom app.utils.logging_config import (\n    should_log_llm_requests, \n    should_log_llm_responses,\n    should_log_browser_actions,\n    should_log_page_state,\n    should_log_performance\n)\n\n# Import ChatBrowserUse for optimized browser automation (3-5x faster)\ntry:\n    from browser_use.llm import ChatBrowserUse\n    CHAT_BROWSER_USE_AVAILABLE = True\nexcept ImportError:\n    CHAT_BROWSER_USE_AVAILABLE = False\n\nfrom app.engines.browser_use.advanced_features import AdvancedBrowserFeatures\nfrom app.engines.browser_use.retry_mechanism import RetryConfig, RetryMechanism\nfrom app.engines.browser_use.state_manager import WorkflowState\nfrom app.engines.browser_use.data_extractor import DataExtractor\nfrom app.engines.browser_use.performance_monitor import PerformanceMonitor\n\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\nlogger = logging.getLogger(__name__)\n\n\nclass OptimizedBrowserUseEngine:\n    \"\"\"\n    Optimized browser automation engine with advanced capabilities\n    \n    Features:\n    - Screenshot capture and PDF generation\n    - Cookie and session management\n    - Smart retry with exponential backoff\n    - Workflow state persistence\n    - Data extraction (tables, lists, metadata)\n    - Performance monitoring\n    - Enhanced popup handling\n    \"\"\"\n    \n    def __init__(self, headless: bool = False, enable_advanced_features: bool = True):\n        \"\"\"\n        Initialize Optimized Browser-Use Engine\n        \n        Args:\n            headless: Run browser in headless mode\n            enable_advanced_features: Enable advanced capabilities\n        \"\"\"\n        self.headless = headless\n        self.enable_advanced_features = enable_advanced_features\n        \n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        gateway_base_url = os.environ.get('GW_BASE_URL')\n        if not gateway_base_url:\n            raise ValueError(\"GW_BASE_URL must be set as environment variable to connect to the gateway endpoint.\")\n        \n        try:\n            oauth_token = get_oauth_token_with_retry(max_retries=3)\n        except Exception as e:\n            raise ValueError(f\"Failed to obtain OAuth token: {str(e)}. Please check your OAuth configuration.\")\n        \n        model = config.get('openai', 'model', fallback='gpt-4.1-2025-04-14-eastus-dz')\n        timeout = int(config.get('openai', 'timeout', fallback='180'))\n        self.max_steps = int(config.get('agent', 'max_steps', fallback='25'))\n        \n        # Logging flags\n        self.log_llm_requests = should_log_llm_requests()\n        self.log_llm_responses = should_log_llm_responses()\n        self.log_browser_actions = should_log_browser_actions()\n        self.log_page_state = should_log_page_state()\n        self.log_performance = should_log_performance()\n        \n        # Verification keywords to detect validation requirements\n        self.verification_keywords = [\n            'verify', 'check', 'ensure', 'validate', 'assert', \n            'confirm', 'test', 'must', 'should contain', 'should have',\n            'expect', 'required', 'make sure', 'assert that'\n        ]\n        \n        # Browser performance settings - using reliable defaults\n        self.minimum_wait_page_load_time = float(config.get('browser_performance', 'minimum_wait_page_load_time', fallback='1.0'))\n        self.wait_for_network_idle_page_load_time = float(config.get('browser_performance', 'wait_for_network_idle_page_load_time', fallback='1.5'))\n        self.wait_between_actions = float(config.get('browser_performance', 'wait_between_actions', fallback='1.0'))\n        \n        # Use ChatBrowserUse model if enabled (3-5x faster for browser automation)\n        use_chat_browser_use = config.getboolean('openai', 'use_chat_browser_use', fallback=False)\n        \n        if use_chat_browser_use and CHAT_BROWSER_USE_AVAILABLE:\n            logger.info(\"üöÄ Using ChatBrowserUse optimized model (3-5x faster)\")\n            self.llm = ChatBrowserUse()\n        else:\n            if use_chat_browser_use and not CHAT_BROWSER_USE_AVAILABLE:\n                logger.warning(\"‚ö†Ô∏è  ChatBrowserUse not available, falling back to standard OpenAI model\")\n            logger.info(f\"Using gateway model: {model} via {gateway_base_url}\")\n            self.llm = ChatOpenAI(\n                model=model,\n                base_url=gateway_base_url,\n                api_key=oauth_token,\n                default_headers={\n                    \"Authorization\": f\"Bearer {oauth_token}\"\n                },\n                timeout=timeout\n            )\n        \n        if enable_advanced_features:\n            output_dir = config.get('advanced_features', 'output_directory', fallback='automation_outputs')\n            self.enable_screenshots = config.getboolean('advanced_features', 'enable_screenshots', fallback=True)\n            self.enable_pdf_generation = config.getboolean('advanced_features', 'enable_pdf_generation', fallback=True)\n            self.enable_cookie_management = config.getboolean('advanced_features', 'enable_cookie_management', fallback=True)\n            self.enable_state_persistence = config.getboolean('advanced_features', 'enable_state_persistence', fallback=True)\n            \n            self.advanced_features = AdvancedBrowserFeatures(output_dir=output_dir)\n            \n            max_retries = int(config.get('retry', 'max_retries', fallback='3'))\n            initial_delay = float(config.get('retry', 'initial_delay', fallback='1.0'))\n            max_delay = float(config.get('retry', 'max_delay', fallback='30.0'))\n            backoff_factor = float(config.get('retry', 'backoff_factor', fallback='2.0'))\n            \n            retry_config = RetryConfig(\n                max_retries=max_retries,\n                initial_delay=initial_delay,\n                max_delay=max_delay,\n                backoff_factor=backoff_factor\n            )\n            self.retry_mechanism = RetryMechanism(retry_config)\n            \n            track_metrics = config.getboolean('performance', 'track_detailed_metrics', fallback=True)\n            self.performance_monitor = PerformanceMonitor(track_detailed_metrics=track_metrics)\n            \n            self.data_extractor = DataExtractor()\n            self.workflow_state = None\n            \n            logger.info(\"üöÄ Advanced features enabled: Screenshots, PDFs, Cookies, Retry, Performance Tracking\")\n        else:\n            logger.info(\"‚ÑπÔ∏è  Running in basic mode (advanced features disabled)\")\n    \n    def _has_verification_requirements(self, instruction: str) -> bool:\n        \"\"\"\n        Check if the instruction contains verification/validation requirements\n        \n        Args:\n            instruction: User's instruction\n            \n        Returns:\n            True if instruction contains verification keywords\n        \"\"\"\n        instruction_lower = instruction.lower()\n        return any(keyword in instruction_lower for keyword in self.verification_keywords)\n    \n    def _check_verification_failure(self, final_result: Any, steps: List[Dict], instruction: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Check if verification failed based on final result and steps\n        \n        Args:\n            final_result: Final result from agent execution\n            steps: List of executed steps\n            instruction: Original instruction\n            \n        Returns:\n            Dict with verification failure info if detected, None otherwise\n        \"\"\"\n        if not final_result:\n            return None\n        \n        result_str = str(final_result).lower()\n        \n        # First check for explicit success indicators - if found, verification passed\n        success_indicators = [\n            'verification passed', 'check passed', 'verified successfully',\n            'validation passed', 'assertion passed', 'confirmed successfully'\n        ]\n        if any(indicator in result_str for indicator in success_indicators):\n            return None  # Verification explicitly passed\n        \n        # More specific failure indicators to avoid false positives\n        failure_indicators = [\n            'verification failed', 'check failed', 'assertion failed',\n            'validation failed', 'not found', 'does not exist',\n            'could not find', 'unable to find', 'did not find',\n            'missing element', 'element missing', 'cannot locate',\n            'no such element', 'not present on', 'not visible',\n            'failed to verify', 'failed to validate', 'failed to confirm'\n        ]\n        \n        has_verification = self._has_verification_requirements(instruction)\n        has_failure = any(indicator in result_str for indicator in failure_indicators)\n        \n        if has_verification and has_failure:\n            return {\n                'verification_failed': True,\n                'reason': str(final_result)[:300],  # Limit length\n                'instruction': instruction,\n                'completed_steps': len(steps)\n            }\n        \n        return None\n    \n    async def execute_instruction(self, instruction: str, \n                                  workflow_id: Optional[str] = None,\n                                  save_screenshot: bool = False,\n                                  save_pdf: bool = False,\n                                  progress_callback=None) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction with advanced features\n        \n        Args:\n            instruction: User's natural language instruction\n            workflow_id: Optional workflow ID for state management\n            save_screenshot: Capture screenshot after completion\n            save_pdf: Generate PDF after completion\n            progress_callback: Optional callback for progress updates\n            \n        Returns:\n            Dictionary with execution results and advanced metrics\n        \"\"\"\n        # Input validation\n        if not instruction or not instruction.strip():\n            logger.error(\"‚ùå Empty instruction provided\")\n            return {\n                \"success\": False,\n                \"error\": \"Instruction cannot be empty\",\n                \"error_type\": \"ValidationError\",\n                \"steps\": [],\n                \"iterations\": 0\n            }\n        \n        instruction = instruction.strip()\n        op_id = None\n        browser = None\n        if self.enable_advanced_features:\n            op_id = self.performance_monitor.start_operation(\"execute_instruction\")\n            \n            if workflow_id:\n                self.workflow_state = WorkflowState(workflow_id=workflow_id, persist_to_disk=True)\n        \n        try:\n            logger.info(\"ü§ñ Initializing Browser-Use Agent\")\n            logger.info(f\"üìã Task: {instruction}\")\n            logger.info(f\"üî¢ Max steps: {self.max_steps}\")\n            \n            # Send initialization progress\n            if progress_callback:\n                progress_callback('init', {'message': 'Initializing browser automation agent...', 'instruction': instruction})\n            \n            # System instructions optimized for efficiency while maintaining safety\n            # Fix from https://github.com/browser-use/browser-use/pull/235 to prevent going beyond task\n            system_instructions = f\"\"\"\nYOUR ULTIMATE TASK: \"{instruction}\"\n\n‚ö†Ô∏è CRITICAL - GOAL-BASED EXECUTION ‚ö†Ô∏è\nIdentify the GOAL of the task, then stop immediately once that goal is achieved.\nYou MAY make auxiliary decisions to achieve the goal (wait for pages, handle popups, retry actions).\nYou MUST NOT perform actions beyond achieving the stated goal.\n\nEXECUTION APPROACH:\n1. Parse the task to identify the GOAL (the end state to achieve)\n2. Make necessary auxiliary decisions to reach that goal:\n   ‚úÖ Wait for pages to load\n   ‚úÖ Handle popups or dialog boxes that block progress\n   ‚úÖ Retry failed actions (element not found, slow page load)\n   ‚úÖ Navigate through necessary intermediate steps\n3. Once the GOAL is achieved ‚Üí IMMEDIATELY use done()\n4. Do NOT perform additional \"helpful\" actions beyond the goal\n\nEXAMPLES OF GOAL-BASED EXECUTION:\n\nTask: \"open linkedin.com click join now\"\n‚Üí GOAL: Click the \"join now\" button on LinkedIn\n‚Üí ‚úÖ Correct: Navigate to linkedin.com ‚Üí Wait for page ‚Üí Click \"join now\" ‚Üí Verify click succeeded ‚Üí done()\n‚Üí ‚ùå Wrong: Navigate ‚Üí Click \"join now\" ‚Üí Fill email ‚Üí Fill password (GOAL was already achieved after clicking!)\n\nTask: \"go to amazon.com and search for laptop\"\n‚Üí GOAL: Execute a search for \"laptop\" on Amazon\n‚Üí ‚úÖ Correct: Navigate ‚Üí Wait for page ‚Üí Type \"laptop\" in search ‚Üí Click search button ‚Üí done()\n‚Üí ‚ùå Wrong: Navigate ‚Üí Search ‚Üí Click first result ‚Üí View product details (GOAL was achieved after search!)\n\nTask: \"fill in the email field with test@example.com and submit the form\"\n‚Üí GOAL: Submit form with email filled\n‚Üí ‚úÖ Correct: Fill email ‚Üí Click submit ‚Üí Wait for submission ‚Üí done()\n‚Üí ‚ùå Wrong: Stop after filling email (GOAL requires submitting!)\n\nCRITICAL: STOP IMMEDIATELY AFTER GOAL IS ACHIEVED\n‚Üí Do NOT fill forms unless required to achieve the goal\n‚Üí Do NOT click buttons unless required to achieve the goal\n‚Üí Do NOT navigate to pages unless required to achieve the goal\n‚Üí Ask yourself: \"Have I achieved the stated goal?\" If yes ‚Üí done()\n\nAUXILIARY DECISIONS (ALLOWED):\n- Waiting for pages/elements to load\n- Handling popups that block the goal\n- Retrying actions that fail due to timing\n- Navigating to intermediate pages to reach the goal\n- Verifying that actions succeeded\n\nPAGE LOADING & ERRORS:\n- If element not found ‚Üí page still loading ‚Üí wait 2s ‚Üí retry with fresh page state\n- Verify critical actions succeeded before done()\n- If action fails after retries ‚Üí report failure and use done()\n\n‚ö†Ô∏è INTELLIGENT DROPDOWN HANDLING ‚ö†Ô∏è\nWhen interacting with dropdown lists or select elements, use these strategies:\n\n1. NATIVE HTML SELECT ELEMENTS:\n   - Use select_option() or click() to interact with <select> elements\n   - You can select by visible text, value attribute, or index\n   - Example: Select \"United States\" from country dropdown\n   \n2. CUSTOM JAVASCRIPT DROPDOWNS (Material-UI, Ant Design, etc.):\n   - First click to open the dropdown\n   - Wait for dropdown options to appear (wait 0.5-1s)\n   - Then click on the desired option\n   - For long dropdowns, scroll into view before clicking\n   \n3. DROPDOWN WITH SEARCH/FILTER:\n   - Click to open dropdown\n   - Type search text to filter options\n   - Wait for filtered results to appear\n   - Click the desired option\n   \n4. HANDLING LONG DROPDOWN LISTS:\n   - If option not visible, scroll within dropdown container\n   - Use hover() on options to scroll them into view\n   - For very long lists, use search/filter if available\n   \n5. MULTI-SELECT DROPDOWNS:\n   - Click each option to add to selection\n   - Don't close dropdown until all selections are made\n   - Look for \"Select All\" or \"Clear All\" buttons if available\n\nDROPDOWN TROUBLESHOOTING:\n- If click doesn't open dropdown ‚Üí try hovering first, then click\n- If option not found ‚Üí check if it's dynamically loaded, wait longer\n- If dropdown closes unexpectedly ‚Üí use longer waits between actions\n- For custom dropdowns, look for aria-expanded, role=\"listbox\", or similar attributes\n\n‚ö†Ô∏è VERIFICATION & VALIDATION REQUIREMENTS ‚ö†Ô∏è\nIf the task contains verification keywords (verify, check, ensure, validate, assert, confirm, must, should):\n- You MUST explicitly check the verification condition\n- If verification FAILS ‚Üí Report failure clearly with: \"Verification failed: [specific reason]\"\n- If verification SUCCEEDS ‚Üí Report success clearly with: \"Verification passed: [what was verified]\"\n- NEVER ignore verification requirements - they are critical to task success\n- Examples:\n  * \"verify the search button exists\" ‚Üí If button not found, report: \"Verification failed: search button not found\"\n  * \"ensure page contains 'Welcome'\" ‚Üí If text not found, report: \"Verification failed: 'Welcome' text not present on page\"\n\nSECURITY:\n- Never navigate to unintended domains\n- Confirm sensitive actions before executing\n            \"\"\"\n            \n            logger.info(\"‚öôÔ∏è  Configuring agent with optimizations\")\n            \n            # Send browser initialization progress\n            if progress_callback:\n                progress_callback('browser_init', {'message': f'Starting browser (headless={self.headless})...'})\n            \n            # Create browser instance with optimized performance settings\n            # Browser accepts **data kwargs, type stubs might not reflect all parameters\n            browser = Browser(  # type: ignore\n                headless=self.headless,\n                disable_security=False,  # Keep security enabled for production\n                minimum_wait_page_load_time=self.minimum_wait_page_load_time,\n                wait_for_network_idle_page_load_time=self.wait_for_network_idle_page_load_time,\n                wait_between_actions=self.wait_between_actions\n            )\n            logger.info(f\"üåê Browser initialized (headless={self.headless})\")\n            \n            # Send agent creation progress\n            if progress_callback:\n                progress_callback('agent_create', {'message': 'Creating AI agent...'})\n            \n            agent = Agent(\n                task=instruction,\n                llm=self.llm,\n                browser=browser,  # Pass browser for proper popup/multi-window handling\n                extend_system_message=system_instructions.strip(),\n            )\n            \n            logger.info(\"‚ñ∂Ô∏è  Starting agent execution...\")\n            \n            # Send execution start progress\n            if progress_callback:\n                progress_callback('execution_start', {'message': 'Agent is now executing automation steps...'})\n            \n            # Add detailed logging wrapper for agent.run()\n            if self.log_performance:\n                start_time = time.time()\n            \n            logger.debug(\"=\" * 80)\n            logger.debug(\"üîÑ CALLING agent.run() - LLM will be invoked repeatedly\")\n            logger.debug(f\"Max steps: {self.max_steps}\")\n            logger.debug(f\"Task: {instruction}\")\n            logger.debug(\"=\" * 80)\n            \n            try:\n                if self.enable_advanced_features:\n                    @self.retry_mechanism.async_retry\n                    async def run_with_retry():\n                        return await agent.run(max_steps=self.max_steps)\n                    \n                    history = await run_with_retry()\n                else:\n                    history = await agent.run(max_steps=self.max_steps)\n            except Exception as e:\n                logger.error(\"=\" * 80)\n                logger.error(\"‚ùå AGENT.RUN() FAILED\")\n                logger.error(f\"Error Type: {type(e).__name__}\")\n                logger.error(f\"Error Message: {str(e)}\")\n                logger.error(\"=\" * 80)\n                import traceback\n                logger.error(traceback.format_exc())\n                raise\n            \n            if self.log_performance:\n                elapsed = time.time() - start_time\n                logger.debug(f\"‚è±Ô∏è  agent.run() completed in {elapsed:.2f}s\")\n            \n            logger.info(f\"‚èπÔ∏è  Agent execution completed\")\n            \n            logger.info(\"=\" * 80)\n            logger.info(\"üìã EXECUTION STEPS\")\n            logger.info(\"=\" * 80)\n            steps = []\n            screenshot_paths = []\n            \n            for i, item in enumerate(history.history):\n                step_num = i + 1\n                action = str(getattr(item, 'model_output', ''))\n                state = str(getattr(item, 'state', ''))\n                \n                # Concise step-based logging\n                logger.info(f\"Step {step_num}: {action[:120]}\")\n                \n                step = {\n                    \"tool\": \"browser_use_action\",\n                    \"arguments\": {\"action\": action},\n                    \"success\": True,\n                    \"result\": {\n                        \"state\": state,\n                        \"step_number\": step_num\n                    }\n                }\n                steps.append(step)\n                \n                # Send step progress update\n                if progress_callback:\n                    progress_callback('step', {\n                        'step_number': step_num,\n                        'action': action[:150],\n                        'total_steps': len(history.history)\n                    })\n                \n                if self.enable_advanced_features and self.workflow_state:\n                    self.workflow_state.add_step(\n                        step_name=f\"browser_action_{step_num}\",\n                        step_data={\"action\": action},\n                        success=True\n                    )\n            \n            final_result = history.final_result() if hasattr(history, 'final_result') else None\n            \n            # Check for verification failures\n            verification_failure = self._check_verification_failure(final_result, steps, instruction)\n            if verification_failure:\n                logger.error(\"=\" * 80)\n                logger.error(\"‚ùå VERIFICATION FAILED\")\n                logger.error(f\"Instruction: {verification_failure['instruction']}\")\n                logger.error(f\"Reason: {verification_failure['reason']}\")\n                logger.error(f\"Completed Steps: {verification_failure['completed_steps']}\")\n                logger.error(\"=\" * 80)\n                \n                # Return verification failure result\n                return {\n                    \"success\": False,\n                    \"error\": f\"Verification failed: {verification_failure['reason']}\",\n                    \"error_type\": \"VerificationError\",\n                    \"verification_failed\": True,\n                    \"verification_details\": verification_failure,\n                    \"steps\": steps,\n                    \"iterations\": len(steps),\n                    \"final_result\": final_result\n                }\n            \n            # Screenshots are now captured automatically at each step above\n            \n            # Capture final screenshot at the end of automation\n            if self.enable_advanced_features and browser and len(steps) > 0:\n                try:\n                    page = await browser.get_current_page()\n                    if page:\n                        screenshot_name = \"final\"\n                        screenshot_result = await self.advanced_features.capture_screenshot(page, name=screenshot_name)\n                        if screenshot_result.get('success'):\n                            screenshot_path = screenshot_result.get('path')\n                            screenshot_paths.append(screenshot_path)\n                            logger.info(f\"üì∏ Final screenshot captured: {screenshot_path}\")\n                            \n                            # Send final screenshot event via progress callback\n                            if progress_callback:\n                                progress_callback('screenshot', {\n                                    'path': screenshot_path,\n                                    'url': screenshot_result.get('url', ''),\n                                    'step_number': 'Final'\n                                })\n                except Exception as screenshot_error:\n                    logger.warning(f\"‚ö†Ô∏è  Final screenshot capture failed: {screenshot_error}\")\n            \n            logger.info(\"=\" * 80)\n            if len(steps) == 0:\n                logger.info(\"‚ùå Execution Failed ‚Äî No steps were executed successfully\")\n                logger.info(\"=\" * 80)\n                result = {\n                    \"success\": False,\n                    \"error\": \"Browser automation failed to execute any steps\",\n                    \"message\": \"No steps executed - browser may have failed to start\",\n                    \"steps\": [],\n                    \"iterations\": 0,\n                    \"final_result\": None\n                }\n            else:\n                logger.info(f\"‚úÖ Execution Completed Successfully\")\n                logger.info(f\"Total Steps: {len(steps)}\")\n                if final_result:\n                    logger.info(f\"Result: {str(final_result)[:150]}\")\n                logger.info(\"=\" * 80)\n                \n                result = {\n                    \"success\": True,\n                    \"message\": f\"Task completed successfully. Executed {len(steps)} steps.\",\n                    \"steps\": steps,\n                    \"iterations\": len(steps),\n                    \"final_result\": final_result,\n                    \"screenshot_paths\": screenshot_paths\n                }\n            \n            if self.enable_advanced_features:\n                if op_id:\n                    self.performance_monitor.end_operation(op_id, success=result[\"success\"])\n                \n                result[\"performance_metrics\"] = self.performance_monitor.get_summary()\n                \n                if self.workflow_state:\n                    result[\"workflow_state\"] = self.workflow_state.get_summary()\n                \n                result[\"retry_stats\"] = self.retry_mechanism.get_stats()\n            \n            return result\n            \n        except Exception as e:\n            error_msg = str(e)\n            logger.error(\"=\" * 80)\n            logger.error(f\"‚ùå Execution Failed ‚Äî {type(e).__name__}\")\n            logger.error(f\"Error: {error_msg}\")\n            logger.error(\"=\" * 80)\n            \n            if self.enable_advanced_features and op_id:\n                self.performance_monitor.end_operation(op_id, success=False)\n            \n            # Provide helpful error context\n            error_context = {\n                \"success\": False,\n                \"error\": error_msg,\n                \"error_type\": type(e).__name__,\n                \"steps\": [],\n                \"iterations\": 0\n            }\n            \n            # Add helpful hints based on error type\n            if \"timeout\" in error_msg.lower():\n                error_context[\"hint\"] = \"The operation timed out. Consider increasing the timeout or simplifying the task.\"\n            elif \"api\" in error_msg.lower() or \"oauth\" in error_msg.lower() or \"token\" in error_msg.lower():\n                error_context[\"hint\"] = \"Authentication error. Please check your OAuth configuration (OAUTH_TOKEN_URL, OAUTH_CLIENT_ID, OAUTH_CLIENT_SECRET, etc.).\"\n            elif \"playwright\" in error_msg.lower() or \"browser\" in error_msg.lower():\n                error_context[\"hint\"] = \"Browser initialization failed. Ensure Playwright is properly installed.\"\n            \n            if self.enable_advanced_features:\n                error_context[\"retry_stats\"] = self.retry_mechanism.get_stats()\n            \n            return error_context\n        finally:\n            # Clean up browser resources\n            if browser is not None:\n                try:\n                    # Browser cleanup is handled automatically by browser-use library\n                    # The Browser object manages its own lifecycle\n                    logger.debug(\"üßπ Browser cleanup completed\")\n                except Exception as cleanup_error:\n                    logger.warning(f\"‚ö†Ô∏è  Error during browser cleanup: {cleanup_error}\")\n    \n    def execute_instruction_sync(self, instruction: str, progress_callback=None, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Synchronous wrapper for execute_instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            progress_callback: Optional callback for progress updates\n            **kwargs: Additional arguments for execute_instruction\n            \n        Returns:\n            Dictionary with execution results\n        \"\"\"\n        loop = None\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            try:\n                return loop.run_until_complete(self.execute_instruction(instruction, progress_callback=progress_callback, **kwargs))\n            finally:\n                # Clean up pending tasks\n                pending = asyncio.all_tasks(loop)\n                for task in pending:\n                    task.cancel()\n                # Wait for cancelled tasks to finish\n                if pending:\n                    loop.run_until_complete(asyncio.gather(*pending, return_exceptions=True))\n                \n        except Exception as e:\n            logger.error(f\"Sync execution error: {str(e)}\", exc_info=True)\n            return {\n                \"success\": False,\n                \"error\": f\"Sync execution error: {str(e)}\",\n                \"steps\": [],\n                \"iterations\": 0\n            }\n        finally:\n            # Always close the event loop\n            if loop is not None:\n                try:\n                    loop.close()\n                    logger.debug(\"üßπ Event loop closed successfully\")\n                except Exception as loop_error:\n                    logger.warning(f\"‚ö†Ô∏è  Error closing event loop: {loop_error}\")\n    \n    def get_performance_summary(self) -> Dict[str, Any]:\n        \"\"\"Get performance monitoring summary\"\"\"\n        if self.enable_advanced_features:\n            return self.performance_monitor.get_summary()\n        return {\"error\": \"Advanced features not enabled\"}\n    \n    def get_retry_stats(self) -> Dict[str, Any]:\n        \"\"\"Get retry mechanism statistics\"\"\"\n        if self.enable_advanced_features:\n            return self.retry_mechanism.get_stats()\n        return {\"error\": \"Advanced features not enabled\"}\n    \n    def reset_metrics(self):\n        \"\"\"Reset all performance metrics and statistics\"\"\"\n        if self.enable_advanced_features:\n            self.performance_monitor.reset()\n            self.retry_mechanism.reset_stats()\n            logger.info(\"üîÑ All metrics reset\")\n","size_bytes":31048},"app/engines/browser_use/popup_handler.py":{"content":"\"\"\"\nEnhanced Popup Window Handler for Browser-Use\nAutomatically detects and switches to new popup windows with advanced features\n\"\"\"\nimport asyncio\nimport logging\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime\nfrom playwright.async_api import Page, BrowserContext\n\nlogger = logging.getLogger(__name__)\n\n\nclass PopupWindowHandler:\n    \"\"\"\n    Enhanced popup window handler with advanced detection and management\n    Features:\n    - Automatic popup detection and switching\n    - Configurable timeouts\n    - Detailed logging and tracking\n    - Multi-popup orchestration\n    - Popup priority rules\n    \"\"\"\n    \n    def __init__(self, context: BrowserContext, popup_timeout: int = 10000, \n                 auto_switch: bool = True, log_verbose: bool = True):\n        \"\"\"\n        Initialize the enhanced popup handler\n        \n        Args:\n            context: Playwright browser context to monitor\n            popup_timeout: Timeout in milliseconds for popup operations (default: 10000ms)\n            auto_switch: Automatically switch to new popups (default: True)\n            log_verbose: Enable detailed logging (default: True)\n        \"\"\"\n        self.context = context\n        self.current_page = None\n        self.popup_detected = False\n        self.new_pages = []\n        self.popup_timeout = popup_timeout\n        self.auto_switch = auto_switch\n        self.log_verbose = log_verbose\n        \n        self.popup_history: List[Dict[str, Any]] = []\n        self.popup_count = 0\n        \n        context.on(\"page\", self._on_new_page)\n        \n        if self.log_verbose:\n            logger.info(f\"üîç Enhanced popup handler initialized (timeout: {popup_timeout}ms, auto_switch: {auto_switch})\")\n    \n    def _on_new_page(self, page: Page):\n        \"\"\"\n        Enhanced event handler for new pages/windows with tracking\n        \n        Args:\n            page: Newly created page object\n        \"\"\"\n        self.popup_count += 1\n        popup_info = {\n            \"popup_number\": self.popup_count,\n            \"url\": page.url or \"about:blank\",\n            \"timestamp\": datetime.now().isoformat(),\n            \"auto_switched\": self.auto_switch\n        }\n        \n        self.popup_history.append(popup_info)\n        self.new_pages.append(page)\n        self.popup_detected = True\n        \n        if self.log_verbose:\n            logger.info(f\"üÜï Popup #{self.popup_count} detected: {popup_info['url']}\")\n            logger.info(f\"üìä Total popups opened: {self.popup_count}\")\n    \n    async def get_active_page(self) -> Optional[Page]:\n        \"\"\"\n        Get the currently active page with enhanced timeout handling\n        \n        Returns:\n            Active page object or None\n        \"\"\"\n        if self.new_pages and self.auto_switch:\n            latest_page = self.new_pages[-1]\n            \n            try:\n                await latest_page.wait_for_load_state(\"domcontentloaded\", timeout=self.popup_timeout)\n                \n                if self.log_verbose:\n                    logger.info(f\"‚úÖ Switched to popup window: {latest_page.url}\")\n                \n                return latest_page\n            except Exception as e:\n                logger.warning(f\"‚ö†Ô∏è Popup not ready within {self.popup_timeout}ms: {str(e)}\")\n        \n        all_pages = self.context.pages\n        if all_pages:\n            return all_pages[-1]\n        \n        return None\n    \n    async def wait_for_popup(self, timeout: Optional[int] = None) -> Optional[Page]:\n        \"\"\"\n        Wait for a popup to appear\n        \n        Args:\n            timeout: Optional custom timeout in milliseconds\n            \n        Returns:\n            New popup page or None if timeout\n        \"\"\"\n        wait_timeout = timeout or self.popup_timeout\n        start_time = datetime.now()\n        \n        while (datetime.now() - start_time).total_seconds() * 1000 < wait_timeout:\n            if self.new_pages:\n                new_page = self.new_pages[-1]\n                if self.log_verbose:\n                    logger.info(f\"‚úÖ Popup appeared: {new_page.url}\")\n                return new_page\n            await asyncio.sleep(0.1)\n        \n        logger.warning(f\"‚è±Ô∏è  No popup appeared within {wait_timeout}ms\")\n        return None\n    \n    def get_popup_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        Get statistics about popup handling\n        \n        Returns:\n            Dictionary with popup statistics\n        \"\"\"\n        return {\n            \"total_popups\": self.popup_count,\n            \"active_popups\": len(self.new_pages),\n            \"popup_history\": self.popup_history,\n            \"auto_switch_enabled\": self.auto_switch,\n            \"timeout_ms\": self.popup_timeout\n        }\n    \n    def reset(self):\n        \"\"\"Reset the handler state with enhanced logging\"\"\"\n        previous_count = self.popup_count\n        self.new_pages.clear()\n        self.popup_detected = False\n        \n        if self.log_verbose:\n            logger.info(f\"üîÑ Popup handler reset (processed {previous_count} popups this session)\")\n    \n    def has_popup(self) -> bool:\n        \"\"\"Check if a popup window was detected\"\"\"\n        return self.popup_detected\n    \n    def get_all_pages(self):\n        \"\"\"Get all open pages\"\"\"\n        return self.context.pages\n","size_bytes":5279},"app/services/engine_orchestrator.py":{"content":"\"\"\"\nEngine Orchestrator\nManages and coordinates browser automation engines\n\"\"\"\nfrom typing import Dict, Any, Optional\nimport logging\nimport asyncio\nimport configparser\nfrom pathlib import Path\nimport app.engines.browser_use as browser_use_codebase\nfrom app.middleware.security import sanitize_error_message\n\nlogger = logging.getLogger(__name__)\n\n\nclass EngineOrchestrator:\n    \"\"\"\n    Orchestrates browser automation engines (Browser-Use and Playwright MCP)\n    Handles engine instantiation, caching, and execution delegation\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the orchestrator with empty engine caches\"\"\"\n        self.browser_use_engines = {}\n        self.playwright_mcp_engine = None\n        self.config = self._load_config()\n        \n    def _load_config(self) -> configparser.ConfigParser:\n        \"\"\"Load configuration from config.ini\"\"\"\n        config = configparser.ConfigParser()\n        config_path = Path(__file__).parent.parent.parent / 'config' / 'config.ini'\n        \n        if config_path.exists():\n            config.read(config_path)\n        \n        return config\n    \n    def get_browser_use_engine(self, headless: bool):\n        \"\"\"\n        Get or create Browser-Use engine instance\n        Caches instances per headless mode for better performance\n        \n        Args:\n            headless: Run in headless mode\n            \n        Returns:\n            BrowserUseEngine instance\n        \"\"\"\n        if headless not in self.browser_use_engines:\n            self.browser_use_engines[headless] = browser_use_codebase.create_engine(headless=headless)\n        \n        return self.browser_use_engines[headless]\n    \n    def get_playwright_mcp_engine(self):\n        \"\"\"\n        Get or create Playwright MCP engine instance\n        \n        Returns:\n            PlaywrightMCPEngine instance\n        \"\"\"\n        if self.playwright_mcp_engine is None:\n            from app.engines.playwright_mcp import PlaywrightMCPEngine\n            self.playwright_mcp_engine = PlaywrightMCPEngine()\n        \n        return self.playwright_mcp_engine\n    \n    \n    def execute_instruction_with_progress(self, instruction: str, engine_type: str, headless: bool, progress_callback=None) -> Dict[str, Any]:\n        \"\"\"\n        Execute an instruction with progress updates via callback\n        \n        Args:\n            instruction: Natural language instruction\n            engine_type: 'browser_use' only\n            headless: Run in headless mode\n            progress_callback: Optional callback function for progress updates\n            \n        Returns:\n            Execution result dictionary\n        \"\"\"\n        return self.execute_instruction(instruction, engine_type, headless, progress_callback)\n    \n    def execute_instruction(self, instruction: str, engine_type: str, headless: bool, progress_callback=None) -> Dict[str, Any]:\n        \"\"\"\n        Execute an instruction using the specified engine\n        \n        Args:\n            instruction: Natural language instruction\n            engine_type: 'browser_use' or 'playwright_mcp'\n            headless: Run in headless mode (only for browser_use)\n            progress_callback: Optional callback function for progress updates\n            \n        Returns:\n            Dict with execution results\n        \"\"\"\n        valid_engines = ['browser_use', 'playwright_mcp']\n        if engine_type not in valid_engines:\n            logger.error(f\"Invalid engine type: {engine_type}\")\n            return {\n                'success': False,\n                'error': f\"Invalid engine type: {engine_type}. Must be one of: {', '.join(valid_engines)}\",\n                'steps': [],\n                'iterations': 0,\n                'engine': engine_type,\n                'headless': headless\n            }\n        \n        # Execute with the appropriate engine\n        if engine_type == 'browser_use':\n            return self._execute_browser_use(instruction, headless, progress_callback)\n        elif engine_type == 'playwright_mcp':\n            return self._execute_playwright_mcp(instruction, headless, progress_callback)\n    \n    def _execute_browser_use(self, instruction: str, headless: bool, progress_callback=None) -> Dict[str, Any]:\n        \"\"\"Execute instruction using Browser-Use engine\"\"\"\n        logger.info(\"üöÄ Executing automation with Browser-Use engine\")\n        \n        result = None\n        try:\n            engine = self.get_browser_use_engine(headless)\n            result = engine.execute_instruction_sync(instruction, progress_callback=progress_callback, save_screenshot=True)\n            \n            if result is not None:\n                result['engine'] = 'browser_use'\n                result['headless'] = headless\n                return result\n            else:\n                raise ValueError(\"Engine returned no result\")\n            \n        except Exception as e:\n            logger.error(f\"Browser-Use engine execution error: {str(e)}\", exc_info=True)\n            user_message = sanitize_error_message(e)\n            \n            return {\n                'success': False,\n                'error': 'Execution failed',\n                'message': user_message,\n                'steps': [],\n                'iterations': 0,\n                'engine': 'browser_use',\n                'headless': headless\n            }\n    \n    def _execute_playwright_mcp(self, instruction: str, headless: bool, progress_callback=None) -> Dict[str, Any]:\n        \"\"\"Execute instruction using Playwright MCP engine\"\"\"\n        logger.info(\"üöÄ Executing automation with Playwright MCP engine\")\n        \n        try:\n            engine = self.get_playwright_mcp_engine()\n            \n            # Run async task in event loop\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            try:\n                result = loop.run_until_complete(engine.run_task(instruction, headless=headless))\n            finally:\n                loop.close()\n            \n            if result.get('success'):\n                trace_data = result['result'].get('trace', [])\n                return {\n                    'success': True,\n                    'result': result.get('result', {}),\n                    'message': result['result'].get('message', 'Task completed'),\n                    'trace': trace_data,\n                    'steps': trace_data,\n                    'iterations': len([t for t in trace_data if t.get('type') == 'tool_call']),\n                    'engine': 'playwright_mcp',\n                    'headless': headless\n                }\n            else:\n                return {\n                    'success': False,\n                    'error': result.get('error', 'Unknown error'),\n                    'message': result.get('error', 'Task execution failed'),\n                    'steps': [],\n                    'iterations': 0,\n                    'engine': 'playwright_mcp',\n                    'headless': headless\n                }\n            \n        except Exception as e:\n            logger.error(f\"Playwright MCP engine execution error: {str(e)}\", exc_info=True)\n            user_message = sanitize_error_message(e)\n            \n            return {\n                'success': False,\n                'error': 'Execution failed',\n                'message': user_message,\n                'steps': [],\n                'iterations': 0,\n                'engine': 'playwright_mcp',\n                'headless': headless\n            }\n    \n    def get_tools(self, engine_type: str) -> list:\n        \"\"\"\n        Get available tools for the specified engine\n        \n        Args:\n            engine_type: 'browser_use' or 'playwright_mcp'\n            \n        Returns:\n            List of available tools\n        \"\"\"\n        if engine_type == 'browser_use':\n            return [\n                {'name': 'browser_use_agent', 'description': 'AI-powered browser automation'}\n            ]\n        elif engine_type == 'playwright_mcp':\n            return [\n                {'name': 'playwright_mcp_agent', 'description': 'AI-powered browser automation using Playwright MCP'}\n            ]\n        return []\n    \n    def cleanup_after_timeout(self, engine_type: str, headless: bool):\n        \"\"\"\n        Clean up resources after a timed-out execution\n        \n        Args:\n            engine_type: Engine that was executing when timeout occurred\n            headless: Headless mode setting\n        \"\"\"\n        logger.warning(f\"Cleaning up after timeout for {engine_type} (headless={headless})\")\n        \n        try:\n            if engine_type == 'browser_use':\n                # Reset browser_use engine by removing it from cache\n                # This forces a fresh engine on next request\n                if headless in self.browser_use_engines:\n                    logger.info(f\"Removing browser_use engine from cache (headless={headless})\")\n                    del self.browser_use_engines[headless]\n            elif engine_type == 'playwright_mcp':\n                # Reset Playwright MCP engine\n                self.playwright_mcp_engine = None\n        except Exception as e:\n            logger.error(f\"Error during timeout cleanup: {str(e)}\")\n    \n    def reset_agent(self, engine_type: str, headless: bool = True):\n        \"\"\"\n        Reset the conversation history for the specified engine\n        \n        Args:\n            engine_type: 'browser_use' or 'playwright_mcp'\n            headless: Headless mode setting\n        \"\"\"\n        logger.info(f\"Reset requested for {engine_type} engine\")\n        \n        if engine_type == 'playwright_mcp':\n            # Reset Playwright MCP engine\n            self.playwright_mcp_engine = None\n","size_bytes":9664},"app/engines/playwright_mcp/mcp_client.py":{"content":"\"\"\"\nPlaywright MCP Client - Manages connection to Playwright MCP server\n\"\"\"\nimport asyncio\nimport json\nimport logging\nfrom typing import Any, Dict, List, Optional\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nlogger = logging.getLogger(__name__)\n\n\nclass PlaywrightMCPClient:\n    \"\"\"Client for Playwright MCP server\"\"\"\n    \n    def __init__(self, command: str, args: List[str]):\n        self.command = command\n        self.args = args\n        self.session: Optional[ClientSession] = None\n        self.read = None\n        self.write = None\n        self.tools: List[Dict[str, Any]] = []\n        self._stdio_context = None\n        \n    async def __aenter__(self):\n        await self.connect()\n        return self\n        \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self.disconnect()\n        \n    async def connect(self):\n        \"\"\"Connect to the MCP server\"\"\"\n        logger.info(\"Starting Playwright MCP server...\")\n        \n        try:\n            server_params = StdioServerParameters(\n                command=self.command,\n                args=self.args,\n                env=None\n            )\n            \n            self._stdio_context = stdio_client(server_params)\n            self.read, self.write = await self._stdio_context.__aenter__()\n            self.session = ClientSession(self.read, self.write)\n            \n            await self.session.__aenter__()\n            await self.session.initialize()\n            \n            tools_list = await self.session.list_tools()\n            self.tools = [tool.model_dump() for tool in tools_list.tools]\n            \n            logger.info(f\"‚úì MCP server connected. Available tools: {len(self.tools)}\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to connect to MCP server: {e}\")\n            raise\n        \n        return self\n    \n    async def disconnect(self):\n        \"\"\"Disconnect from the MCP server\"\"\"\n        try:\n            if self.session:\n                await self.session.__aexit__(None, None, None)\n            if self._stdio_context:\n                await self._stdio_context.__aexit__(None, None, None)\n            logger.info(\"MCP server disconnected\")\n        except Exception as e:\n            logger.error(f\"Error disconnecting from MCP server: {e}\")\n    \n    async def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Any:\n        \"\"\"Call a tool on the MCP server\"\"\"\n        if not self.session:\n            raise RuntimeError(\"MCP client not connected\")\n        \n        logger.debug(f\"‚Üí Calling tool: {tool_name}\")\n        logger.debug(f\"  Arguments: {json.dumps(arguments, indent=2)}\")\n        \n        try:\n            result = await self.session.call_tool(tool_name, arguments)\n            logger.debug(f\"‚úì Tool executed: {tool_name}\")\n            return result\n        except Exception as e:\n            logger.error(f\"Error calling tool {tool_name}: {e}\")\n            raise\n    \n    def get_tools_description(self) -> str:\n        \"\"\"Get a formatted description of available tools\"\"\"\n        if not self.tools:\n            return \"No tools available\"\n        \n        descriptions = []\n        for tool in self.tools:\n            tool_desc = f\"- {tool['name']}: {tool.get('description', 'No description')}\"\n            if 'inputSchema' in tool:\n                props = tool['inputSchema'].get('properties', {})\n                if props:\n                    params = \", \".join(props.keys())\n                    tool_desc += f\"\\n  Parameters: {params}\"\n            descriptions.append(tool_desc)\n        \n        return \"\\n\".join(descriptions)\n","size_bytes":3654},"app/engines/browser_use/data_extractor.py":{"content":"\"\"\"\nAdvanced Data Extraction Capabilities\nStructured data scraping, table extraction, and content parsing\n\"\"\"\nimport json\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\n\nclass DataExtractor:\n    \"\"\"\n    Advanced data extraction for web automation\n    Handles tables, lists, structured data, and custom selectors\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize data extractor\"\"\"\n        logger.info(\"üìä Data extractor initialized\")\n    \n    async def extract_table(self, page, selector: str = \"table\", \n                          include_headers: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Extract data from HTML table\n        \n        Args:\n            page: Playwright page object\n            selector: CSS selector for table\n            include_headers: Extract header row\n            \n        Returns:\n            Dictionary with table data\n        \"\"\"\n        try:\n            table_data = await page.evaluate(f\"\"\"(selector) => {{\n                const table = document.querySelector(selector);\n                if (!table) return null;\n                \n                const rows = Array.from(table.querySelectorAll('tr'));\n                const data = [];\n                \n                rows.forEach((row, index) => {{\n                    const cells = Array.from(row.querySelectorAll('td, th'));\n                    const rowData = cells.map(cell => cell.textContent.trim());\n                    if (rowData.length > 0) {{\n                        data.push(rowData);\n                    }}\n                }});\n                \n                return data;\n            }}\"\"\", selector)\n            \n            if not table_data:\n                return {\"success\": False, \"error\": \"Table not found\"}\n            \n            result = {\n                \"success\": True,\n                \"rows\": table_data,\n                \"row_count\": len(table_data),\n                \"column_count\": len(table_data[0]) if table_data else 0\n            }\n            \n            if include_headers and table_data:\n                result[\"headers\"] = table_data[0]\n                result[\"data\"] = table_data[1:]\n            \n            logger.info(f\"üìä Table extracted: {result['row_count']} rows, {result['column_count']} columns\")\n            return result\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Table extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_list(self, page, selector: str, item_selector: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract items from a list\n        \n        Args:\n            page: Playwright page object\n            selector: CSS selector for list container\n            item_selector: Optional selector for individual items\n            \n        Returns:\n            Dictionary with list items\n        \"\"\"\n        try:\n            if item_selector:\n                query = f\"{selector} {item_selector}\"\n            else:\n                query = f\"{selector} li\"\n            \n            items = await page.evaluate(f\"\"\"(query) => {{\n                const elements = document.querySelectorAll(query);\n                return Array.from(elements).map(el => el.textContent.trim());\n            }}\"\"\", query)\n            \n            logger.info(f\"üìã List extracted: {len(items)} items\")\n            \n            return {\n                \"success\": True,\n                \"items\": items,\n                \"item_count\": len(items)\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå List extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_structured_data(self, page, schema: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"\n        Extract structured data using a schema\n        \n        Args:\n            page: Playwright page object\n            schema: Dictionary mapping field names to CSS selectors\n            \n        Returns:\n            Dictionary with extracted data\n        \"\"\"\n        try:\n            extracted_data = {}\n            \n            for field_name, selector in schema.items():\n                try:\n                    value = await page.evaluate(f\"\"\"(selector) => {{\n                        const element = document.querySelector(selector);\n                        return element ? element.textContent.trim() : null;\n                    }}\"\"\", selector)\n                    \n                    extracted_data[field_name] = value\n                except:\n                    extracted_data[field_name] = None\n            \n            logger.info(f\"üì¶ Structured data extracted: {len(extracted_data)} fields\")\n            \n            return {\n                \"success\": True,\n                \"data\": extracted_data,\n                \"field_count\": len(extracted_data)\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Structured data extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_all_links(self, page, base_url: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract all links from page\n        \n        Args:\n            page: Playwright page object\n            base_url: Optional base URL for relative links\n            \n        Returns:\n            Dictionary with links\n        \"\"\"\n        try:\n            links = await page.evaluate(\"\"\"() => {\n                const anchors = document.querySelectorAll('a[href]');\n                return Array.from(anchors).map(a => ({\n                    text: a.textContent.trim(),\n                    href: a.href,\n                    rel_href: a.getAttribute('href')\n                }));\n            }\"\"\")\n            \n            logger.info(f\"üîó Links extracted: {len(links)} links\")\n            \n            return {\n                \"success\": True,\n                \"links\": links,\n                \"link_count\": len(links),\n                \"page_url\": page.url\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Link extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_images(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract all images from page\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with image data\n        \"\"\"\n        try:\n            images = await page.evaluate(\"\"\"() => {\n                const imgs = document.querySelectorAll('img');\n                return Array.from(imgs).map(img => ({\n                    src: img.src,\n                    alt: img.alt,\n                    width: img.width,\n                    height: img.height\n                }));\n            }\"\"\")\n            \n            logger.info(f\"üñºÔ∏è  Images extracted: {len(images)} images\")\n            \n            return {\n                \"success\": True,\n                \"images\": images,\n                \"image_count\": len(images)\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Image extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_metadata(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract page metadata (title, description, etc.)\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with metadata\n        \"\"\"\n        try:\n            metadata = await page.evaluate(\"\"\"() => {\n                const getMeta = (name) => {\n                    const element = document.querySelector(`meta[name=\"${name}\"], meta[property=\"${name}\"]`);\n                    return element ? element.content : null;\n                };\n                \n                return {\n                    title: document.title,\n                    description: getMeta('description') || getMeta('og:description'),\n                    keywords: getMeta('keywords'),\n                    author: getMeta('author'),\n                    og_title: getMeta('og:title'),\n                    og_image: getMeta('og:image'),\n                    canonical: document.querySelector('link[rel=\"canonical\"]')?.href\n                };\n            }\"\"\")\n            \n            metadata[\"url\"] = page.url\n            \n            logger.info(f\"‚ÑπÔ∏è  Metadata extracted from: {page.url}\")\n            \n            return {\n                \"success\": True,\n                \"metadata\": metadata\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Metadata extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_text_content(self, page, selector: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract text content from page or specific element\n        \n        Args:\n            page: Playwright page object\n            selector: Optional CSS selector for specific element\n            \n        Returns:\n            Dictionary with text content\n        \"\"\"\n        try:\n            if selector:\n                text = await page.evaluate(f\"\"\"(selector) => {{\n                    const element = document.querySelector(selector);\n                    return element ? element.textContent.trim() : null;\n                }}\"\"\", selector)\n            else:\n                text = await page.evaluate(\"\"\"() => {\n                    return document.body.textContent.trim();\n                }\"\"\")\n            \n            logger.info(f\"üìù Text content extracted: {len(text)} characters\")\n            \n            return {\n                \"success\": True,\n                \"text\": text,\n                \"length\": len(text) if text else 0\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Text extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n","size_bytes":10037},"app/engines/browser_use/config/__init__.py":{"content":"\"\"\"\nBrowser-Use Configuration Module\n\"\"\"\n","size_bytes":41},"app/middleware/__init__.py":{"content":"\"\"\"Middleware package\"\"\"\n","size_bytes":25},"app/__init__.py":{"content":"\"\"\"\nFlask Application Factory\n\"\"\"\nimport os\nimport logging\nimport sys\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\n# PRIVACY: Disable all external data transmission from browser-use library\n# Set these BEFORE importing any browser-use components\nos.environ.setdefault('ANONYMIZED_TELEMETRY', 'false')\nos.environ.setdefault('BROWSER_USE_CLOUD_SYNC', 'false')\n\nfrom flask import Flask\nfrom flask_cors import CORS\nfrom app.models import db\nfrom app.services.engine_orchestrator import EngineOrchestrator\nfrom app.routes.api import create_api_routes\nfrom app.utils.logging_config import LoggingConfigurator\n\n\ndef create_app():\n    \"\"\"\n    Create and configure the Flask application\n    \n    Returns:\n        Configured Flask app instance\n    \"\"\"\n    # Configure logging from config.ini\n    logging_config = LoggingConfigurator()\n    logging_config.configure()\n    \n    logger = logging.getLogger(__name__)\n    logger.info(\"üöÄ Starting AI Browser Automation application\")\n    \n    # Log privacy settings confirmation\n    telemetry_status = os.environ.get('ANONYMIZED_TELEMETRY', 'not set')\n    cloud_sync_status = os.environ.get('BROWSER_USE_CLOUD_SYNC', 'not set')\n    logger.info(\"=\" * 80)\n    logger.info(\"üîí PRIVACY SETTINGS\")\n    logger.info(\"=\" * 80)\n    logger.info(f\"Anonymized Telemetry: {telemetry_status} (should be 'false')\")\n    logger.info(f\"Cloud Sync: {cloud_sync_status} (should be 'false')\")\n    if telemetry_status.lower()[:1] in 'ty1' or cloud_sync_status.lower()[:1] in 'ty1':\n        logger.warning(\"‚ö†Ô∏è  WARNING: External data transmission may be ENABLED!\")\n        logger.warning(\"‚ö†Ô∏è  Set ANONYMIZED_TELEMETRY=false and BROWSER_USE_CLOUD_SYNC=false\")\n    else:\n        logger.info(\"‚úÖ All external data transmission DISABLED\")\n        logger.info(\"‚úÖ No telemetry or cloud sync - data stays on your system\")\n    logger.info(\"=\" * 80)\n    \n    app = Flask(__name__)\n    \n    # Session secret key - MUST be set in production\n    session_secret = os.environ.get(\"SESSION_SECRET\")\n    if not session_secret:\n        # Generate ephemeral random key for local development only\n        import secrets\n        session_secret = secrets.token_hex(32)\n        logger.warning(\"‚ö†Ô∏è  SESSION_SECRET not set! Using ephemeral random key for local dev.\")\n        logger.warning(\"‚ö†Ô∏è  Set SESSION_SECRET environment variable for production!\")\n    \n    app.config['SECRET_KEY'] = session_secret\n    \n    # Use SQLite database\n    app.config[\"SQLALCHEMY_DATABASE_URI\"] = \"sqlite:///automation_history.db\"\n    logger.info(\"üìù Using SQLite database\")\n    app.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n        \"pool_recycle\": 300,\n        \"pool_pre_ping\": True,\n    }\n    \n    db.init_app(app)\n    \n    with app.app_context():\n        db.create_all()\n        logger.info(\"‚úÖ Database initialized successfully\")\n    \n    allowed_origins = os.environ.get('CORS_ALLOWED_ORIGINS', '*').split(',')\n    CORS(app, \n         resources={r\"/api/*\": {\"origins\": allowed_origins}},\n         methods=[\"GET\", \"POST\", \"OPTIONS\", \"DELETE\"],\n         allow_headers=[\"Content-Type\", \"X-API-Key\"],\n         supports_credentials=True)\n    \n    logger.info(f\"üîí CORS configured with origins: {allowed_origins}\")\n    logger.info(\"üì¶ Initializing Engine Orchestrator\")\n    orchestrator = EngineOrchestrator()\n    \n    logger.info(\"üîó Registering API routes\")\n    api_routes = create_api_routes(orchestrator)\n    app.register_blueprint(api_routes)\n    \n    # Add cache control headers to prevent browser caching issues\n    @app.after_request\n    def add_cache_control_headers(response):\n        \"\"\"Add Cache-Control headers to all responses to prevent caching\"\"\"\n        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, public, max-age=0'\n        response.headers['Pragma'] = 'no-cache'\n        response.headers['Expires'] = '0'\n        return response\n    \n    # Handle favicon request to prevent 404 errors\n    @app.route('/favicon.ico')\n    def favicon():\n        \"\"\"Return 204 No Content for favicon requests\"\"\"\n        from flask import Response\n        return Response(status=204)\n    \n    # Serve automation outputs (screenshots, PDFs, etc.)\n    @app.route('/automation_outputs/<path:filename>')\n    def serve_automation_outputs(filename):\n        \"\"\"Serve files from automation_outputs directory (legacy)\"\"\"\n        from flask import send_from_directory\n        import os\n        output_dir = os.path.join(project_root, 'automation_outputs')\n        return send_from_directory(output_dir, filename)\n    \n    # Serve screenshots from automation_outputs/screenshots folder\n    @app.route('/screenshots/<path:filename>')\n    def serve_screenshots(filename):\n        \"\"\"Serve files from screenshots directory\"\"\"\n        from flask import send_from_directory\n        import os\n        screenshots_dir = os.path.join(project_root, 'automation_outputs', 'screenshots')\n        # Create directory if it doesn't exist\n        os.makedirs(screenshots_dir, exist_ok=True)\n        return send_from_directory(screenshots_dir, filename)\n    \n    logger.info(\"‚úÖ Application initialization complete\")\n    \n    return app\n","size_bytes":5331},"app/engines/browser_use/performance_monitor.py":{"content":"\"\"\"\nPerformance Monitoring and Metrics Tracking\nTracks automation performance, timing, and resource usage\n\"\"\"\nimport time\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nfrom collections import defaultdict\n\nlogger = logging.getLogger(__name__)\n\n\nclass PerformanceMonitor:\n    \"\"\"\n    Monitor and track performance metrics for browser automation\n    Tracks timing, success rates, and resource usage\n    \"\"\"\n    \n    def __init__(self, track_detailed_metrics: bool = True):\n        \"\"\"\n        Initialize performance monitor\n        \n        Args:\n            track_detailed_metrics: Track detailed per-operation metrics\n        \"\"\"\n        self.track_detailed_metrics = track_detailed_metrics\n        self.metrics = {\n            \"total_operations\": 0,\n            \"successful_operations\": 0,\n            \"failed_operations\": 0,\n            \"total_duration\": 0.0,\n            \"start_time\": datetime.now().isoformat()\n        }\n        \n        self.operation_metrics: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            \"count\": 0,\n            \"success_count\": 0,\n            \"fail_count\": 0,\n            \"total_duration\": 0.0,\n            \"min_duration\": float('inf'),\n            \"max_duration\": 0.0\n        })\n        \n        self.timing_stack: List[Dict[str, Any]] = []\n        \n        logger.info(\"üìä Performance monitor initialized\")\n    \n    def start_operation(self, operation_name: str) -> str:\n        \"\"\"\n        Start tracking an operation\n        \n        Args:\n            operation_name: Name of the operation\n            \n        Returns:\n            Operation ID for stopping later\n        \"\"\"\n        operation_id = f\"{operation_name}_{len(self.timing_stack)}\"\n        \n        timing_info = {\n            \"operation_id\": operation_id,\n            \"operation_name\": operation_name,\n            \"start_time\": time.time(),\n            \"start_timestamp\": datetime.now().isoformat()\n        }\n        \n        self.timing_stack.append(timing_info)\n        \n        if self.track_detailed_metrics:\n            logger.debug(f\"‚è±Ô∏è  Started: {operation_name}\")\n        \n        return operation_id\n    \n    def end_operation(self, operation_id: str, success: bool = True, metadata: Optional[Dict] = None):\n        \"\"\"\n        End tracking an operation\n        \n        Args:\n            operation_id: ID returned from start_operation\n            success: Whether operation succeeded\n            metadata: Optional metadata about the operation\n        \"\"\"\n        if not self.timing_stack:\n            logger.warning(\"‚ö†Ô∏è  No operation to end\")\n            return\n        \n        timing_info = self.timing_stack.pop()\n        \n        if timing_info[\"operation_id\"] != operation_id:\n            logger.warning(f\"‚ö†Ô∏è  Operation ID mismatch: expected {timing_info['operation_id']}, got {operation_id}\")\n        \n        duration = time.time() - timing_info[\"start_time\"]\n        operation_name = timing_info[\"operation_name\"]\n        \n        self.metrics[\"total_operations\"] += 1\n        self.metrics[\"total_duration\"] += duration\n        \n        if success:\n            self.metrics[\"successful_operations\"] += 1\n        else:\n            self.metrics[\"failed_operations\"] += 1\n        \n        op_metrics = self.operation_metrics[operation_name]\n        op_metrics[\"count\"] += 1\n        op_metrics[\"total_duration\"] += duration\n        op_metrics[\"min_duration\"] = min(op_metrics[\"min_duration\"], duration)\n        op_metrics[\"max_duration\"] = max(op_metrics[\"max_duration\"], duration)\n        \n        if success:\n            op_metrics[\"success_count\"] += 1\n        else:\n            op_metrics[\"fail_count\"] += 1\n        \n        if self.track_detailed_metrics:\n            status = \"‚úÖ\" if success else \"‚ùå\"\n            logger.info(f\"{status} {operation_name} completed in {duration:.2f}s\")\n    \n    def record_metric(self, metric_name: str, value: Any):\n        \"\"\"\n        Record a custom metric\n        \n        Args:\n            metric_name: Name of the metric\n            value: Metric value\n        \"\"\"\n        if \"custom_metrics\" not in self.metrics:\n            self.metrics[\"custom_metrics\"] = {}\n        \n        self.metrics[\"custom_metrics\"][metric_name] = value\n        \n        if self.track_detailed_metrics:\n            logger.debug(f\"üìä Metric recorded: {metric_name} = {value}\")\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"\n        Get performance summary\n        \n        Returns:\n            Dictionary with performance metrics\n        \"\"\"\n        total_ops = self.metrics[\"total_operations\"]\n        \n        summary = {\n            \"overview\": {\n                \"total_operations\": total_ops,\n                \"successful_operations\": self.metrics[\"successful_operations\"],\n                \"failed_operations\": self.metrics[\"failed_operations\"],\n                \"success_rate\": (self.metrics[\"successful_operations\"] / max(total_ops, 1)) * 100,\n                \"total_duration\": self.metrics[\"total_duration\"],\n                \"average_duration\": self.metrics[\"total_duration\"] / max(total_ops, 1),\n                \"start_time\": self.metrics[\"start_time\"],\n                \"current_time\": datetime.now().isoformat()\n            },\n            \"operation_breakdown\": {}\n        }\n        \n        for op_name, op_metrics in self.operation_metrics.items():\n            count = op_metrics[\"count\"]\n            summary[\"operation_breakdown\"][op_name] = {\n                \"count\": count,\n                \"success_count\": op_metrics[\"success_count\"],\n                \"fail_count\": op_metrics[\"fail_count\"],\n                \"success_rate\": (op_metrics[\"success_count\"] / max(count, 1)) * 100,\n                \"total_duration\": op_metrics[\"total_duration\"],\n                \"average_duration\": op_metrics[\"total_duration\"] / max(count, 1),\n                \"min_duration\": op_metrics[\"min_duration\"] if op_metrics[\"min_duration\"] != float('inf') else 0,\n                \"max_duration\": op_metrics[\"max_duration\"]\n            }\n        \n        if \"custom_metrics\" in self.metrics:\n            summary[\"custom_metrics\"] = self.metrics[\"custom_metrics\"]\n        \n        return summary\n    \n    def get_top_slowest_operations(self, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get the slowest operations\n        \n        Args:\n            limit: Number of operations to return\n            \n        Returns:\n            List of slowest operations with metrics\n        \"\"\"\n        operations = []\n        \n        for op_name, op_metrics in self.operation_metrics.items():\n            if op_metrics[\"count\"] > 0:\n                avg_duration = op_metrics[\"total_duration\"] / op_metrics[\"count\"]\n                operations.append({\n                    \"operation\": op_name,\n                    \"average_duration\": avg_duration,\n                    \"max_duration\": op_metrics[\"max_duration\"],\n                    \"count\": op_metrics[\"count\"]\n                })\n        \n        operations.sort(key=lambda x: x[\"average_duration\"], reverse=True)\n        return operations[:limit]\n    \n    def reset(self):\n        \"\"\"Reset all metrics\"\"\"\n        self.metrics = {\n            \"total_operations\": 0,\n            \"successful_operations\": 0,\n            \"failed_operations\": 0,\n            \"total_duration\": 0.0,\n            \"start_time\": datetime.now().isoformat()\n        }\n        self.operation_metrics.clear()\n        self.timing_stack.clear()\n        \n        logger.info(\"üîÑ Performance metrics reset\")\n    \n    def log_summary(self):\n        \"\"\"Log a formatted summary of metrics\"\"\"\n        summary = self.get_summary()\n        \n        logger.info(\"=\" * 80)\n        logger.info(\"üìä PERFORMANCE SUMMARY\")\n        logger.info(\"=\" * 80)\n        logger.info(f\"Total Operations: {summary['overview']['total_operations']}\")\n        logger.info(f\"Success Rate: {summary['overview']['success_rate']:.1f}%\")\n        logger.info(f\"Total Duration: {summary['overview']['total_duration']:.2f}s\")\n        logger.info(f\"Average Duration: {summary['overview']['average_duration']:.2f}s\")\n        \n        if summary['operation_breakdown']:\n            logger.info(\"\\nüìã Operation Breakdown:\")\n            for op_name, metrics in summary['operation_breakdown'].items():\n                logger.info(f\"  ‚Ä¢ {op_name}: {metrics['count']} ops, \"\n                          f\"avg {metrics['average_duration']:.2f}s, \"\n                          f\"success {metrics['success_rate']:.1f}%\")\n        \n        logger.info(\"=\" * 80)\n","size_bytes":8538},"app/static/css/dark-theme.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\n:root {\n    --bg-dark: #0a0e1a;\n    --bg-sidebar: #111827;\n    --bg-panel: #1a1f35;\n    --bg-panel-hover: #1e2640;\n    --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    --primary-blue: #667eea;\n    --primary-purple: #764ba2;\n    --primary-blue-hover: #5568d3;\n    --accent-cyan: #06b6d4;\n    --accent-pink: #ec4899;\n    --text-primary: #f8fafc;\n    --text-secondary: #94a3b8;\n    --text-muted: #64748b;\n    --border-color: #2d3748;\n    --success-bg: #065f46;\n    --success-text: #10b981;\n    --error-bg: #991b1b;\n    --error-text: #ef4444;\n    --warning-bg: #92400e;\n    --warning-text: #f59e0b;\n    --glow-purple: rgba(118, 75, 162, 0.4);\n    --glow-blue: rgba(102, 126, 234, 0.4);\n}\n\n[data-theme=\"light\"] {\n    --bg-dark: #f8fafc;\n    --bg-sidebar: #ffffff;\n    --bg-panel: #ffffff;\n    --bg-panel-hover: #f1f5f9;\n    --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    --primary-blue: #667eea;\n    --primary-purple: #764ba2;\n    --primary-blue-hover: #5568d3;\n    --accent-cyan: #06b6d4;\n    --accent-pink: #ec4899;\n    --text-primary: #0f172a;\n    --text-secondary: #475569;\n    --text-muted: #64748b;\n    --border-color: #e2e8f0;\n    --success-bg: #d1fae5;\n    --success-text: #059669;\n    --error-bg: #fee2e2;\n    --error-text: #dc2626;\n    --warning-bg: #fef3c7;\n    --warning-text: #d97706;\n    --glow-purple: rgba(118, 75, 162, 0.15);\n    --glow-blue: rgba(102, 126, 234, 0.15);\n}\n\nhtml {\n    background: var(--bg-dark);\n    transition: background-color 0.3s ease;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: var(--bg-dark);\n    color: var(--text-primary);\n    min-height: 100vh;\n    margin: 0;\n    padding: 0;\n    line-height: 1.6;\n    background-image: \n        radial-gradient(at 0% 0%, rgba(102, 126, 234, 0.05) 0px, transparent 50%),\n        radial-gradient(at 100% 100%, rgba(118, 75, 162, 0.05) 0px, transparent 50%);\n}\n\n@keyframes fadeIn {\n    from { opacity: 0; transform: translateY(10px); }\n    to { opacity: 1; transform: translateY(0); }\n}\n\n.main-content {\n    opacity: 1;\n    animation: fadeIn 0.5s ease-out;\n}\n\n.app-container {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    width: 260px;\n    background: var(--bg-sidebar);\n    padding: 24px 0;\n    display: flex;\n    flex-direction: column;\n    position: fixed;\n    height: 100vh;\n    left: 0;\n    top: 0;\n    border-right: 1px solid var(--border-color);\n    backdrop-filter: blur(10px);\n}\n\n.sidebar-header {\n    padding: 0 20px 24px;\n    display: flex;\n    align-items: center;\n    gap: 12px;\n}\n\n.sidebar-logo {\n    width: 40px;\n    height: 40px;\n    background: var(--primary-gradient);\n    border-radius: 10px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 1.2rem;\n    box-shadow: 0 4px 12px var(--glow-purple);\n    animation: pulse 3s ease-in-out infinite;\n}\n\n@keyframes pulse {\n    0%, 100% { box-shadow: 0 4px 12px var(--glow-purple); }\n    50% { box-shadow: 0 6px 20px var(--glow-blue); }\n}\n\n.sidebar-title {\n    font-size: 1.1rem;\n    font-weight: 700;\n    letter-spacing: -0.02em;\n    background: var(--primary-gradient);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n.sidebar-subtitle {\n    font-size: 0.65rem;\n    color: var(--accent-cyan);\n    font-weight: 600;\n    letter-spacing: 0.15em;\n    text-transform: uppercase;\n}\n\n.sidebar-nav {\n    flex: 1;\n    padding: 0 12px;\n}\n\n.nav-section {\n    margin-bottom: 32px;\n}\n\n.nav-section-title {\n    font-size: 0.65rem;\n    text-transform: uppercase;\n    color: var(--text-muted);\n    padding: 0 12px 12px;\n    letter-spacing: 0.1em;\n    font-weight: 700;\n}\n\n.nav-item {\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    padding: 12px 14px;\n    margin-bottom: 4px;\n    border-radius: 10px;\n    color: var(--text-secondary);\n    text-decoration: none;\n    transition: all 0.2s ease;\n    cursor: pointer;\n    font-size: 0.9rem;\n    font-weight: 500;\n    position: relative;\n    overflow: hidden;\n}\n\n.nav-item::before {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    height: 100%;\n    width: 0;\n    background: var(--primary-gradient);\n    transition: width 0.3s ease;\n    border-radius: 10px;\n}\n\n.nav-item:hover::before {\n    width: 4px;\n}\n\n.nav-item:hover {\n    background: var(--bg-panel-hover);\n    color: var(--text-primary);\n    transform: translateX(2px);\n}\n\n.nav-item.active {\n    background: var(--primary-gradient);\n    color: white;\n    box-shadow: 0 4px 12px var(--glow-purple);\n}\n\n.nav-item.active::before {\n    width: 0;\n}\n\n.nav-icon {\n    font-size: 1rem;\n    width: 20px;\n    text-align: center;\n}\n\n.sidebar-footer {\n    padding: 16px 20px;\n    border-top: 1px solid var(--border-color);\n}\n\n.version-info {\n    font-size: 0.75rem;\n    color: var(--text-muted);\n    font-weight: 600;\n}\n\n.main-content {\n    margin: 0 auto;\n    padding: 40px 48px;\n    padding-left: calc(260px + 48px);\n    max-width: calc(1400px + 260px);\n    width: 100%;\n}\n\n.page-header {\n    margin-bottom: 32px;\n}\n\n.page-title {\n    font-size: 2.25rem;\n    font-weight: 800;\n    margin-bottom: 8px;\n    letter-spacing: -0.03em;\n    background: linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n.page-description {\n    color: var(--text-secondary);\n    font-size: 1rem;\n}\n\n.btn {\n    padding: 10px 20px;\n    border-radius: 10px;\n    font-size: 0.9rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    border: none;\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    position: relative;\n    overflow: hidden;\n}\n\n.btn::before {\n    content: '';\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 0;\n    height: 0;\n    border-radius: 50%;\n    background: rgba(255, 255, 255, 0.1);\n    transform: translate(-50%, -50%);\n    transition: width 0.6s, height 0.6s;\n}\n\n.btn:hover::before {\n    width: 300px;\n    height: 300px;\n}\n\n.btn-primary {\n    background: var(--primary-gradient);\n    color: white;\n    box-shadow: 0 4px 12px var(--glow-purple);\n}\n\n.btn-primary:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 6px 20px var(--glow-blue);\n}\n\n.btn-secondary {\n    background: var(--bg-panel);\n    color: var(--text-secondary);\n    border: 1px solid var(--border-color);\n}\n\n.btn-secondary:hover {\n    background: var(--bg-panel-hover);\n    color: var(--text-primary);\n    border-color: var(--primary-blue);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.panel {\n    background: var(--bg-panel);\n    border-radius: 16px;\n    padding: 28px;\n    border: 1px solid var(--border-color);\n    margin-bottom: 24px;\n    transition: all 0.3s ease;\n    position: relative;\n}\n\n.panel:hover {\n    border-color: var(--primary-blue);\n    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);\n}\n\n.panel-header {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-bottom: 20px;\n}\n\n.panel-title {\n    font-size: 1rem;\n    font-weight: 700;\n    color: var(--text-primary);\n}\n\n.panel-icon {\n    font-size: 1.1rem;\n    color: var(--primary-blue);\n}\n\n.textarea-large {\n    width: 100%;\n    background: var(--bg-dark);\n    border: 2px solid var(--border-color);\n    border-radius: 12px;\n    padding: 16px;\n    color: var(--text-primary);\n    font-family: inherit;\n    font-size: 0.95rem;\n    resize: vertical;\n    min-height: 180px;\n    line-height: 1.7;\n    transition: all 0.3s ease;\n}\n\n.textarea-large:focus {\n    outline: none;\n    border-color: var(--primary-blue);\n    box-shadow: 0 0 0 4px var(--glow-blue);\n    transform: scale(1.01);\n}\n\n.textarea-large::placeholder {\n    color: var(--text-muted);\n}\n\n.execute-btn {\n    width: 100%;\n    padding: 16px;\n    background: var(--primary-gradient);\n    color: white;\n    border: none;\n    border-radius: 12px;\n    font-size: 1.05rem;\n    font-weight: 700;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    margin-top: 20px;\n    box-shadow: 0 4px 16px var(--glow-purple);\n    position: relative;\n    overflow: hidden;\n}\n\n.execute-btn::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: -100%;\n    width: 100%;\n    height: 100%;\n    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);\n    transition: left 0.5s;\n}\n\n.execute-btn:hover::before {\n    left: 100%;\n}\n\n.execute-btn:hover:not(:disabled) {\n    transform: translateY(-3px);\n    box-shadow: 0 8px 24px var(--glow-blue);\n}\n\n.execute-btn:active {\n    transform: translateY(-1px);\n}\n\n.execute-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.grid-2 {\n    display: grid;\n    grid-template-columns: repeat(2, 1fr);\n    gap: 24px;\n}\n\n.output-panel {\n    background: var(--bg-dark);\n    border: 1px solid var(--border-color);\n    border-radius: 12px;\n    padding: 20px;\n    height: 350px;\n    overflow-y: auto;\n    overflow-x: auto;\n    color: var(--text-muted);\n    font-size: 0.875rem;\n}\n\n.output-panel .empty-state {\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0.5;\n}\n\n.output-panel pre,\n.output-panel code {\n    white-space: pre-wrap;\n    word-wrap: break-word;\n    margin: 0;\n    color: var(--success-text);\n}\n\n.output-panel img {\n    max-width: 100%;\n    height: auto;\n    display: block;\n    border-radius: 8px;\n}\n\n.badge {\n    display: inline-block;\n    padding: 6px 12px;\n    border-radius: 6px;\n    font-size: 0.7rem;\n    font-weight: 700;\n    text-transform: uppercase;\n    letter-spacing: 0.05em;\n}\n\n.badge-smart {\n    background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));\n    color: var(--primary-blue);\n    border: 1px solid var(--primary-blue);\n}\n\n.mode-toggle {\n    display: inline-flex;\n    background: var(--bg-dark);\n    border-radius: 12px;\n    padding: 4px;\n    gap: 4px;\n    border: 2px solid var(--border-color);\n}\n\n.mode-toggle-btn {\n    padding: 12px 20px;\n    border-radius: 10px;\n    background: transparent;\n    border: none;\n    color: var(--text-secondary);\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-size: 0.9rem;\n    font-weight: 600;\n    position: relative;\n    overflow: hidden;\n}\n\n.mode-toggle-btn::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: var(--primary-gradient);\n    opacity: 0;\n    transition: opacity 0.3s ease;\n    border-radius: 10px;\n}\n\n.mode-toggle-btn span {\n    position: relative;\n    z-index: 1;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.mode-toggle-btn.active {\n    color: white;\n    box-shadow: 0 4px 12px var(--glow-purple);\n    transform: scale(1.05);\n}\n\n.mode-toggle-btn.active::before {\n    opacity: 1;\n}\n\n.mode-toggle-btn:hover:not(.active) {\n    color: var(--text-primary);\n    background: var(--bg-panel-hover);\n}\n\n.theme-toggle {\n    background: var(--bg-panel);\n    border: 1px solid var(--border-color);\n    border-radius: 10px;\n    padding: 10px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.theme-toggle:hover {\n    transform: rotate(180deg);\n    border-color: var(--primary-blue);\n}\n\n.spinner {\n    display: inline-block;\n    width: 18px;\n    height: 18px;\n    border: 3px solid rgba(255, 255, 255, 0.2);\n    border-top-color: white;\n    border-radius: 50%;\n    animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n    to { transform: rotate(360deg); }\n}\n\n.history-card {\n    background: var(--bg-panel);\n    border: 1px solid var(--border-color);\n    border-radius: 16px;\n    padding: 28px;\n    margin-bottom: 24px;\n    transition: all 0.3s ease;\n    position: relative;\n}\n\n.history-card:hover {\n    border-color: var(--primary-blue);\n    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);\n    transform: translateY(-2px);\n}\n\n.history-status {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px 16px;\n    border-radius: 8px;\n    font-size: 0.875rem;\n    font-weight: 600;\n    margin-bottom: 12px;\n}\n\n.history-status.success {\n    background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.05));\n    color: var(--success-text);\n    border: 1px solid var(--success-text);\n}\n\n.history-status.error {\n    background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(239, 68, 68, 0.05));\n    color: var(--error-text);\n    border: 1px solid var(--error-text);\n}\n\n.info-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    background: var(--bg-dark);\n    padding: 8px 16px;\n    border-radius: 8px;\n    font-size: 0.85rem;\n    color: var(--text-secondary);\n    border: 1px solid var(--border-color);\n    transition: all 0.2s ease;\n}\n\n.info-badge:hover {\n    border-color: var(--primary-blue);\n    transform: translateY(-1px);\n}\n\n@media (max-width: 1024px) {\n    .sidebar {\n        width: 220px;\n    }\n    \n    .main-content {\n        margin-left: 220px;\n        width: calc(100% - 220px);\n    }\n    \n    .grid-2 {\n        grid-template-columns: 1fr;\n    }\n}\n\n@media (max-width: 768px) {\n    .sidebar {\n        width: 70px;\n    }\n    \n    .sidebar-title,\n    .sidebar-subtitle,\n    .nav-item span,\n    .nav-section-title,\n    .version-info {\n        display: none;\n    }\n    \n    .main-content {\n        margin-left: 70px;\n        width: calc(100% - 70px);\n        padding: 24px 20px;\n    }\n    \n    .page-title {\n        font-size: 1.75rem;\n    }\n}\n\n.sidebar-logo svg,\n.nav-icon svg,\n.btn-icon svg,\n.panel-icon svg {\n    display: inline-block;\n    vertical-align: middle;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n    fill: none;\n}\n\n.sidebar-logo svg {\n    width: 22px;\n    height: 22px;\n    color: white;\n}\n\n.nav-icon svg {\n    width: 20px;\n    height: 20px;\n}\n\n.panel-icon svg {\n    width: 20px;\n    height: 20px;\n}\n\n.btn-icon svg {\n    width: 18px;\n    height: 18px;\n}\n\n.execute-btn svg {\n    width: 20px;\n    height: 20px;\n}\n\n.empty-state-icon svg {\n    width: 48px;\n    height: 48px;\n}\n\n::-webkit-scrollbar {\n    width: 8px;\n    height: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: var(--bg-dark);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb {\n    background: var(--border-color);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: var(--text-muted);\n}\n\n.input-group {\n    margin-bottom: 24px;\n}\n\n.input-label {\n    display: block;\n    font-size: 0.9rem;\n    font-weight: 600;\n    margin-bottom: 10px;\n    color: var(--text-primary);\n}\n\n.text-input {\n    width: 100%;\n    background: var(--bg-dark);\n    border: 2px solid var(--border-color);\n    border-radius: 10px;\n    padding: 12px 16px;\n    color: var(--text-primary);\n    font-size: 0.95rem;\n    transition: all 0.3s ease;\n}\n\n.text-input:focus {\n    outline: none;\n    border-color: var(--primary-blue);\n    box-shadow: 0 0 0 4px var(--glow-blue);\n}\n\n.alert {\n    padding: 16px;\n    border-radius: 12px;\n    margin-bottom: 24px;\n    display: flex;\n    align-items: start;\n    gap: 12px;\n    font-size: 0.95rem;\n    border: 1px solid;\n}\n\n.alert-warning {\n    background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(245, 158, 11, 0.05));\n    border-color: var(--warning-text);\n    color: var(--warning-text);\n}\n\n.code-block {\n    background: var(--bg-dark);\n    border: 1px solid var(--border-color);\n    border-radius: 12px;\n    padding: 16px;\n    font-family: 'Monaco', 'Menlo', 'Courier New', monospace;\n    font-size: 0.875rem;\n    color: var(--success-text);\n    overflow-x: auto;\n}\n\n.search-input {\n    width: 100%;\n    background: var(--bg-dark);\n    border: 2px solid var(--border-color);\n    border-radius: 10px;\n    padding: 12px 16px;\n    color: var(--text-primary);\n    font-size: 0.95rem;\n    transition: all 0.3s ease;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: var(--primary-blue);\n    box-shadow: 0 0 0 4px var(--glow-blue);\n}\n\n.search-input::placeholder {\n    color: var(--text-muted);\n}\n\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.8);\n    backdrop-filter: blur(8px);\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-content {\n    background: var(--bg-panel);\n    border-radius: 16px;\n    border: 1px solid var(--border-color);\n    width: 90%;\n    max-width: 1200px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);\n}\n\n.modal-header {\n    padding: 28px;\n    border-bottom: 1px solid var(--border-color);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n.modal-title {\n    font-size: 1.5rem;\n    font-weight: 700;\n    margin: 0;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    color: var(--text-secondary);\n    cursor: pointer;\n    padding: 8px;\n    border-radius: 8px;\n    transition: all 0.2s ease;\n}\n\n.modal-close:hover {\n    background: var(--bg-panel-hover);\n    color: var(--text-primary);\n    transform: rotate(90deg);\n}\n\n#history-container {\n    min-height: 400px;\n    display: flex;\n    flex-direction: column;\n}\n\n.empty-state {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 20px;\n    margin: auto;\n    color: var(--text-muted);\n    text-align: center;\n}\n\n.empty-state-icon {\n    opacity: 0.3;\n    color: var(--text-muted);\n}\n\n.empty-state p {\n    font-size: 1.1rem;\n    font-weight: 500;\n    color: var(--text-secondary);\n    margin: 0;\n}\n","size_bytes":17682},"auth/__init__.py":{"content":"\"\"\"\nOAuth Authentication Module\nProvides centralized OAuth 2.0 token-based authentication for gateway access\n\"\"\"\nfrom .oauth_handler import OAuthConfig, OAuthTokenFetcher, enable_certs\n\n__all__ = ['OAuthConfig', 'OAuthTokenFetcher', 'enable_certs']\n","size_bytes":249},"app/services/locator_extractor.py":{"content":"\"\"\"\nIntelligent Locator Extraction System\nGenerates high-quality Playwright locators with smart prioritization and confidence scoring\n\"\"\"\nimport re\nfrom typing import Dict, List, Optional, Tuple\nfrom dataclasses import dataclass\nfrom enum import Enum\n\n\nclass LocatorStrategy(Enum):\n    \"\"\"Locator strategies in priority order\"\"\"\n    ROLE = \"role\"  # Highest priority - semantic, accessible\n    LABEL = \"label\"  # Form elements with labels\n    PLACEHOLDER = \"placeholder\"  # Input placeholders\n    TEST_ID = \"testid\"  # Explicit test identifiers\n    TEXT = \"text\"  # Visible text content\n    ALT_TEXT = \"alt\"  # Image alt text\n    TITLE = \"title\"  # Title attribute\n    CSS = \"css\"  # CSS selectors (lowest priority)\n\n\n@dataclass\nclass LocatorResult:\n    \"\"\"Result of locator extraction\"\"\"\n    strategy: LocatorStrategy\n    locator: str\n    confidence: float  # 0.0 to 1.0\n    is_unique: bool\n    alternatives: List[Tuple[LocatorStrategy, str, float]]  # Alternative locators\n    warnings: List[str]  # Potential issues\n\n\nclass IntelligentLocatorExtractor:\n    \"\"\"\n    Extracts intelligent locators from DOM elements with quality scoring\n    \n    Features:\n    - Smart prioritization (role > label > testid > text > css)\n    - Avoids brittle selectors (nth-child, complex paths)\n    - Provides confidence scores for each locator\n    - Suggests alternative locators\n    - Warns about potential stability issues\n    \"\"\"\n    \n    # Confidence scores for each strategy\n    CONFIDENCE_SCORES = {\n        LocatorStrategy.ROLE: 0.95,\n        LocatorStrategy.LABEL: 0.90,\n        LocatorStrategy.PLACEHOLDER: 0.85,\n        LocatorStrategy.TEST_ID: 0.88,\n        LocatorStrategy.TEXT: 0.75,\n        LocatorStrategy.ALT_TEXT: 0.80,\n        LocatorStrategy.TITLE: 0.70,\n        LocatorStrategy.CSS: 0.50\n    }\n    \n    # Brittle selector patterns to avoid\n    BRITTLE_PATTERNS = [\n        r':nth-child\\(',\n        r':nth-of-type\\(',\n        r'>\\s*div\\s*>\\s*div',  # Deep div nesting\n        r'\\[class\\*=\"[^\"]*random[^\"]*\"\\]',  # Randomized classes\n        r'\\[class\\*=\"[^\"]*hash[^\"]*\"\\]',\n    ]\n    \n    # Semantic HTML roles\n    ARIA_ROLES = {\n        'button', 'link', 'checkbox', 'radio', 'textbox', 'searchbox',\n        'combobox', 'listbox', 'option', 'menu', 'menuitem', 'tab',\n        'tabpanel', 'dialog', 'alert', 'navigation', 'main', 'heading',\n        'img', 'list', 'listitem', 'row', 'cell', 'table', 'banner',\n        'contentinfo', 'complementary', 'form', 'search', 'region'\n    }\n    \n    def __init__(self):\n        \"\"\"Initialize the locator extractor\"\"\"\n        self.locator_cache = {}\n    \n    def extract_locator(\n        self,\n        element_info: Dict,\n        action_type: Optional[str] = None\n    ) -> LocatorResult:\n        \"\"\"\n        Extract the best locator for an element\n        \n        Args:\n            element_info: Dictionary containing element properties\n                {\n                    'tag': 'button',\n                    'text': 'Click me',\n                    'role': 'button',\n                    'aria_label': 'Submit form',\n                    'placeholder': 'Enter text',\n                    'test_id': 'submit-btn',\n                    'id': 'btn-123',\n                    'class': 'btn btn-primary',\n                    'name': 'submit',\n                    'type': 'submit',\n                    'alt': 'Logo',\n                    'title': 'Submit the form'\n                }\n            action_type: Type of action (click, fill, etc.)\n        \n        Returns:\n            LocatorResult with best locator and alternatives\n        \"\"\"\n        all_locators = []\n        warnings = []\n        \n        # Try each strategy in priority order\n        locator_functions = [\n            self._extract_role_locator,\n            self._extract_label_locator,\n            self._extract_placeholder_locator,\n            self._extract_testid_locator,\n            self._extract_text_locator,\n            self._extract_alt_locator,\n            self._extract_title_locator,\n            self._extract_css_locator\n        ]\n        \n        for func in locator_functions:\n            result = func(element_info)\n            if result:\n                strategy, locator = result\n                confidence = self._calculate_confidence(strategy, locator, element_info)\n                all_locators.append((strategy, locator, confidence))\n        \n        if not all_locators:\n            # Fallback to basic CSS\n            tag = element_info.get('tag', 'div')\n            return LocatorResult(\n                strategy=LocatorStrategy.CSS,\n                locator=f\"page.locator('{tag}')\",\n                confidence=0.30,\n                is_unique=False,\n                alternatives=[],\n                warnings=[\"No semantic locators found, using generic tag selector\"]\n            )\n        \n        # Best locator is first one (highest priority with highest confidence)\n        best = all_locators[0]\n        alternatives = all_locators[1:] if len(all_locators) > 1 else []\n        \n        # Check for brittle patterns\n        brittle_warnings = self._check_brittle_patterns(best[1])\n        warnings.extend(brittle_warnings)\n        \n        return LocatorResult(\n            strategy=best[0],\n            locator=best[1],\n            confidence=best[2],\n            is_unique=True,  # Assume unique for now (would need DOM context to verify)\n            alternatives=alternatives,\n            warnings=warnings\n        )\n    \n    def _extract_role_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract role-based locator (highest priority)\"\"\"\n        role = element_info.get('role') or self._infer_role(element_info)\n        \n        if not role or role not in self.ARIA_ROLES:\n            return None\n        \n        # Check for accessible name (aria-label, label, text)\n        name = (\n            element_info.get('aria_label') or\n            element_info.get('label') or\n            element_info.get('text', '').strip()\n        )\n        \n        if name:\n            # Clean and escape the name\n            name = self._clean_text(name)\n            if role == 'button':\n                return (LocatorStrategy.ROLE, f\"page.getByRole('button', {{ name: '{name}' }})\")\n            elif role == 'link':\n                return (LocatorStrategy.ROLE, f\"page.getByRole('link', {{ name: '{name}' }})\")\n            elif role == 'textbox':\n                return (LocatorStrategy.ROLE, f\"page.getByRole('textbox', {{ name: '{name}' }})\")\n            elif role == 'checkbox':\n                return (LocatorStrategy.ROLE, f\"page.getByRole('checkbox', {{ name: '{name}' }})\")\n            elif role == 'heading':\n                return (LocatorStrategy.ROLE, f\"page.getByRole('heading', {{ name: '{name}' }})\")\n            else:\n                return (LocatorStrategy.ROLE, f\"page.getByRole('{role}', {{ name: '{name}' }})\")\n        else:\n            # Role without name (less specific)\n            return (LocatorStrategy.ROLE, f\"page.getByRole('{role}')\")\n    \n    def _extract_label_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract label-based locator (good for forms)\"\"\"\n        label = element_info.get('label') or element_info.get('aria_label')\n        \n        if label:\n            label = self._clean_text(label)\n            return (LocatorStrategy.LABEL, f\"page.getByLabel('{label}')\")\n        \n        return None\n    \n    def _extract_placeholder_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract placeholder-based locator (for inputs)\"\"\"\n        placeholder = element_info.get('placeholder')\n        \n        if placeholder:\n            placeholder = self._clean_text(placeholder)\n            return (LocatorStrategy.PLACEHOLDER, f\"page.getByPlaceholder('{placeholder}')\")\n        \n        return None\n    \n    def _extract_testid_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract test ID locator (explicit test identifiers)\"\"\"\n        test_id = (\n            element_info.get('data-testid') or\n            element_info.get('data-test-id') or\n            element_info.get('data-test') or\n            element_info.get('test_id')\n        )\n        \n        if test_id:\n            return (LocatorStrategy.TEST_ID, f\"page.getByTestId('{test_id}')\")\n        \n        return None\n    \n    def _extract_text_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract text-based locator\"\"\"\n        text = element_info.get('text', '').strip()\n        \n        if text and len(text) > 0 and len(text) < 100:  # Reasonable text length\n            text = self._clean_text(text)\n            # Check if it's exact match or partial\n            if len(text) < 50:\n                return (LocatorStrategy.TEXT, f\"page.getByText('{text}')\")\n            else:\n                # Use partial match for long text\n                partial = text[:30]\n                return (LocatorStrategy.TEXT, f\"page.getByText('{partial}', {{ exact: false }})\")\n        \n        return None\n    \n    def _extract_alt_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract alt text locator (for images)\"\"\"\n        alt = element_info.get('alt')\n        \n        if alt:\n            alt = self._clean_text(alt)\n            return (LocatorStrategy.ALT_TEXT, f\"page.getByAltText('{alt}')\")\n        \n        return None\n    \n    def _extract_title_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract title-based locator\"\"\"\n        title = element_info.get('title')\n        \n        if title:\n            title = self._clean_text(title)\n            return (LocatorStrategy.TITLE, f\"page.getByTitle('{title}')\")\n        \n        return None\n    \n    def _extract_css_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract CSS locator (last resort)\"\"\"\n        # Priority: ID > stable class > tag + attributes\n        \n        elem_id = element_info.get('id')\n        if elem_id and not self._looks_dynamic(elem_id):\n            return (LocatorStrategy.CSS, f\"page.locator('#{elem_id}')\")\n        \n        # Use stable classes (avoid hashed/random ones)\n        classes = element_info.get('class', '').split()\n        stable_classes = [c for c in classes if not self._looks_dynamic(c)]\n        \n        if stable_classes:\n            class_selector = '.' + '.'.join(stable_classes[:2])  # Max 2 classes\n            tag = element_info.get('tag', '')\n            if tag:\n                return (LocatorStrategy.CSS, f\"page.locator('{tag}{class_selector}')\")\n            else:\n                return (LocatorStrategy.CSS, f\"page.locator('{class_selector}')\")\n        \n        # Fallback to tag + type/name\n        tag = element_info.get('tag', 'div')\n        elem_type = element_info.get('type')\n        name = element_info.get('name')\n        \n        if elem_type:\n            return (LocatorStrategy.CSS, f\"page.locator('{tag}[type=\\\"{elem_type}\\\"]')\")\n        elif name:\n            return (LocatorStrategy.CSS, f\"page.locator('{tag}[name=\\\"{name}\\\"]')\")\n        else:\n            return (LocatorStrategy.CSS, f\"page.locator('{tag}')\")\n    \n    def _infer_role(self, element_info: Dict) -> Optional[str]:\n        \"\"\"Infer ARIA role from element properties\"\"\"\n        tag = element_info.get('tag', '').lower()\n        elem_type = element_info.get('type', '').lower()\n        \n        # Map HTML elements to ARIA roles\n        role_map = {\n            'button': 'button',\n            'a': 'link',\n            'input': {\n                'text': 'textbox',\n                'email': 'textbox',\n                'password': 'textbox',\n                'search': 'searchbox',\n                'tel': 'textbox',\n                'url': 'textbox',\n                'number': 'textbox',\n                'checkbox': 'checkbox',\n                'radio': 'radio',\n                'submit': 'button',\n                'button': 'button'\n            },\n            'textarea': 'textbox',\n            'select': 'combobox',\n            'img': 'img',\n            'nav': 'navigation',\n            'main': 'main',\n            'header': 'banner',\n            'footer': 'contentinfo',\n            'aside': 'complementary',\n            'form': 'form',\n            'h1': 'heading',\n            'h2': 'heading',\n            'h3': 'heading',\n            'h4': 'heading',\n            'h5': 'heading',\n            'h6': 'heading',\n            'ul': 'list',\n            'ol': 'list',\n            'li': 'listitem',\n            'table': 'table',\n            'tr': 'row',\n            'td': 'cell',\n            'th': 'cell'\n        }\n        \n        if tag in role_map:\n            role_value = role_map[tag]\n            if isinstance(role_value, dict):\n                return role_value.get(elem_type, 'textbox' if tag == 'input' else None)\n            return role_value\n        \n        return None\n    \n    def _calculate_confidence(\n        self,\n        strategy: LocatorStrategy,\n        locator: str,\n        element_info: Dict\n    ) -> float:\n        \"\"\"Calculate confidence score for a locator\"\"\"\n        base_confidence = self.CONFIDENCE_SCORES[strategy]\n        \n        # Adjust based on locator characteristics\n        adjustments = 0.0\n        \n        # Bonus for specific attributes\n        if 'name:' in locator or \"name: '\" in locator:\n            adjustments += 0.05  # Has accessible name\n        \n        # Penalty for generic selectors\n        if locator.count('div') > 1:\n            adjustments -= 0.10  # Multiple divs\n        \n        # Penalty for complex selectors\n        if locator.count('>') > 2:\n            adjustments -= 0.15  # Deep nesting\n        \n        # Bonus for test IDs\n        if 'getByTestId' in locator:\n            adjustments += 0.10  # Explicit test identifier\n        \n        # Check for brittle patterns\n        for pattern in self.BRITTLE_PATTERNS:\n            if re.search(pattern, locator):\n                adjustments -= 0.20\n                break\n        \n        return max(0.0, min(1.0, base_confidence + adjustments))\n    \n    def _check_brittle_patterns(self, locator: str) -> List[str]:\n        \"\"\"Check for brittle selector patterns\"\"\"\n        warnings = []\n        \n        for pattern in self.BRITTLE_PATTERNS:\n            if re.search(pattern, locator):\n                warnings.append(f\"Brittle pattern detected: {pattern}\")\n        \n        if locator.count('>') > 3:\n            warnings.append(\"Deep selector nesting may be fragile\")\n        \n        if ':nth-child(' in locator or ':nth-of-type(' in locator:\n            warnings.append(\"Position-based selector may break if DOM changes\")\n        \n        return warnings\n    \n    def _looks_dynamic(self, value: str) -> bool:\n        \"\"\"Check if a class or ID looks dynamically generated\"\"\"\n        # Patterns that indicate dynamic values\n        dynamic_patterns = [\n            r'[a-f0-9]{8,}',  # Long hex strings\n            r'_[0-9a-z]{6,}$',  # Trailing hash\n            r'^[a-z]{1,2}[0-9]+$',  # Short prefix + numbers\n            r'random|hash|uuid|guid',\n        ]\n        \n        for pattern in dynamic_patterns:\n            if re.search(pattern, value.lower()):\n                return True\n        \n        return False\n    \n    def _clean_text(self, text: str) -> str:\n        \"\"\"Clean and escape text for use in selectors\"\"\"\n        # Remove extra whitespace\n        text = ' '.join(text.split())\n        # Escape single quotes\n        text = text.replace(\"'\", \"\\\\'\")\n        # Limit length\n        if len(text) > 100:\n            text = text[:97] + '...'\n        return text\n    \n    def get_quality_indicator(self, confidence: float) -> Dict[str, str]:\n        \"\"\"\n        Get visual quality indicator for UI display\n        \n        Returns:\n            {\n                'level': 'excellent' | 'good' | 'fair' | 'poor',\n                'color': 'green' | 'yellow' | 'orange' | 'red',\n                'emoji': 'üü¢' | 'üü°' | 'üü†' | 'üî¥'\n            }\n        \"\"\"\n        if confidence >= 0.85:\n            return {'level': 'excellent', 'color': 'green', 'emoji': 'üü¢'}\n        elif confidence >= 0.70:\n            return {'level': 'good', 'color': 'yellow', 'emoji': 'üü°'}\n        elif confidence >= 0.50:\n            return {'level': 'fair', 'color': 'orange', 'emoji': 'üü†'}\n        else:\n            return {'level': 'poor', 'color': 'red', 'emoji': 'üî¥'}\n\n\ndef extract_locator_from_action(action_data: Dict) -> LocatorResult:\n    \"\"\"\n    Convenience function to extract locator from action data\n    \n    Args:\n        action_data: Action data with element information\n    \n    Returns:\n        LocatorResult\n    \"\"\"\n    extractor = IntelligentLocatorExtractor()\n    element_info = action_data.get('element', {})\n    action_type = action_data.get('action_type', None)\n    \n    return extractor.extract_locator(element_info, action_type)\n","size_bytes":16989},"app/engines/browser_use/__init__.py":{"content":"\"\"\"\nBrowser-Use Codebase\nAI-powered browser automation using browser-use library with LLM reasoning\n\"\"\"\nfrom app.engines.browser_use.engine_optimized import OptimizedBrowserUseEngine\n\n\ndef create_engine(headless: bool = False):\n    \"\"\"\n    Factory function to create an optimized Browser-Use engine instance\n    \n    The engine will automatically select the appropriate LLM model based on config.ini:\n    - If use_chat_browser_use=true, uses ChatBrowserUse (3-5x faster)\n    - Otherwise uses standard OpenAI models\n    \n    Args:\n        headless: Run browser in headless mode\n        \n    Returns:\n        OptimizedBrowserUseEngine instance with advanced features enabled\n    \"\"\"\n    return OptimizedBrowserUseEngine(headless=headless, enable_advanced_features=True)\n\n\n__all__ = ['OptimizedBrowserUseEngine', 'create_engine']\n","size_bytes":827},"replit.md":{"content":"# AI Browser Automation\n\n## Overview\nThis project is an AI-powered web automation application built with Flask, designed to provide a web interface for automating browser tasks using AI agents. Its purpose is to enable users to easily create and manage complex web automations. The application supports **two automation engines**: Browser Use (default) and Playwright MCP (advanced). It emphasizes security, privacy, and state persistence, making it suitable for various automation needs.\n\n## Recent Changes (November 2025)\n- **Replit Environment Setup (November 7, 2025)**: Successfully configured for Replit\n  - Installed Python 3.11 and Node.js 20\n  - Installed system dependencies for Playwright (Chromium, X11, Mesa, etc.)\n  - Installed all Python dependencies from requirements.txt\n  - Playwright Chromium browser installed and configured\n  - Flask development server running on 0.0.0.0:5000\n  - Production deployment configured with Gunicorn\n- **Playwright MCP Engine Added**: New automation engine using Playwright MCP server with AI agents\n  - Supports both Claude and GPT-4o models\n  - Automatic MCP server management via npx\n  - Seamless engine switching through configuration UI\n  - Uses Model Context Protocol for advanced browser automation\n\n## User Preferences\n- **AI Model**: Configured to use `gpt-4.1-2025-04-14-eastus-dz` for all AI operations\n  - Model is read from `config/config.ini` and applied to both automation engines\n- **Automation Engine**: Browser Use (default) or Playwright MCP\n  - Configurable in `config/config.ini` under `[engine]` section\n  - Switchable via Configuration page in the web interface\n\n## System Architecture\nThe application uses Python 3.11 with the Flask web framework, SQLite for local data storage, and supports two automation engines for browser automation.\n\n### Automation Engines\n\n#### Browser Use Engine (Default)\n- Uses the `browser-use` library for AI-powered automation\n- Best for most tasks, simpler setup\n- Direct Playwright integration\n- Faster execution for simple tasks\n\n#### Playwright MCP Engine (Advanced)\n- Uses Playwright MCP (Model Context Protocol) server\n- AI agents (Claude/GPT-4o) control browser via MCP tools\n- More structured approach with tool-based automation\n- Requires Node.js 20+ for MCP server\n- Automatic server management via npx\n\n### Key Features\n- **Dual Engine Support**: Choose between Browser Use and Playwright MCP engines\n- **Browser Automation**: AI-guided web browsing actions using advanced AI models\n- **Web Interface**: User-friendly dashboard for managing automations\n- **Security**: API key authentication, rate limiting, and CORS protection\n- **Privacy-First**: No telemetry or cloud sync by default\n- **State Persistence**: Ability to save and restore browser states\n- **Screenshot & PDF Generation**: Capture and display of automation results\n\n### Project Structure\nThe codebase is organized into logical directories:\n- `app/`: Contains the Flask application, including engines, middleware, routes, services, static assets, templates, and utilities.\n  - `app/engines/browser_use/`: Browser Use engine implementation\n  - `app/engines/playwright_mcp/`: Playwright MCP engine implementation\n    - `engine_mcp.py`: Main MCP engine\n    - `mcp_client.py`: MCP server client\n    - `ai_agents.py`: AI agents for automation\n  - `app/services/engine_orchestrator.py`: Manages both engines\n- `auth/`: Handles OAuth authentication.\n- `config/`: Stores configuration files.\n- `instance/`: Used for SQLite database storage.\n- `main.py`: The application's entry point.\n- `requirements.txt`: Lists Python dependencies.\n- `package.json`: Node.js configuration for Playwright MCP server.\n\n### Configuration\n- **Environment Variables**: OAuth credentials for AI features (e.g., `OAUTH_TOKEN_URL`, `OAUTH_CLIENT_ID`) and security settings (`SESSION_SECRET`, `API_KEY`) are managed via Replit Secrets.\n  - For Playwright MCP: `ANTHROPIC_API_KEY` or `OPENAI_API_KEY` (at least one required)\n- **Application Configuration**: Detailed settings for browser, AI models, logging, performance, and advanced features are controlled through `config/config.ini`.\n  - `[engine]` section: Select automation engine (`browser_use` or `playwright_mcp`)\n  - Engine selection is also available via the Configuration page in the web interface\n\n### Database\n- **Type**: SQLite, located at `instance/automation_history.db`.\n- **Management**: Tables are automatically created on startup, and data is included in Replit snapshots.\n\n## External Dependencies\n- **Python Packages**:\n    - `Flask`: Web framework\n    - `browser-use`: AI-powered browser automation engine (Browser Use engine)\n    - `SQLAlchemy`: Database ORM\n    - `Gunicorn`: Production WSGI server\n    - `Anthropic`, `OpenAI`, `Google GenAI`: SDKs for various AI providers\n    - `mcp`: Model Context Protocol library (for Playwright MCP engine)\n    - `playwright`: Browser automation library (used by both engines)\n- **Node.js Dependencies** (for Playwright MCP engine):\n    - `@playwright/mcp`: Playwright MCP server (auto-installed via npx on first use)\n    - Node.js 20+ is required for Playwright MCP engine\n- **System Dependencies**:\n    - Chromium browser dependencies (e.g., X11, Mesa, Cairo, Pango) are installed to support browser automation\n\n## Setup Notes\n- **Replit Environment**: \n  - Python 3.11 and Node.js 20 are installed via Replit modules\n  - System dependencies for Playwright browser automation are installed\n  - Flask runs on 0.0.0.0:5000 for proper Replit webview integration\n  - Production deployment uses Gunicorn with autoscale configuration\n  - Workflow configured to automatically start the Flask application\n- **Playwright MCP Engine**: The `@playwright/mcp` package is automatically installed on first use via npx. No manual npm install required.\n- **Engine Switching**: Users can switch between Browser Use and Playwright MCP engines in the Configuration page without restarting the application.\n- **Environment Variables**: OAuth credentials are optional - the app will start and run without them, but AI automation features will require proper OAuth configuration.","size_bytes":6121},"app/routes/__init__.py":{"content":"\"\"\"\nFlask Routes Module\n\"\"\"\nfrom app.routes.api import create_api_routes\n\n__all__ = ['create_api_routes']\n","size_bytes":106},"app/engines/playwright_mcp/engine_mcp.py":{"content":"\"\"\"\nPlaywright MCP Engine - Main engine for MCP-based automation\n\"\"\"\nimport asyncio\nimport logging\nimport os\nimport configparser\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional\n\nfrom .mcp_client import PlaywrightMCPClient\nfrom .ai_agents import MCPExecutorAgent\nfrom auth.oauth_handler import get_oauth_token_with_retry\n\nlogger = logging.getLogger(__name__)\n\n\nclass PlaywrightMCPEngine:\n    \"\"\"Main engine for Playwright MCP-based browser automation\"\"\"\n    \n    def __init__(self):\n        self.config = self._load_config()\n        self.mcp_command = \"npx\"\n        self.mcp_args = [\"@playwright/mcp\"]\n        self._mcp_client: Optional[PlaywrightMCPClient] = None\n        \n    def _load_config(self) -> configparser.ConfigParser:\n        \"\"\"Load configuration from config.ini\"\"\"\n        config = configparser.ConfigParser()\n        config_path = Path(__file__).parent.parent.parent.parent / 'config' / 'config.ini'\n        \n        if config_path.exists():\n            config.read(config_path)\n        \n        return config\n    \n    async def run_task(self, task_description: str, headless: bool = True, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Run an automation task using Playwright MCP\n        Supports both OAuth (like Browser Use) and direct API keys\n        \n        Args:\n            task_description: Natural language description of the task\n            headless: Whether to run browser in headless mode\n            **kwargs: Additional parameters (model_name, api_key, etc.)\n        \n        Returns:\n            Dictionary with task execution results\n        \"\"\"\n        logger.info(f\"üöÄ Playwright MCP Engine starting task: {task_description} (headless={headless})\")\n        \n        # Get model configuration\n        model_name = kwargs.get('model_name', self.config.get('openai', 'model', fallback='gpt-4o'))\n        api_key = None\n        use_oauth = False\n        \n        gateway_base_url = os.environ.get('GW_BASE_URL', '')\n        if gateway_base_url:\n            try:\n                logger.info(\"üîê Using OAuth authentication (like Browser Use)\")\n                api_key = get_oauth_token_with_retry(max_retries=3)\n                use_oauth = True\n                logger.info(\"‚úÖ OAuth token obtained successfully\")\n            except Exception as e:\n                logger.warning(f\"‚ö†Ô∏è  OAuth authentication failed: {e}\")\n                logger.info(\"üìã Falling back to direct API keys...\")\n        \n        if not api_key:\n            api_key = kwargs.get('api_key', os.environ.get('OPENAI_API_KEY', ''))\n        \n        if not api_key:\n            api_key = os.environ.get('ANTHROPIC_API_KEY', '')\n            if api_key:\n                model_name = 'claude-sonnet-4-20250514'\n                logger.info(\"ü§ñ Using Anthropic Claude model\")\n        \n        if not api_key:\n            error_msg = \"No API key found. Please set up OAuth (GW_BASE_URL + OAuth env vars) or set OPENAI_API_KEY/ANTHROPIC_API_KEY.\"\n            logger.error(f\"‚ùå {error_msg}\")\n            return {\n                \"success\": False,\n                \"error\": error_msg,\n                \"result\": None\n            }\n        \n        try:\n            # Connect to MCP server\n            async with PlaywrightMCPClient(self.mcp_command, self.mcp_args) as mcp_client:\n                self._mcp_client = mcp_client\n                \n                # Create executor agent\n                # Pass gateway_base_url if using OAuth, otherwise pass None for direct API access\n                base_url = gateway_base_url if use_oauth else None\n                executor = MCPExecutorAgent(model_name, api_key, mcp_client, base_url=base_url)\n                \n                # Execute the task with headless preference\n                result = await executor.execute_task(task_description, headless=headless)\n                \n                if result[\"success\"]:\n                    logger.info(\"‚úì Task completed successfully\")\n                    return {\n                        \"success\": True,\n                        \"result\": {\n                            \"message\": \"Task completed successfully\",\n                            \"trace\": result[\"trace\"],\n                            \"model\": result[\"model\"]\n                        },\n                        \"error\": None\n                    }\n                else:\n                    logger.error(f\"Task execution failed: {result.get('error', 'Unknown error')}\")\n                    return {\n                        \"success\": False,\n                        \"error\": result.get('error', 'Task execution failed'),\n                        \"result\": {\"trace\": result[\"trace\"]}\n                    }\n                \n        except Exception as e:\n            logger.error(f\"Error running MCP engine: {e}\", exc_info=True)\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"result\": None\n            }\n        finally:\n            self._mcp_client = None\n    \n    async def health_check(self) -> Dict[str, Any]:\n        \"\"\"Check if the MCP engine is healthy and ready\"\"\"\n        try:\n            # Try to connect to MCP server\n            async with PlaywrightMCPClient(self.mcp_command, self.mcp_args) as mcp_client:\n                tools_count = len(mcp_client.tools)\n                return {\n                    \"healthy\": True,\n                    \"message\": f\"MCP server connected with {tools_count} tools available\",\n                    \"tools_count\": tools_count\n                }\n        except Exception as e:\n            return {\n                \"healthy\": False,\n                \"message\": f\"MCP server connection failed: {str(e)}\",\n                \"error\": str(e)\n            }\n","size_bytes":5722},"app/utils/credentials.py":{"content":"\"\"\"\nCredential placeholder replacement utilities\n\"\"\"\nimport re\nimport logging\nfrom app.models import CredentialVault\n\nlogger = logging.getLogger(__name__)\n\n\ndef replace_credential_placeholders(instruction: str) -> tuple[str, list[str]]:\n    \"\"\"\n    Replace credential placeholders in the instruction with actual values.\n    Also detect credential names mentioned in the instruction and inject URL, username, and password.\n    \n    Supports two modes:\n    1. Placeholder format: {{credential_name}} - replaces with password only (legacy mode)\n    2. Natural language: \"log in to gmail\" - injects URL, username, and password\n    \n    Args:\n        instruction: The instruction string that may contain placeholders or credential names\n        \n    Returns:\n        Tuple of (processed_instruction, list_of_credentials_used)\n        \n    Example:\n        Input: \"log in to gmail\"\n        Output: (\"Go to https://mail.google.com and log in with username user@gmail.com and password MyActualPassword123\", [\"gmail\"])\n    \"\"\"\n    processed_instruction = instruction\n    credentials_used = []\n    missing_credentials = []\n    decryption_errors = []\n    \n    # Get all credentials from database\n    all_credentials = CredentialVault.query.all()\n    \n    # First, handle placeholder format {{credential_name}}\n    placeholder_pattern = r'\\{\\{([a-zA-Z0-9_]+)\\}\\}'\n    placeholders = re.findall(placeholder_pattern, instruction)\n    \n    for credential_name in placeholders:\n        credential = CredentialVault.query.filter_by(name=credential_name).first()\n        \n        if credential:\n            try:\n                # Get the decrypted value\n                actual_value = credential.get_credential()\n                \n                # Replace the placeholder with the actual value\n                placeholder = f\"{{{{{credential_name}}}}}\"\n                processed_instruction = processed_instruction.replace(placeholder, actual_value)\n                \n                if credential_name not in credentials_used:\n                    credentials_used.append(credential_name)\n                logger.info(f\"üîê Replaced credential placeholder: {{{{{{credential_name}}}}}}\")\n                \n            except ValueError as e:\n                logger.error(f\"Encryption error for credential '{credential_name}': {str(e)}\")\n                raise ValueError(\n                    f\"Cannot decrypt credentials: {str(e)} \"\n                    \"Please set the ENCRYPTION_KEY environment variable or Replit Secret.\"\n                )\n            except Exception as e:\n                logger.error(f\"Failed to decrypt credential '{credential_name}': {str(e)}\")\n                decryption_errors.append(f\"{credential_name}: {str(e)}\")\n        else:\n            logger.warning(f\"‚ö†Ô∏è  Credential not found: {{{{{{credential_name}}}}}}\")\n            missing_credentials.append(credential_name)\n    \n    # Second, detect credential names in natural language (case-insensitive)\n    instruction_lower = processed_instruction.lower()\n    \n    for credential in all_credentials:\n        credential_name_lower = credential.name.lower()\n        \n        # Check if credential name is mentioned in the instruction\n        # Look for patterns like \"log in to gmail\", \"login to gmail\", \"sign in to gmail\"\n        login_patterns = [\n            f\"log in to {credential_name_lower}\",\n            f\"login to {credential_name_lower}\",\n            f\"sign in to {credential_name_lower}\",\n            f\"signin to {credential_name_lower}\",\n            f\"log into {credential_name_lower}\",\n            f\"sign into {credential_name_lower}\",\n            f\"authenticate to {credential_name_lower}\",\n            f\"authenticate with {credential_name_lower}\",\n        ]\n        \n        # Also check if just the credential name is mentioned with context words\n        if any(pattern in instruction_lower for pattern in login_patterns):\n            try:\n                password = credential.get_credential()\n                username = credential.username or \"\"\n                url = credential.url or \"\"\n                \n                # Build the replacement text with all credential info\n                replacement_parts = []\n                \n                if url:\n                    replacement_parts.append(f\"go to {url}\")\n                \n                if username and password:\n                    replacement_parts.append(f\"log in with username {username} and password {password}\")\n                elif password:\n                    replacement_parts.append(f\"log in with password {password}\")\n                \n                if replacement_parts:\n                    replacement_text = \" and \".join(replacement_parts)\n                    \n                    # Find and replace the login pattern in the instruction\n                    for pattern in login_patterns:\n                        if pattern in instruction_lower:\n                            # Find the actual text in the original instruction (preserving case)\n                            start_idx = instruction_lower.find(pattern)\n                            end_idx = start_idx + len(pattern)\n                            original_text = processed_instruction[start_idx:end_idx]\n                            \n                            # Replace with detailed credential information\n                            processed_instruction = (\n                                processed_instruction[:start_idx] +\n                                replacement_text +\n                                processed_instruction[end_idx:]\n                            )\n                            \n                            if credential.name not in credentials_used:\n                                credentials_used.append(credential.name)\n                            logger.info(f\"üîê Detected and expanded credential reference: {credential.name}\")\n                            logger.info(f\"   URL: {url if url else 'Not set'}\")\n                            logger.info(f\"   Username: {username if username else 'Not set'}\")\n                            logger.info(f\"   Password: {'*' * len(password) if password else 'Not set'}\")\n                            break\n                \n            except ValueError as e:\n                logger.error(f\"Encryption error for credential '{credential.name}': {str(e)}\")\n                raise ValueError(\n                    f\"Cannot decrypt credentials: {str(e)} \"\n                    \"Please set the ENCRYPTION_KEY environment variable or Replit Secret.\"\n                )\n            except Exception as e:\n                logger.error(f\"Failed to decrypt credential '{credential.name}': {str(e)}\")\n                decryption_errors.append(f\"{credential.name}: {str(e)}\")\n    \n    if decryption_errors:\n        raise ValueError(\n            f\"Failed to decrypt credentials: {'; '.join(decryption_errors)}\"\n        )\n    \n    if missing_credentials:\n        raise ValueError(\n            f\"Missing credentials: {', '.join(missing_credentials)}. \"\n            f\"Please add these credentials in the Credentials page before using them in automations.\"\n        )\n    \n    return processed_instruction, credentials_used\n\n\ndef has_credential_placeholders(instruction: str) -> bool:\n    \"\"\"\n    Check if the instruction contains any credential placeholders.\n    \n    Args:\n        instruction: The instruction string to check\n        \n    Returns:\n        True if placeholders are found, False otherwise\n    \"\"\"\n    placeholder_pattern = r'\\{\\{([a-zA-Z0-9_]+)\\}\\}'\n    return bool(re.search(placeholder_pattern, instruction))\n\n\ndef extract_credential_names(instruction: str) -> list[str]:\n    \"\"\"\n    Extract credential names from placeholders in the instruction.\n    \n    Args:\n        instruction: The instruction string that may contain placeholders\n        \n    Returns:\n        List of credential names found in placeholders\n    \"\"\"\n    placeholder_pattern = r'\\{\\{([a-zA-Z0-9_]+)\\}\\}'\n    return re.findall(placeholder_pattern, instruction)\n","size_bytes":8006},"app/middleware/security.py":{"content":"\"\"\"\nSecurity Middleware\nAuthentication, rate limiting, and security utilities\n\"\"\"\nimport os\nimport time\nimport logging\nfrom functools import wraps\nfrom flask import request, jsonify\nfrom typing import Dict, Tuple, Optional\n\nlogger = logging.getLogger(__name__)\n\n\nclass RateLimiter:\n    \"\"\"Simple in-memory rate limiter\"\"\"\n    \n    def __init__(self, max_requests: int = 10, window_seconds: int = 60):\n        \"\"\"\n        Initialize rate limiter\n        \n        Args:\n            max_requests: Maximum requests allowed in the time window\n            window_seconds: Time window in seconds\n        \"\"\"\n        self.max_requests = max_requests\n        self.window_seconds = window_seconds\n        self.requests: Dict[str, list] = {}\n    \n    def is_allowed(self, client_id: str) -> Tuple[bool, Optional[int]]:\n        \"\"\"\n        Check if request is allowed for client\n        \n        Args:\n            client_id: Unique identifier for the client\n            \n        Returns:\n            Tuple of (is_allowed, retry_after_seconds)\n        \"\"\"\n        now = time.time()\n        \n        if client_id not in self.requests:\n            self.requests[client_id] = []\n        \n        requests = self.requests[client_id]\n        requests = [req_time for req_time in requests if now - req_time < self.window_seconds]\n        \n        if len(requests) >= self.max_requests:\n            oldest_request = min(requests)\n            retry_after = int(self.window_seconds - (now - oldest_request)) + 1\n            return False, retry_after\n        \n        requests.append(now)\n        self.requests[client_id] = requests\n        \n        self._cleanup_old_entries(now)\n        \n        return True, None\n    \n    def _cleanup_old_entries(self, now: float):\n        \"\"\"Clean up old entries to prevent memory bloat\"\"\"\n        clients_to_remove = []\n        for client_id, requests in self.requests.items():\n            active_requests = [req_time for req_time in requests if now - req_time < self.window_seconds]\n            if not active_requests:\n                clients_to_remove.append(client_id)\n            else:\n                self.requests[client_id] = active_requests\n        \n        for client_id in clients_to_remove:\n            del self.requests[client_id]\n\n\nrate_limiter = RateLimiter(max_requests=10, window_seconds=60)\n\n\ndef require_api_key(f):\n    \"\"\"\n    Decorator to require API key authentication\n    \n    Checks for API key in:\n    1. X-API-Key header\n    2. api_key query parameter\n    \n    Set API_KEY environment variable to enable authentication.\n    If API_KEY is not set, authentication is disabled (development mode).\n    \"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        expected_api_key = os.environ.get('API_KEY')\n        \n        if not expected_api_key:\n            logger.warning(\"‚ö†Ô∏è  API_KEY not set - authentication disabled (development mode)\")\n            return f(*args, **kwargs)\n        \n        provided_api_key = request.headers.get('X-API-Key') or request.args.get('api_key')\n        \n        if not provided_api_key:\n            logger.warning(f\"üîí Unauthorized request from {request.remote_addr} - no API key provided\")\n            return jsonify({\n                'success': False,\n                'error': 'Authentication required',\n                'message': 'Please provide an API key via X-API-Key header or api_key parameter'\n            }), 401\n        \n        if provided_api_key != expected_api_key:\n            logger.warning(f\"üîí Unauthorized request from {request.remote_addr} - invalid API key\")\n            return jsonify({\n                'success': False,\n                'error': 'Invalid API key'\n            }), 403\n        \n        return f(*args, **kwargs)\n    \n    return decorated_function\n\n\ndef rate_limit(f):\n    \"\"\"\n    Decorator to apply rate limiting\n    \n    Uses IP address as client identifier\n    \"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        client_id = request.remote_addr or 'unknown'\n        \n        allowed, retry_after = rate_limiter.is_allowed(client_id)\n        \n        if not allowed:\n            logger.warning(f\"‚ö†Ô∏è  Rate limit exceeded for {client_id}\")\n            return jsonify({\n                'success': False,\n                'error': 'Rate limit exceeded',\n                'message': f'Too many requests. Please try again in {retry_after} seconds.',\n                'retry_after': retry_after\n            }), 429\n        \n        return f(*args, **kwargs)\n    \n    return decorated_function\n\n\ndef validate_engine_type(engine_type: str) -> Tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate engine type parameter\n    \n    Args:\n        engine_type: Engine type to validate\n        \n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    valid_engines = ['browser_use', 'playwright_mcp']\n    \n    if engine_type not in valid_engines:\n        return False, f\"Invalid engine type '{engine_type}'. Must be one of: {', '.join(valid_engines)}\"\n    \n    return True, None\n\n\ndef validate_instruction(instruction: str) -> Tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate instruction parameter\n    \n    Args:\n        instruction: Instruction to validate\n        \n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    if not instruction or not instruction.strip():\n        return False, \"Instruction cannot be empty\"\n    \n    if len(instruction) > 5000:\n        return False, \"Instruction is too long (maximum 5000 characters)\"\n    \n    return True, None\n\n\ndef sanitize_error_message(error: Exception) -> str:\n    \"\"\"\n    Convert internal exception to user-safe error message\n    \n    Args:\n        error: Exception to sanitize\n        \n    Returns:\n        User-safe error message\n    \"\"\"\n    error_str = str(error).lower()\n    \n    if 'openai' in error_str or 'api' in error_str:\n        return \"AI service error. Please try again later.\"\n    \n    if 'browser' in error_str or 'playwright' in error_str:\n        return \"Browser automation error. Please try again.\"\n    \n    if 'timeout' in error_str:\n        return \"Operation timed out. The task took too long to complete.\"\n    \n    if 'permission' in error_str or 'denied' in error_str:\n        return \"Permission denied. Please check your access rights.\"\n    \n    return \"An unexpected error occurred. Please try again.\"\n","size_bytes":6336},"app/engines/playwright_mcp/ai_agents.py":{"content":"\"\"\"\nAI Agents for Playwright MCP Engine\n\"\"\"\nimport json\nimport logging\nfrom typing import Any, Dict, List, Union\nfrom anthropic import Anthropic\nfrom openai import OpenAI\n\nlogger = logging.getLogger(__name__)\n\n\nclass MCPExecutorAgent:\n    \"\"\"Agent that executes browser automation tasks using MCP tools\"\"\"\n    \n    def __init__(self, model_name: str, api_key: str, mcp_client, base_url: str = None):\n        self.model_name = model_name\n        self.api_key = api_key\n        self.mcp_client = mcp_client\n        self.base_url = base_url\n        self.execution_trace: List[Dict[str, Any]] = []\n        \n        # Determine which LLM client to use\n        if \"claude\" in model_name.lower() or \"anthropic\" in model_name.lower():\n            self.client = Anthropic(api_key=api_key)\n            self.client_type = \"claude\"\n        elif \"gpt\" in model_name.lower() or \"openai\" in model_name.lower():\n            if base_url:\n                logger.info(f\"üîê Using OAuth gateway: {base_url}\")\n                self.client = OpenAI(api_key=api_key, base_url=base_url)\n            else:\n                self.client = OpenAI(api_key=api_key)\n            self.client_type = \"openai\"\n        else:\n            # Default to OpenAI with gateway if base_url provided\n            if base_url:\n                logger.info(f\"üîê Using OAuth gateway: {base_url}\")\n                self.client = OpenAI(api_key=api_key, base_url=base_url)\n                self.client_type = \"openai\"\n            else:\n                self.client = Anthropic(api_key=api_key)\n                self.client_type = \"claude\"\n    \n    async def execute_task(self, task_description: str, headless: bool = True) -> Dict[str, Any]:\n        \"\"\"Execute a browser automation task\"\"\"\n        logger.info(f\"ü§ñ MCPExecutorAgent starting task: {task_description} (headless={headless})\")\n        \n        self.execution_trace = []\n        \n        tools_description = self.mcp_client.get_tools_description()\n        \n        browser_mode = \"headless mode (no visible window)\" if headless else \"headful mode (visible browser window)\"\n        \n        system_prompt = f\"\"\"You are a browser automation expert. Your task is to perform web automation using Playwright MCP tools.\n\nIMPORTANT: When launching the browser, you MUST run it in {browser_mode}.\nFor any playwright_launch or browser launch tool calls, set headless parameter to {str(headless).lower()}.\n\nWhen performing tasks:\n1. Launch browser in {browser_mode}\n2. Use accessible selectors (role, label, placeholder, test-id) when possible\n3. Navigate step by step\n4. Verify actions were successful\n5. Be precise with selectors\n\nDescribe each action clearly as you perform it.\"\"\"\n        \n        prompt = f\"\"\"Task: {task_description}\n\nAvailable Playwright MCP tools:\n{tools_description}\n\nREMEMBER: Launch the browser in {browser_mode} (headless={str(headless).lower()}).\n\nExecute this task step by step using the available tools. After each action, describe what you did and what you observe.\"\"\"\n        \n        if self.client_type == \"claude\":\n            result = await self._execute_with_claude(prompt, system_prompt)\n        else:\n            result = await self._execute_with_openai(prompt, system_prompt)\n        \n        return result\n    \n    async def _execute_with_claude(self, prompt: str, system_prompt: str) -> Dict[str, Any]:\n        \"\"\"Execute task using Claude\"\"\"\n        mcp_tools = []\n        for tool in self.mcp_client.tools:\n            mcp_tools.append({\n                \"name\": tool[\"name\"],\n                \"description\": tool.get(\"description\", \"\"),\n                \"input_schema\": tool.get(\"inputSchema\", {})\n            })\n        \n        messages: List[Dict[str, Any]] = [\n            {\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": prompt}]}\n        ]\n        max_iterations = 20\n        \n        try:\n            for iteration in range(max_iterations):\n                response = self.client.messages.create(\n                    model=self.model_name,\n                    max_tokens=4096,\n                    system=system_prompt,\n                    messages=messages,\n                    tools=mcp_tools\n                )\n                \n                messages.append({\n                    \"role\": \"assistant\",\n                    \"content\": response.content\n                })\n                \n                if response.stop_reason == \"end_turn\":\n                    logger.info(\"‚úì Task execution completed\")\n                    break\n                \n                if response.stop_reason == \"tool_use\":\n                    tool_results = []\n                    \n                    for block in response.content:\n                        if block.type == \"tool_use\":\n                            tool_name = block.name\n                            tool_input = block.input\n                            \n                            self.execution_trace.append({\n                                \"type\": \"tool_call\",\n                                \"tool\": tool_name,\n                                \"arguments\": tool_input\n                            })\n                            \n                            result = await self.mcp_client.call_tool(tool_name, tool_input)\n                            \n                            result_content = []\n                            for content_item in result.content:\n                                if hasattr(content_item, 'text'):\n                                    result_content.append(content_item.text)\n                            \n                            result_text = \"\\n\".join(result_content)\n                            \n                            self.execution_trace.append({\n                                \"type\": \"tool_result\",\n                                \"tool\": tool_name,\n                                \"result\": result_text\n                            })\n                            \n                            tool_results.append({\n                                \"type\": \"tool_result\",\n                                \"tool_use_id\": block.id,\n                                \"content\": [{\"type\": \"text\", \"text\": result_text}]\n                            })\n                    \n                    messages.append({\n                        \"role\": \"user\",\n                        \"content\": tool_results\n                    })\n            \n            return {\n                \"success\": True,\n                \"trace\": self.execution_trace,\n                \"model\": self.model_name\n            }\n        except Exception as e:\n            logger.error(f\"Error during task execution: {e}\")\n            return {\n                \"success\": False,\n                \"trace\": self.execution_trace,\n                \"model\": self.model_name,\n                \"error\": str(e)\n            }\n    \n    async def _execute_with_openai(self, prompt: str, system_prompt: str) -> Dict[str, Any]:\n        \"\"\"Execute task using OpenAI\"\"\"\n        tools = []\n        for tool in self.mcp_client.tools:\n            tools.append({\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool.get(\"description\", \"\"),\n                    \"parameters\": tool.get(\"inputSchema\", {})\n                }\n            })\n        \n        messages: List[Dict[str, Any]] = [\n            {\"role\": \"system\", \"content\": system_prompt},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        max_iterations = 20\n        \n        try:\n            for iteration in range(max_iterations):\n                response = self.client.chat.completions.create(\n                    model=self.model_name,\n                    messages=messages,\n                    tools=tools\n                )\n                \n                message = response.choices[0].message\n                messages.append({\n                    \"role\": \"assistant\",\n                    \"content\": message.content or \"\",\n                    \"tool_calls\": message.tool_calls\n                })\n                \n                if not message.tool_calls:\n                    logger.info(\"‚úì Task execution completed\")\n                    break\n                \n                for tool_call in message.tool_calls:\n                    tool_name = tool_call.function.name\n                    tool_args = json.loads(tool_call.function.arguments)\n                    \n                    self.execution_trace.append({\n                        \"type\": \"tool_call\",\n                        \"tool\": tool_name,\n                        \"arguments\": tool_args\n                    })\n                    \n                    result = await self.mcp_client.call_tool(tool_name, tool_args)\n                    \n                    result_content = []\n                    for content_item in result.content:\n                        if hasattr(content_item, 'text'):\n                            result_content.append(content_item.text)\n                    \n                    result_text = \"\\n\".join(result_content)\n                    \n                    self.execution_trace.append({\n                        \"type\": \"tool_result\",\n                        \"tool\": tool_name,\n                        \"result\": result_text\n                    })\n                    \n                    messages.append({\n                        \"role\": \"tool\",\n                        \"tool_call_id\": tool_call.id,\n                        \"content\": result_text\n                    })\n            \n            return {\n                \"success\": True,\n                \"trace\": self.execution_trace,\n                \"model\": self.model_name\n            }\n        except Exception as e:\n            logger.error(f\"Error during task execution: {e}\")\n            return {\n                \"success\": False,\n                \"trace\": self.execution_trace,\n                \"model\": self.model_name,\n                \"error\": str(e)\n            }\n","size_bytes":9965},"app/static/js/navigation.js":{"content":"// Theme handling\nfunction initializeTheme() {\n    const savedTheme = localStorage.getItem('theme') || 'dark';\n    document.documentElement.setAttribute('data-theme', savedTheme);\n    updateThemeButton(savedTheme);\n}\n\nfunction updateThemeButton(theme) {\n    const themeToggle = document.getElementById('theme-toggle');\n    const themeIcon = document.getElementById('theme-icon');\n    const themeText = document.getElementById('theme-text');\n    \n    if (themeToggle && themeIcon && themeText) {\n        if (theme === 'light') {\n            themeIcon.setAttribute('data-feather', 'moon');\n            themeText.textContent = 'Dark';\n        } else {\n            themeIcon.setAttribute('data-feather', 'sun');\n            themeText.textContent = 'Light';\n        }\n        // Re-render feather icons\n        if (typeof feather !== 'undefined') {\n            feather.replace();\n        }\n    }\n}\n\nfunction toggleTheme() {\n    const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';\n    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';\n    \n    document.documentElement.setAttribute('data-theme', newTheme);\n    localStorage.setItem('theme', newTheme);\n    updateThemeButton(newTheme);\n}\n\n// Initialize theme immediately\ninitializeTheme();\n\n// Navigation and theme handling\ndocument.addEventListener('DOMContentLoaded', () => {\n    updateActiveNav();\n    initializeTheme();\n    \n    // Add theme toggle listener\n    const themeToggle = document.getElementById('theme-toggle');\n    if (themeToggle) {\n        themeToggle.addEventListener('click', toggleTheme);\n    }\n});\n\nfunction updateActiveNav() {\n    const currentPath = window.location.pathname;\n    const navItems = document.querySelectorAll('.nav-item');\n    \n    navItems.forEach(item => {\n        const href = item.getAttribute('href');\n        item.classList.remove('active');\n        if (href === currentPath || (currentPath === '/' && href === '/')) {\n            item.classList.add('active');\n        }\n    });\n}\n","size_bytes":2011},"auth/oauth_handler.py":{"content":"\"\"\"\nOAuth 2.0 Token Handler for Gateway Authentication\nHandles OAuth token fetching, caching, and certificate management\n\"\"\"\nimport os\nimport sys\nimport logging\nimport requests\nfrom typing import Dict, Optional, Any\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timedelta\nimport threading\n\ntry:\n    from dotenv import load_dotenv  # type: ignore\n    load_dotenv(override=True)  # type: ignore\nexcept ImportError:\n    pass\n\nlogging.basicConfig(level=logging.INFO)\n\n\ndef enable_certs():\n    \"\"\"\n    Enable certificate handling for secure gateway connections\n    Sets SSL certificate verification and paths\n    \"\"\"\n    cert_path = os.environ.get(\"SSL_CERT_FILE\") or os.environ.get(\"REQUESTS_CA_BUNDLE\")\n    if cert_path and os.path.exists(cert_path):\n        os.environ[\"REQUESTS_CA_BUNDLE\"] = cert_path\n        os.environ[\"SSL_CERT_FILE\"] = cert_path\n        logging.info(f\"SSL certificates enabled from: {cert_path}\")\n    else:\n        logging.debug(\"No custom SSL certificate path configured\")\n\n\n@dataclass\nclass OAuthConfig:\n    \"\"\"\n    OAuth configuration for keeping track of OAuth token config\n    \"\"\"\n    token_url: str = field(default=\"\")\n    client_id: str = field(default=\"\")\n    client_secret: str = field(default=\"\")\n    grant_type: str = field(default=\"\")\n    scope: str = field(default=\"\")\n    \n    def __post_init__(self):\n        \"\"\"Validate required fields\"\"\"\n        if not self.token_url:\n            raise ValueError(\"OAUTH_TOKEN_URL is required\")\n        if not self.client_id:\n            raise ValueError(\"OAUTH_CLIENT_ID is required\")\n        if not self.client_secret:\n            raise ValueError(\"OAUTH_CLIENT_SECRET is required\")\n\n\nclass OAuthTokenFetcher:\n    \"\"\"\n    Class for fetching and caching OAuth tokens\n    Handles refetching before token expiry\n    \"\"\"\n    OAUTH_HEADERS = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n    \n    def __init__(self, oauth_config: OAuthConfig):\n        \"\"\"\n        Initialize OAuth token fetcher\n        \n        Args:\n            oauth_config: OAuth configuration object\n        \"\"\"\n        self._oauth_config = oauth_config\n        self._token: Optional[Dict] = None\n        self._refresh_after: Optional[datetime] = None\n        self.early_refresh_seconds: int = int(os.environ.get(\"OAUTH_EARLY_REFRESH_SECONDS\", \"300\"))\n        \n    def _fetch_token(self) -> Dict:\n        \"\"\"\n        Fetch a new OAuth token from the token endpoint\n        \n        Returns:\n            Token response dictionary\n            \n        Raises:\n            requests.RequestException: If token fetch fails\n        \"\"\"\n        oauth_config = self._oauth_config\n        oauth_payload = {\n            \"client_id\": oauth_config.client_id,\n            \"client_secret\": oauth_config.client_secret,\n            \"grant_type\": oauth_config.grant_type,\n            \"scope\": oauth_config.scope\n        }\n        \n        response = requests.post(\n            oauth_config.token_url,\n            data=oauth_payload,\n            headers=self.OAUTH_HEADERS\n        )\n        response.raise_for_status()\n        return response.json()\n    \n    def get_token(self) -> Dict:\n        \"\"\"\n        Get OAuth token, fetching if needed or cache is expired\n        \n        Returns:\n            Token dictionary with 'access_token' and 'expires_in' keys\n        \"\"\"\n        datetime_now = datetime.now().timestamp()\n        \n        if (\n            self._token is None or \n            self._refresh_after is None or \n            datetime_now > self._refresh_after.timestamp()\n        ):\n            self._token = self._fetch_token()\n            \n            expires_in = int(self._token.get(\"expires_in\", 3600))\n            self._refresh_after = datetime.now() + timedelta(\n                seconds=(expires_in - self.early_refresh_seconds)\n            )\n            \n            logging.info(f\"OAuth token refreshed. Expires in {expires_in}s, will refresh after {self.early_refresh_seconds}s\")\n        \n        return self._token\n\n\nclass OAuthTokenManager:\n    \"\"\"\n    Singleton manager for OAuth tokens\n    Ensures token fetcher persists across requests for proper caching\n    \"\"\"\n    _instance: Optional['OAuthTokenManager'] = None\n    _lock: Optional[threading.Lock] = threading.Lock()\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n    \n    def __init__(self):\n        \"\"\"Initialize the token manager (only once)\"\"\"\n        if self._initialized:\n            return\n        \n        self._token_fetcher: Optional[OAuthTokenFetcher] = None\n        self._initialized = True\n        \n    def _initialize_fetcher(self):\n        \"\"\"Initialize the OAuth token fetcher with configuration from environment\"\"\"\n        enable_certs()\n        \n        required_env_vars = {\n            \"OAUTH_TOKEN_URL\": os.environ.get(\"OAUTH_TOKEN_URL\"),\n            \"OAUTH_CLIENT_ID\": os.environ.get(\"OAUTH_CLIENT_ID\"),\n            \"OAUTH_CLIENT_SECRET\": os.environ.get(\"OAUTH_CLIENT_SECRET\"),\n            \"OAUTH_GRANT_TYPE\": os.environ.get(\"OAUTH_GRANT_TYPE\"),\n            \"OAUTH_SCOPE\": os.environ.get(\"OAUTH_SCOPE\")\n        }\n        \n        missing_vars = [var for var, val in required_env_vars.items() if not val]\n        if missing_vars:\n            logging.error(f\"Missing required environment variables: {', '.join(missing_vars)}\")\n            raise EnvironmentError(f\"Missing required environment variables: {', '.join(missing_vars)}\")\n        \n        oauth_config = OAuthConfig(\n            token_url=str(required_env_vars[\"OAUTH_TOKEN_URL\"]),\n            client_id=str(required_env_vars[\"OAUTH_CLIENT_ID\"]),\n            client_secret=str(required_env_vars[\"OAUTH_CLIENT_SECRET\"]),\n            grant_type=str(required_env_vars[\"OAUTH_GRANT_TYPE\"]),\n            scope=str(required_env_vars[\"OAUTH_SCOPE\"])\n        )\n        \n        self._token_fetcher = OAuthTokenFetcher(oauth_config)\n        logging.info(\"OAuth token fetcher initialized\")\n    \n    def get_token(self, max_retries: int = 3) -> str:\n        \"\"\"\n        Get OAuth access token with retry logic and caching\n        Thread-safe singleton ensures token cache persists across requests\n        \n        Args:\n            max_retries: Maximum number of retry attempts\n            \n        Returns:\n            OAuth access token string\n            \n        Raises:\n            Exception: If all retry attempts fail\n        \"\"\"\n        if self._lock is not None:\n            with self._lock:\n                if self._token_fetcher is None:\n                    self._initialize_fetcher()\n        else:\n            if self._token_fetcher is None:\n                self._initialize_fetcher()\n        \n        for attempt in range(1, max_retries + 1):\n            try:\n                token = self._token_fetcher.get_token()  # type: ignore\n                return token[\"access_token\"]\n            except Exception as e:\n                if attempt == max_retries:\n                    logging.error(f\"OAuth token fetch failed after {max_retries} attempts: {e}\")\n                    raise\n                logging.warning(f\"OAuth token fetch attempt {attempt} failed: {e}. Retrying...\")\n        \n        raise Exception(\"Failed to fetch OAuth token\")\n\n\ndef get_oauth_token_with_retry(max_retries: int = 3) -> str:\n    \"\"\"\n    Get OAuth access token with retry logic\n    Uses singleton token manager to ensure tokens are cached across requests\n    \n    Args:\n        max_retries: Maximum number of retry attempts\n        \n    Returns:\n        OAuth access token string\n        \n    Raises:\n        Exception: If all retry attempts fail\n    \"\"\"\n    manager = OAuthTokenManager()\n    return manager.get_token(max_retries)\n","size_bytes":7763},"app/utils/timeout.py":{"content":"\"\"\"\nCross-platform timeout utility\nWorks on Windows, Linux, and macOS with proper cancellation\n\"\"\"\nimport threading\nimport logging\nfrom typing import Callable, Any, Optional\nfrom concurrent.futures import ThreadPoolExecutor, TimeoutError as FutureTimeoutError\n\nlogger = logging.getLogger(__name__)\n\n\nclass TimeoutError(Exception):\n    \"\"\"Raised when operation times out\"\"\"\n    pass\n\n\ndef run_with_timeout(func: Callable, timeout_seconds: int, *args, **kwargs) -> Any:\n    \"\"\"\n    Run a function with a timeout (cross-platform)\n    \n    Note: This implementation returns promptly on timeout but cannot\n    forcefully terminate the underlying function if it's stuck. The\n    worker thread continues in the background but HTTP request returns.\n    \n    Args:\n        func: Function to execute\n        timeout_seconds: Timeout in seconds\n        *args: Positional arguments to pass to func\n        **kwargs: Keyword arguments to pass to func\n        \n    Returns:\n        Result from func\n        \n    Raises:\n        TimeoutError: If function execution exceeds timeout\n    \"\"\"\n    executor = ThreadPoolExecutor(max_workers=1)\n    future = executor.submit(func, *args, **kwargs)\n    \n    try:\n        result = future.result(timeout=timeout_seconds)\n        executor.shutdown(wait=False)\n        return result\n    except FutureTimeoutError:\n        logger.warning(f\"‚è±Ô∏è Operation timed out after {timeout_seconds} seconds\")\n        future.cancel()\n        executor.shutdown(wait=False)\n        raise TimeoutError(f\"Operation timed out after {timeout_seconds} seconds\")\n    except Exception as e:\n        logger.error(f\"‚ùå Error during timed execution: {str(e)}\")\n        executor.shutdown(wait=False)\n        raise\n","size_bytes":1714},"app/utils/__init__.py":{"content":"\"\"\"Utilities package\"\"\"\n","size_bytes":24},"app/services/__init__.py":{"content":"\"\"\"\nFlask Services Module\n\"\"\"\nfrom app.services.engine_orchestrator import EngineOrchestrator\n\n__all__ = ['EngineOrchestrator']\n","size_bytes":128},"app/static/js/dashboard.js":{"content":"// Load settings from localStorage\nlet currentMode = localStorage.getItem('browserMode') || 'headful';\nlet currentEngine = localStorage.getItem('automationEngine') || 'browser_use';\nlet isExecuting = false;\n\n// Function to toggle script panels visibility based on engine\nfunction toggleScriptPanels(engineType) {\n    const scriptPanelsContainer = document.getElementById('script-panels-container');\n    const browserUsePanelsContainer = document.getElementById('browser-use-panels-container');\n    const screenshotPanelSingle = document.getElementById('screenshot-panel-single');\n    \n    if (scriptPanelsContainer && browserUsePanelsContainer && screenshotPanelSingle) {\n        if (engineType === 'browser_use') {\n            scriptPanelsContainer.style.display = 'none';\n            browserUsePanelsContainer.style.display = 'grid';\n            screenshotPanelSingle.style.display = 'none';\n        } else {\n            scriptPanelsContainer.style.display = 'grid';\n            browserUsePanelsContainer.style.display = 'none';\n            screenshotPanelSingle.style.display = 'block';\n        }\n    }\n}\n\n// Helper function to get the active execution logs element\nfunction getActiveExecutionLogsElement() {\n    if (currentEngine === 'browser_use') {\n        return document.getElementById('execution-logs-single');\n    } else {\n        return document.getElementById('execution-logs-grid');\n    }\n}\n\n// Helper function to update execution logs in the active panel\nfunction updateExecutionLogs(htmlContent) {\n    const logsElement = getActiveExecutionLogsElement();\n    if (logsElement) {\n        logsElement.innerHTML = htmlContent;\n    }\n}\n\n// Helper function to get the active screenshot panel element\nfunction getActiveScreenshotPanelElement() {\n    if (currentEngine === 'browser_use') {\n        return document.getElementById('screenshot-panel-grid-content');\n    } else {\n        return document.getElementById('screenshot-panel-single-content');\n    }\n}\n\n// Function to show/hide healed script panel\nfunction toggleHealedScriptPanel(show) {\n    const healedContainer = document.getElementById('healed-script-container');\n    if (healedContainer) {\n        healedContainer.style.display = show ? 'block' : 'none';\n    }\n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    const executeBtn = document.getElementById('execute-automation');\n    const promptTextarea = document.getElementById('automation-prompt');\n    \n    // Initialize visibility on page load based on saved settings\n    toggleScriptPanels(currentEngine);\n    \n    if (executeBtn) {\n        executeBtn.addEventListener('click', async () => {\n            if (isExecuting) return;\n            \n            const instruction = promptTextarea.value.trim();\n            if (!instruction) {\n                alert('Please enter an automation instruction');\n                return;\n            }\n            \n            isExecuting = true;\n            executeBtn.disabled = true;\n            executeBtn.innerHTML = '<span class=\"spinner\"></span> Executing...';\n            \n            document.getElementById('generated-script').innerHTML = '<div style=\"color: var(--text-secondary);\">Waiting for automation to start...</div>';\n            getActiveExecutionLogsElement().innerHTML = '<div style=\"color: var(--text-secondary);\">Connecting to automation server...</div>';\n            \n            // Hide healed script panel at start (only show if healing occurs)\n            toggleHealedScriptPanel(false);\n            \n            // Hide copy button at start of execution\n            const copyBtn = document.getElementById('copy-playwright-code');\n            if (copyBtn) {\n                copyBtn.style.display = 'none';\n                copyBtn.onclick = null;\n            }\n            \n            let stepLogs = [];\n            \n            try {\n                const apiKey = localStorage.getItem('api_key');\n                \n                // Use Server-Sent Events for real-time streaming\n                const payload = {\n                    instruction: instruction,\n                    engine: currentEngine,\n                    headless: currentMode === 'headless'\n                };\n                \n                // Create SSE connection\n                const url = '/api/execute/stream';\n                const response = await fetch(url, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        ...(apiKey ? {'X-API-Key': apiKey} : {})\n                    },\n                    body: JSON.stringify(payload)\n                });\n                \n                // Handle non-OK HTTP responses before entering streaming loop\n                if (!response.ok) {\n                    let errorData;\n                    try {\n                        errorData = await response.json();\n                    } catch (e) {\n                        errorData = {error: 'Unknown error', message: 'Failed to get error details'};\n                    }\n                    \n                    // Reset script panel and hide copy button on error\n                    document.getElementById('generated-script').innerHTML = \n                        `<div class=\"empty-state\"><div>No script generated</div></div>`;\n                    const copyBtn = document.getElementById('copy-playwright-code');\n                    if (copyBtn) {\n                        copyBtn.style.display = 'none';\n                        copyBtn.onclick = null;\n                    }\n                    \n                    let errorMessage = '';\n                    if (response.status === 401 || response.status === 403) {\n                        errorMessage = 'üîí Authentication Error<br>Please provide a valid API key.';\n                    } else if (response.status === 429) {\n                        errorMessage = '‚è±Ô∏è Rate Limit Exceeded<br>' + (errorData.message || 'Too many requests. Please try again later.');\n                    } else {\n                        errorMessage = `‚ùå ${errorData.error || 'Error'}<br>${errorData.message || 'An unexpected error occurred'}`;\n                    }\n                    \n                    getActiveExecutionLogsElement().innerHTML = \n                        `<div style=\"color: var(--error-text);\">${errorMessage}</div>`;\n                    return;\n                }\n                \n                const reader = response.body.getReader();\n                const decoder = new TextDecoder();\n                let buffer = '';\n                \n                while (true) {\n                    const {done, value} = await reader.read();\n                    if (done) break;\n                    \n                    buffer += decoder.decode(value, {stream: true});\n                    const lines = buffer.split('\\n\\n');\n                    buffer = lines.pop() || '';\n                    \n                    for (const line of lines) {\n                        if (!line.trim() || !line.startsWith('data: ')) continue;\n                        \n                        try {\n                            const data = JSON.parse(line.substring(6));\n                            \n                            // Handle different event types from SSE stream\n                            if (data.type === 'start') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">üöÄ ${data.message || 'Starting...'}</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                                \n                                // Clear screenshot panel for new execution\n                                getActiveScreenshotPanelElement().innerHTML = '<div class=\"empty-state\"><div>Screenshots will appear here during execution</div></div>';\n                            } else if (data.type === 'init') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">‚öôÔ∏è  Initializing automation...</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'browser_init') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">üåê Browser ready</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'agent_create') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">ü§ñ AI agent ready</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'execution_start') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">‚ñ∂Ô∏è  Executing steps...</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'planner_init') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">üé≠ Planning automation...</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'generator_init') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">üé® Preparing code generation...</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'generator_building') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">üîß Generating Python script...</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'generator_complete') {\n                                stepLogs.push(`<div style=\"color: var(--success-text); margin: 3px 0;\">‚úì Script generated (${data.data.lines} lines)</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'healer_init') {\n                                stepLogs.push(`<div style=\"color: var(--warning-text); margin: 3px 0;\">üîß Healing script...</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'healer_complete') {\n                                stepLogs.push(`<div style=\"color: var(--success-text); margin: 3px 0;\">‚úì Script healed (${data.data.fixes} fixes applied)</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'step') {\n                                stepLogs.push(`<div style=\"color: var(--success-text); margin: 3px 0;\">‚úì ${data.data.action}</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                                // Auto-scroll to bottom\n                                const logsElement = getActiveExecutionLogsElement();\n                                logsElement.scrollTop = logsElement.scrollHeight;\n                            } else if (data.type === 'screenshot') {\n                                // Display screenshot in real-time - ACCUMULATE multiple screenshots\n                                const screenshotPanel = getActiveScreenshotPanelElement();\n                                const screenshotPath = data.data.path;\n                                const screenshotUrl = data.data.url || '';\n                                const stepNumber = data.data.step_number || 'N/A';\n                                \n                                // Convert local file path to URL (assuming static serving)\n                                const publicPath = screenshotPath.replace(/\\\\/g, '/');\n                                \n                                // Clear the empty state if it's the first screenshot\n                                if (screenshotPanel.querySelector('.empty-state')) {\n                                    screenshotPanel.innerHTML = '';\n                                }\n                                \n                                // Add screenshot to the panel (accumulate, don't replace)\n                                const screenshotDiv = document.createElement('div');\n                                screenshotDiv.style.cssText = 'margin-bottom: 15px; padding: 10px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel-bg);';\n                                screenshotDiv.innerHTML = `\n                                    <div style=\"text-align: center;\">\n                                        <div style=\"margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem; font-weight: 600;\">Step ${stepNumber}</div>\n                                        <img src=\"/${publicPath}\" alt=\"Step ${stepNumber} Screenshot\" \n                                             style=\"max-width: 100%; height: auto; border-radius: 4px; cursor: pointer; border: 1px solid var(--border);\" \n                                             onclick=\"window.open('/${publicPath}', '_blank')\"\n                                             onerror=\"this.parentElement.innerHTML='<div style=\\\\'color: var(--error-text); padding: 20px;\\\\'>Screenshot capture failed</div>'\">\n                                        ${screenshotUrl ? `<div style=\"margin-top: 8px; color: var(--text-secondary); font-size: 0.85rem;\">üìç ${screenshotUrl}</div>` : ''}\n                                    </div>`;\n                                screenshotPanel.appendChild(screenshotDiv);\n                                \n                                // Auto-scroll to the latest screenshot\n                                screenshotPanel.scrollTop = screenshotPanel.scrollHeight;\n                                \n                                stepLogs.push(`<div style=\"color: var(--success-text); margin: 3px 0;\">üì∏ Screenshot saved</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                                \n                                // Auto-scroll execution logs\n                                const logsElement = getActiveExecutionLogsElement();\n                                logsElement.scrollTop = logsElement.scrollHeight;\n                            } else if (data.type === 'done') {\n                                const result = data.result;\n                                \n                                // Display generated code in the Generated Script panel\n                                const scriptPanel = document.getElementById('generated-script');\n                                const copyBtn = document.getElementById('copy-playwright-code');\n                                \n                                if (result.playwright_code) {\n                                    // Show the code with syntax highlighting\n                                    scriptPanel.innerHTML = \n                                        `<pre style=\"color: var(--success-text); margin: 0; white-space: pre-wrap; font-size: 0.85rem; font-family: 'Monaco', 'Courier New', monospace; line-height: 1.5;\"><code class=\"language-python\">${escapeHtml(result.playwright_code)}</code></pre>`;\n                                    \n                                    // Show copy button\n                                    copyBtn.style.display = 'block';\n                                    copyBtn.onclick = () => copyToClipboard(result.playwright_code);\n                                } else {\n                                    // No code generated - reset to empty state\n                                    scriptPanel.innerHTML = \n                                        `<div class=\"empty-state\">\n                                            <div>No script generated for this automation</div>\n                                        </div>`;\n                                    \n                                    // Hide copy button and clear handler\n                                    copyBtn.style.display = 'none';\n                                    copyBtn.onclick = null;\n                                }\n                                \n                                // Display healed code in the Healed Script panel if available\n                                const healedScriptPanel = document.getElementById('healed-script');\n                                if (result.healed_code) {\n                                    // Show healed script panel since healing occurred\n                                    toggleHealedScriptPanel(true);\n                                    healedScriptPanel.innerHTML = \n                                        `<pre style=\"color: var(--warning-text); margin: 0; white-space: pre-wrap; font-size: 0.85rem; font-family: 'Monaco', 'Courier New', monospace; line-height: 1.5;\"><code class=\"language-python\">${escapeHtml(result.healed_code)}</code></pre>`;\n                                } else {\n                                    // No healed code - keep panel hidden\n                                    toggleHealedScriptPanel(false);\n                                }\n                                \n                                // Add final summary\n                                stepLogs.push(`<div style=\"color: var(--success-text); margin-top: 10px; font-weight: bold;\">‚úÖ Completed (${result.iterations || 0} steps)</div>`);\n                                if (result.final_result) {\n                                    stepLogs.push(`<div style=\"color: var(--success-text); margin-top: 5px;\">${result.final_result}</div>`);\n                                }\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                                \n                                // Auto-scroll to bottom\n                                const logsElement = getActiveExecutionLogsElement();\n                                logsElement.scrollTop = logsElement.scrollHeight;\n                                break;\n                            } else if (data.type === 'error') {\n                                // Reset script panel and hide copy button on error\n                                document.getElementById('generated-script').innerHTML = \n                                    `<div class=\"empty-state\"><div>No script generated due to error</div></div>`;\n                                const copyBtn = document.getElementById('copy-playwright-code');\n                                if (copyBtn) {\n                                    copyBtn.style.display = 'none';\n                                    copyBtn.onclick = null;\n                                }\n                                \n                                // Check if this is a verification failure\n                                const isVerificationError = data.error_type === 'VerificationError' || \n                                                           (data.error && data.error.includes('Verification failed'));\n                                \n                                if (isVerificationError) {\n                                    // Display verification failure with special formatting\n                                    stepLogs.push(`<div style=\"color: var(--error-text); font-weight: bold; margin-top: 10px; padding: 10px; border: 2px solid var(--error-text); border-radius: 4px; background: rgba(220, 38, 38, 0.1);\">‚ö†Ô∏è VERIFICATION FAILED</div>`);\n                                    stepLogs.push(`<div style=\"color: var(--error-text); margin: 5px 0; padding: 8px; background: rgba(220, 38, 38, 0.05); border-radius: 4px;\">${data.error || 'Verification step did not pass'}</div>`);\n                                    stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 5px 0; font-size: 0.9rem;\">The automation detected that a required verification condition was not satisfied. Please review the execution logs above for details.</div>`);\n                                } else {\n                                    // Display regular error\n                                    stepLogs.push(`<div style=\"color: var(--error-text); font-weight: bold; margin-top: 10px;\">‚ùå ${data.error || 'Execution failed'}</div>`);\n                                }\n                                \n                                if (data.message && !isVerificationError) {\n                                    stepLogs.push(`<pre style=\"color: var(--error-text); margin: 5px 0; white-space: pre-wrap; font-size: 0.85rem;\">${data.message}</pre>`);\n                                }\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                                break;\n                            }\n                        } catch (parseError) {\n                            console.error('Failed to parse SSE data:', parseError);\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Execution error:', error);\n                // Reset script panel and hide copy button on network error\n                document.getElementById('generated-script').innerHTML = \n                    `<div class=\"empty-state\"><div>No script generated due to network error</div></div>`;\n                const copyBtn = document.getElementById('copy-playwright-code');\n                if (copyBtn) {\n                    copyBtn.style.display = 'none';\n                    copyBtn.onclick = null;\n                }\n                getActiveExecutionLogsElement().innerHTML = \n                    `<div style=\"color: var(--error-text);\">‚ùå Network Error<br>Failed to execute automation: ${error.message}</div>`;\n            } finally {\n                isExecuting = false;\n                executeBtn.disabled = false;\n                executeBtn.innerHTML = '<span>‚ñ∂Ô∏è</span> Execute Automation';\n            }\n        });\n    }\n});\n\n// Helper function to escape HTML\nfunction escapeHtml(text) {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n}\n\n// Helper function to copy text to clipboard\nasync function copyToClipboard(text) {\n    try {\n        await navigator.clipboard.writeText(text);\n        const copyBtn = document.getElementById('copy-playwright-code');\n        const originalContent = copyBtn.innerHTML;\n        copyBtn.innerHTML = '<i data-feather=\"check\"></i>';\n        feather.replace();\n        setTimeout(() => {\n            copyBtn.innerHTML = originalContent;\n            feather.replace();\n        }, 2000);\n    } catch (err) {\n        console.error('Failed to copy:', err);\n        alert('Failed to copy code to clipboard');\n    }\n}\n","size_bytes":23227},"app/utils/encryption.py":{"content":"\"\"\"\nEncryption utilities for securely storing sensitive credentials\n\"\"\"\nimport os\nimport base64\nfrom cryptography.fernet import Fernet\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.backends import default_backend\n\n\nclass CredentialEncryption:\n    \"\"\"\n    Handles encryption and decryption of stored credentials.\n    Uses Fernet (symmetric encryption) with a key derived from an environment variable.\n    \"\"\"\n    \n    def __init__(self):\n        self._cipher = None\n        \n    def _get_cipher(self):\n        \"\"\"\n        Get or create the Fernet cipher instance.\n        Requires ENCRYPTION_KEY environment variable to be set.\n        \n        The ENCRYPTION_KEY should be a base64-encoded Fernet key.\n        To generate a secure key, run: python -c \"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\"\n        \n        Raises:\n            ValueError: If ENCRYPTION_KEY is not set or invalid\n        \"\"\"\n        if self._cipher is not None:\n            return self._cipher\n            \n        encryption_key = os.environ.get('ENCRYPTION_KEY')\n        \n        if not encryption_key:\n            raise ValueError(\n                \"ENCRYPTION_KEY environment variable is not set. \"\n                \"Credential vault requires a secure encryption key. \"\n                \"Generate one with: python -c \\\"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\\\" \"\n                \"Then set it as an environment variable or Replit Secret.\"\n            )\n        \n        try:\n            # Try to use it directly as a Fernet key\n            self._cipher = Fernet(encryption_key.encode())\n            return self._cipher\n        except Exception as e:\n            raise ValueError(\n                f\"Invalid ENCRYPTION_KEY format: {str(e)}. \"\n                \"The key must be a valid Fernet key (44 characters, base64-encoded). \"\n                \"Generate a new one with: python -c \\\"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\\\"\"\n            )\n    \n    def encrypt(self, plaintext: str) -> str:\n        \"\"\"\n        Encrypt a plaintext string\n        \n        Args:\n            plaintext: The string to encrypt\n            \n        Returns:\n            Base64-encoded encrypted string\n        \"\"\"\n        if not plaintext:\n            return ''\n            \n        cipher = self._get_cipher()\n        encrypted_bytes = cipher.encrypt(plaintext.encode('utf-8'))\n        return base64.urlsafe_b64encode(encrypted_bytes).decode('utf-8')\n    \n    def decrypt(self, encrypted: str) -> str:\n        \"\"\"\n        Decrypt an encrypted string\n        \n        Args:\n            encrypted: Base64-encoded encrypted string\n            \n        Returns:\n            Decrypted plaintext string\n        \"\"\"\n        if not encrypted:\n            return ''\n            \n        try:\n            cipher = self._get_cipher()\n            encrypted_bytes = base64.urlsafe_b64decode(encrypted.encode('utf-8'))\n            decrypted_bytes = cipher.decrypt(encrypted_bytes)\n            return decrypted_bytes.decode('utf-8')\n        except Exception as e:\n            raise ValueError(f\"Decryption failed: {str(e)}\")\n\n\ncredential_encryption = CredentialEncryption()\n","size_bytes":3314},"app/static/js/credentials.js":{"content":"/**\n * Credential Manager\n * Handles secure credential storage and management UI\n */\n\nconst credentialManager = {\n    /**\n     * Initialize the credential manager\n     */\n    init() {\n        this.loadCredentials();\n    },\n\n    /**\n     * Load and display all credentials\n     */\n    async loadCredentials() {\n        try {\n            const response = await fetch('/api/credentials');\n            const data = await response.json();\n\n            if (data.success) {\n                this.renderCredentials(data.credentials);\n            } else {\n                this.showError('Failed to load credentials: ' + data.message);\n            }\n        } catch (error) {\n            console.error('Error loading credentials:', error);\n            this.showError('Failed to load credentials. Please try again.');\n        }\n    },\n\n    /**\n     * Render credentials list\n     */\n    renderCredentials(credentials) {\n        const container = document.getElementById('credentials-list');\n\n        if (credentials.length === 0) {\n            container.innerHTML = `\n                <div class=\"empty-state\">\n                    <i data-feather=\"key\"></i>\n                    <h3 style=\"color: var(--text-primary); margin: 16px 0 8px 0;\">No credentials stored yet</h3>\n                    <p style=\"max-width: 400px; margin: 0 auto;\">\n                        Add your first credential to start using secure placeholders in your automation prompts.\n                    </p>\n                </div>\n            `;\n            feather.replace();\n            return;\n        }\n\n        container.innerHTML = credentials.map(cred => `\n            <div class=\"credential-card\">\n                <div class=\"credential-header\">\n                    <div>\n                        <div class=\"credential-name\">${this.escapeHtml(cred.name)}</div>\n                        <div class=\"credential-placeholder\">{{${this.escapeHtml(cred.name)}}}</div>\n                    </div>\n                    <div class=\"credential-actions\">\n                        <button class=\"btn btn-secondary btn-icon-only\" \n                                onclick=\"credentialManager.deleteCredential(${cred.id}, '${this.escapeHtml(cred.name)}')\"\n                                title=\"Delete credential\">\n                            <i data-feather=\"trash-2\"></i>\n                        </button>\n                    </div>\n                </div>\n                ${cred.service || cred.url || cred.username || cred.description ? `\n                    <div class=\"credential-info\">\n                        ${cred.service ? `\n                            <div class=\"credential-info-item\">\n                                <div class=\"credential-info-label\">Service</div>\n                                <div class=\"credential-info-value\">${this.escapeHtml(cred.service)}</div>\n                            </div>\n                        ` : ''}\n                        ${cred.url ? `\n                            <div class=\"credential-info-item\">\n                                <div class=\"credential-info-label\">URL</div>\n                                <div class=\"credential-info-value\">${this.escapeHtml(cred.url)}</div>\n                            </div>\n                        ` : ''}\n                        ${cred.username ? `\n                            <div class=\"credential-info-item\">\n                                <div class=\"credential-info-label\">Username</div>\n                                <div class=\"credential-info-value\">${this.escapeHtml(cred.username)}</div>\n                            </div>\n                        ` : ''}\n                        ${cred.description ? `\n                            <div class=\"credential-info-item\">\n                                <div class=\"credential-info-label\">Description</div>\n                                <div class=\"credential-info-value\">${this.escapeHtml(cred.description)}</div>\n                            </div>\n                        ` : ''}\n                    </div>\n                ` : ''}\n                <div style=\"margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 0.85rem; color: var(--text-secondary);\">\n                    <i data-feather=\"clock\" style=\"width: 14px; height: 14px;\"></i>\n                    Created: ${new Date(cred.created_at).toLocaleString()}\n                </div>\n            </div>\n        `).join('');\n\n        feather.replace();\n    },\n\n    /**\n     * Show the add credential modal\n     */\n    showAddCredentialModal() {\n        document.getElementById('add-credential-modal').style.display = 'flex';\n        document.getElementById('add-credential-form').reset();\n        document.getElementById('credential-name').focus();\n    },\n\n    /**\n     * Close the add credential modal\n     */\n    closeAddCredentialModal() {\n        document.getElementById('add-credential-modal').style.display = 'none';\n    },\n\n    /**\n     * Add a new credential\n     */\n    async addCredential(event) {\n        event.preventDefault();\n\n        const name = document.getElementById('credential-name').value.trim();\n        const service = document.getElementById('credential-service').value.trim();\n        const url = document.getElementById('credential-url').value.trim();\n        const username = document.getElementById('credential-username').value.trim();\n        const value = document.getElementById('credential-value').value.trim();\n        const description = document.getElementById('credential-description').value.trim();\n\n        if (!name || !url || !username || !value) {\n            this.showError('Name, URL, username, and password are required');\n            return;\n        }\n\n        try {\n            const response = await fetch('/api/credentials', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    name,\n                    service,\n                    url,\n                    username,\n                    value,\n                    description\n                })\n            });\n\n            const data = await response.json();\n\n            if (data.success) {\n                this.showSuccess('Credential added successfully');\n                this.closeAddCredentialModal();\n                this.loadCredentials();\n            } else {\n                this.showError(data.message || 'Failed to add credential');\n            }\n        } catch (error) {\n            console.error('Error adding credential:', error);\n            this.showError('Failed to add credential. Please try again.');\n        }\n    },\n\n    /**\n     * Delete a credential\n     */\n    async deleteCredential(id, name) {\n        if (!confirm(`Are you sure you want to delete the credential \"${name}\"?\\n\\nThis action cannot be undone.`)) {\n            return;\n        }\n\n        try {\n            const response = await fetch(`/api/credentials/${id}`, {\n                method: 'DELETE'\n            });\n\n            const data = await response.json();\n\n            if (data.success) {\n                this.showSuccess('Credential deleted successfully');\n                this.loadCredentials();\n            } else {\n                this.showError(data.message || 'Failed to delete credential');\n            }\n        } catch (error) {\n            console.error('Error deleting credential:', error);\n            this.showError('Failed to delete credential. Please try again.');\n        }\n    },\n\n    /**\n     * Show error message\n     */\n    showError(message) {\n        alert('Error: ' + message);\n    },\n\n    /**\n     * Show success message\n     */\n    showSuccess(message) {\n        // Simple alert for now - can be enhanced with a toast notification\n        alert(message);\n    },\n\n    /**\n     * Escape HTML to prevent XSS\n     */\n    escapeHtml(text) {\n        if (!text) return '';\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n};\n\n// Initialize when DOM is ready\ndocument.addEventListener('DOMContentLoaded', function() {\n    credentialManager.init();\n\n    // Close modal when clicking outside\n    document.getElementById('add-credential-modal')?.addEventListener('click', function(e) {\n        if (e.target === this) {\n            credentialManager.closeAddCredentialModal();\n        }\n    });\n\n    // Handle escape key to close modal\n    document.addEventListener('keydown', function(e) {\n        if (e.key === 'Escape') {\n            credentialManager.closeAddCredentialModal();\n        }\n    });\n});\n","size_bytes":8611},"app/services/intelligent_validator.py":{"content":"\"\"\"\nIntelligent Validation Service\nPerforms web scraping and validation to ensure accurate element locators and actions\n\"\"\"\nimport logging\nimport asyncio\nfrom typing import Dict, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom playwright.async_api import async_playwright, Page, ElementHandle\nimport re\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass ElementValidation:\n    \"\"\"Result of element validation\"\"\"\n    exists: bool\n    locator: str\n    locator_strategy: str\n    confidence: float\n    element_info: Dict[str, Any]\n    alternatives: List[Dict[str, Any]] = field(default_factory=list)\n    warnings: List[str] = field(default_factory=list)\n    \n\n@dataclass\nclass PageValidation:\n    \"\"\"Result of page validation\"\"\"\n    url: str\n    title: str\n    is_accessible: bool\n    elements_found: List[ElementValidation]\n    page_structure: Dict[str, Any]\n    validation_time: float\n    \n\nclass IntelligentValidator:\n    \"\"\"\n    Validates web pages and elements through intelligent scraping\n    \n    Features:\n    - Scrapes pages to validate element existence\n    - Detects accurate locators with confidence scoring\n    - Provides alternative locators for robustness\n    - Analyzes page structure for better automation\n    - Suggests improvements for element targeting\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the validator\"\"\"\n        self.browser = None\n        self.context = None\n        self.page = None\n        \n    async def validate_task(\n        self,\n        url: str,\n        steps: List[Dict[str, Any]],\n        headless: bool = True\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Validate a complete automation task by scraping and verifying elements\n        \n        Args:\n            url: Target URL to validate\n            steps: List of steps with actions and targets\n            headless: Run browser in headless mode\n            \n        Returns:\n            Validation result with detailed element information\n        \"\"\"\n        logger.info(f\"üîç Starting intelligent validation for {url}\")\n        \n        try:\n            # Initialize browser\n            await self._init_browser(headless)\n            \n            # Navigate and validate page\n            page_validation = await self._validate_page(url)\n            \n            if not page_validation.is_accessible:\n                return {\n                    'success': False,\n                    'error': f'Page {url} is not accessible',\n                    'page_validation': page_validation\n                }\n            \n            # Validate each step's elements\n            validated_steps = []\n            for step in steps:\n                validated_step = await self._validate_step(step, self.page)\n                validated_steps.append(validated_step)\n            \n            logger.info(f\"‚úÖ Validation complete: {len(validated_steps)} steps validated\")\n            \n            return {\n                'success': True,\n                'url': url,\n                'page_validation': page_validation,\n                'validated_steps': validated_steps,\n                'total_elements': len([s for s in validated_steps if s.get('element_valid')])\n            }\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Validation failed: {e}\", exc_info=True)\n            return {\n                'success': False,\n                'error': str(e)\n            }\n        finally:\n            await self._cleanup()\n    \n    async def _init_browser(self, headless: bool = True):\n        \"\"\"Initialize browser for validation\"\"\"\n        playwright = await async_playwright().start()\n        self.browser = await playwright.chromium.launch(headless=headless)\n        self.context = await self.browser.new_context(\n            viewport={'width': 1280, 'height': 720},\n            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n        )\n        self.page = await self.context.new_page()\n        \n    async def _cleanup(self):\n        \"\"\"Cleanup browser resources\"\"\"\n        if self.page:\n            await self.page.close()\n        if self.context:\n            await self.context.close()\n        if self.browser:\n            await self.browser.close()\n    \n    async def _validate_page(self, url: str) -> PageValidation:\n        \"\"\"Validate page accessibility and structure\"\"\"\n        import time\n        start_time = time.time()\n        \n        try:\n            # Navigate to page\n            response = await self.page.goto(url, wait_until='networkidle', timeout=30000)\n            \n            # Get page info\n            title = await self.page.title()\n            \n            # Analyze page structure\n            structure = await self._analyze_page_structure()\n            \n            elapsed = time.time() - start_time\n            \n            return PageValidation(\n                url=url,\n                title=title,\n                is_accessible=response.ok if response else False,\n                elements_found=[],\n                page_structure=structure,\n                validation_time=elapsed\n            )\n            \n        except Exception as e:\n            logger.error(f\"Page validation failed: {e}\")\n            return PageValidation(\n                url=url,\n                title='',\n                is_accessible=False,\n                elements_found=[],\n                page_structure={},\n                validation_time=time.time() - start_time\n            )\n    \n    async def _analyze_page_structure(self) -> Dict[str, Any]:\n        \"\"\"Analyze page structure for better automation\"\"\"\n        try:\n            # Count interactive elements\n            buttons = await self.page.locator('button').count()\n            links = await self.page.locator('a').count()\n            inputs = await self.page.locator('input').count()\n            selects = await self.page.locator('select').count()\n            \n            # Get forms\n            forms = await self.page.locator('form').count()\n            \n            # Check for common frameworks\n            frameworks = await self._detect_frameworks()\n            \n            return {\n                'interactive_elements': {\n                    'buttons': buttons,\n                    'links': links,\n                    'inputs': inputs,\n                    'selects': selects,\n                    'forms': forms\n                },\n                'frameworks': frameworks,\n                'has_spa': await self._detect_spa()\n            }\n            \n        except Exception as e:\n            logger.warning(f\"Page structure analysis failed: {e}\")\n            return {}\n    \n    async def _detect_frameworks(self) -> List[str]:\n        \"\"\"Detect frontend frameworks\"\"\"\n        frameworks = []\n        \n        try:\n            # Check for React\n            react_check = await self.page.evaluate(\n                \"() => !!window.React || !!document.querySelector('[data-reactroot]')\"\n            )\n            if react_check:\n                frameworks.append('React')\n            \n            # Check for Vue\n            vue_check = await self.page.evaluate(\n                \"() => !!window.Vue || !!document.querySelector('[data-v-]')\"\n            )\n            if vue_check:\n                frameworks.append('Vue')\n            \n            # Check for Angular\n            angular_check = await self.page.evaluate(\n                \"() => !!window.angular || !!document.querySelector('[ng-app], [ng-version]')\"\n            )\n            if angular_check:\n                frameworks.append('Angular')\n                \n        except Exception as e:\n            logger.debug(f\"Framework detection error: {e}\")\n        \n        return frameworks\n    \n    async def _detect_spa(self) -> bool:\n        \"\"\"Detect if page is a Single Page Application\"\"\"\n        try:\n            # Check for common SPA indicators\n            has_client_routing = await self.page.evaluate(\n                \"() => !!window.history.pushState && window.location.hash.length > 1\"\n            )\n            return has_client_routing\n        except:\n            return False\n    \n    async def _validate_step(\n        self,\n        step: Dict[str, Any],\n        page: Page\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Validate a single step by finding and verifying the target element\n        \n        Args:\n            step: Step dict with action, target, value, etc.\n            page: Playwright page object\n            \n        Returns:\n            Validated step with element information\n        \"\"\"\n        action = step.get('action', '').lower()\n        target = step.get('target', '')\n        \n        # Skip validation for navigation and wait actions\n        if action in ['navigate', 'wait', 'screenshot']:\n            return {\n                **step,\n                'element_valid': True,\n                'validation': ElementValidation(\n                    exists=True,\n                    locator='N/A',\n                    locator_strategy='N/A',\n                    confidence=1.0,\n                    element_info={}\n                )\n            }\n        \n        # Find and validate element\n        validation = await self._find_and_validate_element(page, target, action)\n        \n        return {\n            **step,\n            'element_valid': validation.exists,\n            'validation': validation,\n            'suggested_locator': validation.locator if validation.exists else None\n        }\n    \n    async def _find_and_validate_element(\n        self,\n        page: Page,\n        target: str,\n        action: str\n    ) -> ElementValidation:\n        \"\"\"\n        Find an element using multiple strategies and validate it\n        \n        Args:\n            page: Playwright page\n            target: Element description\n            action: Action type (click, fill, etc.)\n            \n        Returns:\n            ElementValidation result\n        \"\"\"\n        # Try multiple locator strategies in order of preference\n        strategies = [\n            ('role', self._try_role_locator),\n            ('text', self._try_text_locator),\n            ('label', self._try_label_locator),\n            ('placeholder', self._try_placeholder_locator),\n            ('css', self._try_css_locator)\n        ]\n        \n        alternatives = []\n        \n        for strategy_name, strategy_func in strategies:\n            try:\n                element, locator = await strategy_func(page, target, action)\n                \n                if element:\n                    # Get element information\n                    element_info = await self._extract_element_info(element)\n                    \n                    # Calculate confidence\n                    confidence = self._calculate_strategy_confidence(\n                        strategy_name, element_info, target\n                    )\n                    \n                    # This is our primary match\n                    if confidence > 0.7:\n                        return ElementValidation(\n                            exists=True,\n                            locator=locator,\n                            locator_strategy=strategy_name,\n                            confidence=confidence,\n                            element_info=element_info,\n                            alternatives=alternatives\n                        )\n                    else:\n                        # Add as alternative\n                        alternatives.append({\n                            'locator': locator,\n                            'strategy': strategy_name,\n                            'confidence': confidence\n                        })\n                        \n            except Exception as e:\n                logger.debug(f\"Strategy {strategy_name} failed: {e}\")\n                continue\n        \n        # No good match found\n        return ElementValidation(\n            exists=False,\n            locator='',\n            locator_strategy='none',\n            confidence=0.0,\n            element_info={},\n            alternatives=alternatives,\n            warnings=[f'Could not find element: {target}']\n        )\n    \n    async def _try_role_locator(\n        self,\n        page: Page,\n        target: str,\n        action: str\n    ) -> Tuple[Optional[ElementHandle], str]:\n        \"\"\"Try to find element using role-based locator with smart matching\"\"\"\n        role = self._infer_role(target, action)\n        name = self._extract_name_from_target(target)\n        \n        if name:\n            try:\n                locator = page.get_by_role(role, name=name, exact=True)\n                locator_str = f'page.get_by_role(\"{role}\", name=\"{name}\", exact=True)'\n                await locator.wait_for(state='attached', timeout=2000)\n                element = await locator.element_handle(timeout=1000)\n                return element, locator_str\n            except:\n                try:\n                    locator = page.get_by_role(role, name=name, exact=False)\n                    locator_str = f'page.get_by_role(\"{role}\", name=\"{name}\", exact=False)'\n                    await locator.wait_for(state='attached', timeout=2000)\n                    element = await locator.element_handle(timeout=1000)\n                    count = await locator.count()\n                    if count == 1:\n                        return element, locator_str\n                    else:\n                        return None, locator_str\n                except:\n                    return None, ''\n        \n        return None, ''\n    \n    async def _try_text_locator(\n        self,\n        page: Page,\n        target: str,\n        action: str\n    ) -> Tuple[Optional[ElementHandle], str]:\n        \"\"\"Try to find element using text content\"\"\"\n        text = self._extract_name_from_target(target)\n        \n        if not text:\n            return None, ''\n        \n        locator = page.get_by_text(text, exact=False).first\n        locator_str = f'page.get_by_text(\"{text}\", exact=False).first'\n        \n        try:\n            await locator.wait_for(state='attached', timeout=2000)\n            element = await locator.element_handle(timeout=1000)\n            return element, locator_str\n        except:\n            return None, locator_str\n    \n    async def _try_label_locator(\n        self,\n        page: Page,\n        target: str,\n        action: str\n    ) -> Tuple[Optional[ElementHandle], str]:\n        \"\"\"Try to find element using label with exact matching first\"\"\"\n        label = self._extract_name_from_target(target)\n        \n        if not label or action not in ['fill', 'select']:\n            return None, ''\n        \n        try:\n            locator = page.get_by_label(label, exact=True)\n            locator_str = f'page.get_by_label(\"{label}\", exact=True)'\n            await locator.wait_for(state='attached', timeout=2000)\n            element = await locator.element_handle(timeout=1000)\n            return element, locator_str\n        except:\n            try:\n                locator = page.get_by_label(label, exact=False)\n                locator_str = f'page.get_by_label(\"{label}\", exact=False)'\n                await locator.wait_for(state='attached', timeout=2000)\n                count = await locator.count()\n                if count == 1:\n                    element = await locator.element_handle(timeout=1000)\n                    return element, locator_str\n                else:\n                    return None, ''\n            except:\n                return None, ''\n    \n    async def _try_placeholder_locator(\n        self,\n        page: Page,\n        target: str,\n        action: str\n    ) -> Tuple[Optional[ElementHandle], str]:\n        \"\"\"Try to find element using placeholder with exact matching first\"\"\"\n        placeholder = self._extract_name_from_target(target)\n        \n        if not placeholder or action != 'fill':\n            return None, ''\n        \n        try:\n            locator = page.get_by_placeholder(placeholder, exact=True)\n            locator_str = f'page.get_by_placeholder(\"{placeholder}\", exact=True)'\n            await locator.wait_for(state='attached', timeout=2000)\n            element = await locator.element_handle(timeout=1000)\n            return element, locator_str\n        except:\n            try:\n                locator = page.get_by_placeholder(placeholder, exact=False)\n                locator_str = f'page.get_by_placeholder(\"{placeholder}\", exact=False)'\n                await locator.wait_for(state='attached', timeout=2000)\n                count = await locator.count()\n                if count == 1:\n                    element = await locator.element_handle(timeout=1000)\n                    return element, locator_str\n                else:\n                    return None, ''\n            except:\n                return None, ''\n    \n    async def _try_css_locator(\n        self,\n        page: Page,\n        target: str,\n        action: str\n    ) -> Tuple[Optional[ElementHandle], str]:\n        \"\"\"Try to find element using CSS selector with smart matching\"\"\"\n        text = self._extract_name_from_target(target)\n        target_lower = target.lower()\n        \n        if action == 'click':\n            selector = 'button, a, [role=\"button\"]'\n        elif action == 'fill':\n            selectors_to_try = []\n            \n            if 'email' in target_lower:\n                selectors_to_try.append('input[type=\"email\"]')\n            if 'password' in target_lower or 'pass' in target_lower:\n                selectors_to_try.append('input[type=\"password\"]')\n            if 'search' in target_lower:\n                selectors_to_try.append('input[type=\"search\"]')\n            if 'phone' in target_lower or 'tel' in target_lower:\n                selectors_to_try.append('input[type=\"tel\"]')\n            \n            selectors_to_try.append('input[type=\"text\"]')\n            selectors_to_try.append('input:not([type=\"hidden\"]):not([type=\"submit\"]):not([type=\"button\"])')\n            selectors_to_try.append('textarea')\n            \n            for sel in selectors_to_try:\n                if text:\n                    selector = f'{sel}[placeholder*=\"{text}\" i], {sel}[name*=\"{text}\" i], {sel}[id*=\"{text}\" i]'\n                else:\n                    selector = sel\n                \n                try:\n                    locator = page.locator(selector).first\n                    locator_str = f'page.locator(\"{selector}\").first'\n                    await locator.wait_for(state='attached', timeout=1000)\n                    element = await locator.element_handle(timeout=1000)\n                    return element, locator_str\n                except:\n                    continue\n            \n            return None, ''\n            \n        elif action == 'select':\n            selector = 'select'\n        else:\n            selector = '*'\n        \n        if text and action != 'fill':\n            selector = f'{selector}:has-text(\"{text[:30]}\")'\n        \n        locator = page.locator(selector).first\n        locator_str = f'page.locator(\"{selector}\").first'\n        \n        try:\n            await locator.wait_for(state='attached', timeout=2000)\n            element = await locator.element_handle(timeout=1000)\n            return element, locator_str\n        except:\n            return None, locator_str\n    \n    async def _extract_element_info(self, element: ElementHandle) -> Dict[str, Any]:\n        \"\"\"Extract detailed information about an element including label\"\"\"\n        try:\n            info = await element.evaluate('''(el) => {\n                let label = '';\n                if (el.labels && el.labels.length > 0) {\n                    label = el.labels[0].textContent?.trim() || '';\n                } else {\n                    const labelEl = document.querySelector(`label[for=\"${el.id}\"]`);\n                    if (labelEl) {\n                        label = labelEl.textContent?.trim() || '';\n                    }\n                }\n                \n                return {\n                    tag: el.tagName.toLowerCase(),\n                    text: el.textContent?.trim() || '',\n                    value: el.value || '',\n                    type: el.type || '',\n                    name: el.name || '',\n                    id: el.id || '',\n                    className: el.className || '',\n                    placeholder: el.placeholder || '',\n                    ariaLabel: el.getAttribute('aria-label') || '',\n                    label: label,\n                    role: el.getAttribute('role') || '',\n                    disabled: el.disabled || false,\n                    visible: el.offsetWidth > 0 && el.offsetHeight > 0,\n                    href: el.href || ''\n                };\n            }''')\n            return info\n        except Exception as e:\n            logger.warning(f\"Failed to extract element info: {e}\")\n            return {}\n    \n    def _calculate_strategy_confidence(\n        self,\n        strategy: str,\n        element_info: Dict[str, Any],\n        target: str\n    ) -> float:\n        \"\"\"Calculate confidence score with intelligent matching\"\"\"\n        base_scores = {\n            'role': 0.92,\n            'label': 0.90,\n            'placeholder': 0.88,\n            'text': 0.75,\n            'css': 0.50\n        }\n        \n        score = base_scores.get(strategy, 0.50)\n        \n        target_lower = target.lower()\n        target_clean = self._extract_name_from_target(target).lower()\n        \n        elem_text = element_info.get('text', '').lower()\n        elem_name = element_info.get('name', '').lower()\n        elem_placeholder = element_info.get('placeholder', '').lower()\n        elem_aria_label = element_info.get('ariaLabel', '').lower()\n        elem_label = element_info.get('label', '').lower()\n        elem_id = element_info.get('id', '').lower()\n        \n        if target_clean == elem_placeholder or target_clean == elem_aria_label or target_clean == elem_label:\n            score += 0.15\n        elif target_clean in elem_placeholder or target_clean in elem_aria_label or target_clean in elem_label:\n            score += 0.08\n        \n        if target_clean == elem_name or target_clean == elem_id:\n            score += 0.10\n        elif target_clean in elem_name or target_clean in elem_id:\n            score += 0.05\n        \n        if element_info.get('visible'):\n            score += 0.05\n        \n        if elem_text and target_lower in elem_text:\n            score += 0.03\n        \n        return min(1.0, score)\n    \n    def _infer_role(self, target: str, action: str) -> str:\n        \"\"\"Infer ARIA role from target and action\"\"\"\n        target_lower = target.lower()\n        \n        if any(kw in target_lower for kw in ['button', 'btn', 'submit']):\n            return 'button'\n        elif any(kw in target_lower for kw in ['link', 'anchor']):\n            return 'link'\n        elif any(kw in target_lower for kw in ['input', 'field', 'textbox']):\n            return 'textbox'\n        elif action == 'click':\n            return 'button'\n        elif action == 'fill':\n            return 'textbox'\n        else:\n            return 'button'\n    \n    def _extract_name_from_target(self, target: str) -> str:\n        \"\"\"Extract meaningful name from target description\"\"\"\n        # Remove noise words\n        noise = ['the', 'a', 'an', 'button', 'link', 'field', 'input', \n                 'box', 'element', 'form', 'select', 'dropdown']\n        \n        words = target.split()\n        filtered = [w for w in words if w.lower() not in noise]\n        \n        return ' '.join(filtered).strip() if filtered else target.strip()\n\n\ndef validate_task_sync(url: str, steps: List[Dict[str, Any]], headless: bool = True) -> Dict[str, Any]:\n    \"\"\"\n    Synchronous wrapper for validate_task\n    \n    Args:\n        url: Target URL\n        steps: List of automation steps\n        headless: Run headless\n        \n    Returns:\n        Validation result\n    \"\"\"\n    validator = IntelligentValidator()\n    return asyncio.run(validator.validate_task(url, steps, headless))\n","size_bytes":23968},"app/engines/browser_use/state_manager.py":{"content":"\"\"\"\nState Management for Complex Multi-Step Workflows\nPreserves context and state across automation steps\n\"\"\"\nimport json\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\n\nclass WorkflowState:\n    \"\"\"\n    Manages state for complex multi-step automation workflows\n    Preserves context, variables, and execution history\n    \"\"\"\n    \n    def __init__(self, workflow_id: Optional[str] = None, persist_to_disk: bool = False):\n        \"\"\"\n        Initialize workflow state manager\n        \n        Args:\n            workflow_id: Unique identifier for this workflow\n            persist_to_disk: Save state to disk for recovery\n        \"\"\"\n        self.workflow_id = workflow_id or f\"workflow_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        self.persist_to_disk = persist_to_disk\n        \n        self.state: Dict[str, Any] = {}\n        self.variables: Dict[str, Any] = {}\n        self.execution_history: List[Dict[str, Any]] = []\n        self.checkpoints: List[Dict[str, Any]] = []\n        \n        self.metadata = {\n            \"workflow_id\": self.workflow_id,\n            \"created_at\": datetime.now().isoformat(),\n            \"last_updated\": datetime.now().isoformat(),\n            \"step_count\": 0\n        }\n        \n        if self.persist_to_disk:\n            self.state_dir = Path(\"workflow_states\")\n            self.state_dir.mkdir(exist_ok=True)\n            self.state_file = self.state_dir / f\"{self.workflow_id}.json\"\n        \n        logger.info(f\"üîÑ Workflow state initialized: {self.workflow_id}\")\n    \n    def set_variable(self, key: str, value: Any):\n        \"\"\"\n        Set a workflow variable\n        \n        Args:\n            key: Variable name\n            value: Variable value\n        \"\"\"\n        self.variables[key] = value\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.debug(f\"üìù Variable set: {key} = {value}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def get_variable(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a workflow variable\n        \n        Args:\n            key: Variable name\n            default: Default value if key doesn't exist\n            \n        Returns:\n            Variable value or default\n        \"\"\"\n        return self.variables.get(key, default)\n    \n    def set_state(self, key: str, value: Any):\n        \"\"\"\n        Set a state value\n        \n        Args:\n            key: State key\n            value: State value\n        \"\"\"\n        self.state[key] = value\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.debug(f\"üíæ State set: {key}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def get_state(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a state value\n        \n        Args:\n            key: State key\n            default: Default value if key doesn't exist\n            \n        Returns:\n            State value or default\n        \"\"\"\n        return self.state.get(key, default)\n    \n    def add_step(self, step_name: str, step_data: Dict[str, Any], success: bool = True):\n        \"\"\"\n        Record a workflow step\n        \n        Args:\n            step_name: Name of the step\n            step_data: Data associated with the step\n            success: Whether the step succeeded\n        \"\"\"\n        step_record = {\n            \"step_number\": self.metadata[\"step_count\"] + 1,\n            \"step_name\": step_name,\n            \"timestamp\": datetime.now().isoformat(),\n            \"success\": success,\n            \"data\": step_data\n        }\n        \n        self.execution_history.append(step_record)\n        self.metadata[\"step_count\"] += 1\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.info(f\"‚úÖ Step {self.metadata['step_count']} recorded: {step_name} (success: {success})\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def create_checkpoint(self, checkpoint_name: str):\n        \"\"\"\n        Create a checkpoint of current state\n        \n        Args:\n            checkpoint_name: Name for this checkpoint\n        \"\"\"\n        checkpoint = {\n            \"name\": checkpoint_name,\n            \"timestamp\": datetime.now().isoformat(),\n            \"state\": self.state.copy(),\n            \"variables\": self.variables.copy(),\n            \"step_count\": self.metadata[\"step_count\"]\n        }\n        \n        self.checkpoints.append(checkpoint)\n        logger.info(f\"üîñ Checkpoint created: {checkpoint_name} (at step {self.metadata['step_count']})\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def restore_checkpoint(self, checkpoint_name: str) -> bool:\n        \"\"\"\n        Restore state from a checkpoint\n        \n        Args:\n            checkpoint_name: Name of checkpoint to restore\n            \n        Returns:\n            True if restored successfully, False if checkpoint not found\n        \"\"\"\n        for checkpoint in reversed(self.checkpoints):\n            if checkpoint[\"name\"] == checkpoint_name:\n                self.state = checkpoint[\"state\"].copy()\n                self.variables = checkpoint[\"variables\"].copy()\n                \n                logger.info(f\"‚ôªÔ∏è  Restored checkpoint: {checkpoint_name} (from step {checkpoint['step_count']})\")\n                \n                if self.persist_to_disk:\n                    self._save_to_disk()\n                \n                return True\n        \n        logger.warning(f\"‚ö†Ô∏è  Checkpoint not found: {checkpoint_name}\")\n        return False\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a summary of the workflow state\n        \n        Returns:\n            Dictionary with state summary\n        \"\"\"\n        return {\n            \"workflow_id\": self.workflow_id,\n            \"metadata\": self.metadata,\n            \"total_steps\": self.metadata[\"step_count\"],\n            \"total_checkpoints\": len(self.checkpoints),\n            \"variable_count\": len(self.variables),\n            \"state_keys\": list(self.state.keys()),\n            \"success_rate\": self._calculate_success_rate()\n        }\n    \n    def _calculate_success_rate(self) -> float:\n        \"\"\"Calculate success rate of executed steps\"\"\"\n        if not self.execution_history:\n            return 100.0\n        \n        successful = sum(1 for step in self.execution_history if step[\"success\"])\n        return (successful / len(self.execution_history)) * 100\n    \n    def _save_to_disk(self):\n        \"\"\"Save state to disk\"\"\"\n        try:\n            state_data = {\n                \"workflow_id\": self.workflow_id,\n                \"metadata\": self.metadata,\n                \"state\": self.state,\n                \"variables\": self.variables,\n                \"execution_history\": self.execution_history,\n                \"checkpoints\": self.checkpoints\n            }\n            \n            with open(self.state_file, 'w', encoding='utf-8') as f:\n                json.dump(state_data, f, indent=2)\n            \n            logger.debug(f\"üíæ State saved to: {self.state_file}\")\n        except Exception as e:\n            logger.error(f\"‚ùå Failed to save state: {str(e)}\")\n    \n    @classmethod\n    def load_from_disk(cls, workflow_id: str) -> Optional['WorkflowState']:\n        \"\"\"\n        Load workflow state from disk\n        \n        Args:\n            workflow_id: Workflow ID to load\n            \n        Returns:\n            WorkflowState instance or None if not found\n        \"\"\"\n        state_file = Path(\"workflow_states\") / f\"{workflow_id}.json\"\n        \n        if not state_file.exists():\n            logger.warning(f\"‚ö†Ô∏è  Workflow state not found: {workflow_id}\")\n            return None\n        \n        try:\n            with open(state_file, 'r', encoding='utf-8') as f:\n                state_data = json.load(f)\n            \n            instance = cls(workflow_id=workflow_id, persist_to_disk=True)\n            instance.metadata = state_data[\"metadata\"]\n            instance.state = state_data[\"state\"]\n            instance.variables = state_data[\"variables\"]\n            instance.execution_history = state_data[\"execution_history\"]\n            instance.checkpoints = state_data[\"checkpoints\"]\n            \n            logger.info(f\"üìÇ Workflow state loaded: {workflow_id}\")\n            return instance\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Failed to load state: {str(e)}\")\n            return None\n    \n    def reset(self):\n        \"\"\"Reset workflow state\"\"\"\n        self.state.clear()\n        self.variables.clear()\n        self.execution_history.clear()\n        self.checkpoints.clear()\n        self.metadata[\"step_count\"] = 0\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.info(f\"üîÑ Workflow state reset: {self.workflow_id}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n","size_bytes":9056},"app/engines/browser_use/retry_mechanism.py":{"content":"\"\"\"\nSmart Retry Mechanism for Browser Automation\nImplements exponential backoff and intelligent retry logic\n\"\"\"\nimport time\nimport logging\nimport asyncio\nfrom typing import Callable, Any, Optional, List\nfrom functools import wraps\n\nlogger = logging.getLogger(__name__)\n\n\nclass RetryConfig:\n    \"\"\"Configuration for retry behavior\"\"\"\n    \n    def __init__(self, \n                 max_retries: int = 3,\n                 initial_delay: float = 1.0,\n                 max_delay: float = 30.0,\n                 backoff_factor: float = 2.0,\n                 retry_on_exceptions: Optional[List[type]] = None):\n        \"\"\"\n        Initialize retry configuration\n        \n        Args:\n            max_retries: Maximum number of retry attempts\n            initial_delay: Initial delay in seconds before first retry\n            max_delay: Maximum delay between retries\n            backoff_factor: Multiplier for exponential backoff\n            retry_on_exceptions: List of exception types to retry on (None = all)\n        \"\"\"\n        self.max_retries = max_retries\n        self.initial_delay = initial_delay\n        self.max_delay = max_delay\n        self.backoff_factor = backoff_factor\n        self.retry_on_exceptions = retry_on_exceptions or [Exception]\n\n\nclass RetryMechanism:\n    \"\"\"\n    Smart retry handler with exponential backoff\n    Handles both sync and async operations\n    \"\"\"\n    \n    def __init__(self, config: Optional[RetryConfig] = None):\n        \"\"\"\n        Initialize retry mechanism\n        \n        Args:\n            config: Retry configuration (uses defaults if None)\n        \"\"\"\n        self.config = config or RetryConfig()\n        self.retry_stats = {\n            \"total_attempts\": 0,\n            \"total_retries\": 0,\n            \"successful_retries\": 0,\n            \"failed_operations\": 0\n        }\n    \n    def retry(self, func: Callable) -> Callable:\n        \"\"\"\n        Decorator for synchronous functions with retry logic\n        \n        Args:\n            func: Function to wrap with retry logic\n            \n        Returns:\n            Wrapped function with retry capability\n        \"\"\"\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            return self._execute_with_retry(func, *args, **kwargs)\n        \n        return wrapper\n    \n    def async_retry(self, func: Callable) -> Callable:\n        \"\"\"\n        Decorator for asynchronous functions with retry logic\n        \n        Args:\n            func: Async function to wrap with retry logic\n            \n        Returns:\n            Wrapped async function with retry capability\n        \"\"\"\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            return await self._execute_async_with_retry(func, *args, **kwargs)\n        \n        return wrapper\n    \n    def _execute_with_retry(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Execute synchronous function with retry logic\n        \n        Args:\n            func: Function to execute\n            *args: Positional arguments\n            **kwargs: Keyword arguments\n            \n        Returns:\n            Function result\n            \n        Raises:\n            Last exception if all retries fail\n        \"\"\"\n        last_exception = None\n        delay = self.config.initial_delay\n        \n        for attempt in range(self.config.max_retries + 1):\n            self.retry_stats[\"total_attempts\"] += 1\n            \n            try:\n                result = func(*args, **kwargs)\n                \n                if attempt > 0:\n                    self.retry_stats[\"successful_retries\"] += 1\n                    logger.info(f\"‚úÖ Operation succeeded after {attempt} retries\")\n                \n                return result\n                \n            except Exception as e:\n                last_exception = e\n                \n                if not self._should_retry(e):\n                    logger.error(f\"‚ùå Non-retryable exception: {type(e).__name__}\")\n                    self.retry_stats[\"failed_operations\"] += 1\n                    raise\n                \n                if attempt < self.config.max_retries:\n                    self.retry_stats[\"total_retries\"] += 1\n                    logger.warning(f\"‚ö†Ô∏è  Attempt {attempt + 1}/{self.config.max_retries + 1} failed: {str(e)}\")\n                    logger.info(f\"üîÑ Retrying in {delay:.1f}s...\")\n                    \n                    time.sleep(delay)\n                    delay = min(delay * self.config.backoff_factor, self.config.max_delay)\n                else:\n                    self.retry_stats[\"failed_operations\"] += 1\n                    logger.error(f\"‚ùå All {self.config.max_retries + 1} attempts failed\")\n        \n        if last_exception:\n            raise last_exception\n        else:\n            raise RuntimeError(\"All retry attempts exhausted without capturing an exception\")\n    \n    async def _execute_async_with_retry(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Execute asynchronous function with retry logic\n        \n        Args:\n            func: Async function to execute\n            *args: Positional arguments\n            **kwargs: Keyword arguments\n            \n        Returns:\n            Function result\n            \n        Raises:\n            Last exception if all retries fail\n        \"\"\"\n        last_exception = None\n        delay = self.config.initial_delay\n        \n        for attempt in range(self.config.max_retries + 1):\n            self.retry_stats[\"total_attempts\"] += 1\n            \n            try:\n                result = await func(*args, **kwargs)\n                \n                if attempt > 0:\n                    self.retry_stats[\"successful_retries\"] += 1\n                    logger.info(f\"‚úÖ Async operation succeeded after {attempt} retries\")\n                \n                return result\n                \n            except Exception as e:\n                last_exception = e\n                \n                if not self._should_retry(e):\n                    logger.error(f\"‚ùå Non-retryable exception: {type(e).__name__}\")\n                    self.retry_stats[\"failed_operations\"] += 1\n                    raise\n                \n                if attempt < self.config.max_retries:\n                    self.retry_stats[\"total_retries\"] += 1\n                    logger.warning(f\"‚ö†Ô∏è  Async attempt {attempt + 1}/{self.config.max_retries + 1} failed: {str(e)}\")\n                    logger.info(f\"üîÑ Retrying in {delay:.1f}s...\")\n                    \n                    await asyncio.sleep(delay)\n                    delay = min(delay * self.config.backoff_factor, self.config.max_delay)\n                else:\n                    self.retry_stats[\"failed_operations\"] += 1\n                    logger.error(f\"‚ùå All {self.config.max_retries + 1} async attempts failed\")\n        \n        if last_exception:\n            raise last_exception\n        else:\n            raise RuntimeError(\"All async retry attempts exhausted without capturing an exception\")\n    \n    def _should_retry(self, exception: Exception) -> bool:\n        \"\"\"\n        Determine if an exception should trigger a retry\n        \n        Args:\n            exception: The caught exception\n            \n        Returns:\n            True if should retry, False otherwise\n        \"\"\"\n        for exc_type in self.config.retry_on_exceptions:\n            if isinstance(exception, exc_type):\n                return True\n        return False\n    \n    def get_stats(self) -> dict:\n        \"\"\"\n        Get retry statistics\n        \n        Returns:\n            Dictionary with retry statistics\n        \"\"\"\n        return {\n            **self.retry_stats,\n            \"success_rate\": (\n                (self.retry_stats[\"total_attempts\"] - self.retry_stats[\"failed_operations\"]) \n                / max(self.retry_stats[\"total_attempts\"], 1) * 100\n            ),\n            \"config\": {\n                \"max_retries\": self.config.max_retries,\n                \"initial_delay\": self.config.initial_delay,\n                \"max_delay\": self.config.max_delay,\n                \"backoff_factor\": self.config.backoff_factor\n            }\n        }\n    \n    def reset_stats(self):\n        \"\"\"Reset retry statistics\"\"\"\n        self.retry_stats = {\n            \"total_attempts\": 0,\n            \"total_retries\": 0,\n            \"successful_retries\": 0,\n            \"failed_operations\": 0\n        }\n        logger.info(\"üìä Retry statistics reset\")\n\n\ndef create_retry_mechanism(max_retries: int = 3, \n                          initial_delay: float = 1.0,\n                          backoff_factor: float = 2.0) -> RetryMechanism:\n    \"\"\"\n    Factory function to create a retry mechanism with custom settings\n    \n    Args:\n        max_retries: Maximum number of retry attempts\n        initial_delay: Initial delay in seconds\n        backoff_factor: Multiplier for exponential backoff\n        \n    Returns:\n        Configured RetryMechanism instance\n    \"\"\"\n    config = RetryConfig(\n        max_retries=max_retries,\n        initial_delay=initial_delay,\n        backoff_factor=backoff_factor\n    )\n    return RetryMechanism(config)\n","size_bytes":9108}},"version":2}