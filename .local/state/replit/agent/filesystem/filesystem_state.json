{"file_contents":{"app/engines/playwright_mcp/agents/locator_engine.py":{"content":"\"\"\"\nStrict-Mode Locator Engine\nMulti-strategy locator generation with priority: data-testid > ARIA roles > unique attributes > text content > CSS\n\"\"\"\nimport logging\nimport re\nfrom typing import Dict, List, Optional, Tuple\nfrom dataclasses import dataclass\nfrom app.engines.playwright_mcp.selector_validator import SelectorValidator\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass LocatorStrategy:\n    \"\"\"Represents a locator strategy with priority\"\"\"\n    priority: int\n    strategy_type: str\n    locator: str\n    selector_type: str  # 'role', 'text', 'css', 'xpath', 'data-testid'\n    is_unique: bool\n    confidence: float\n\n\nclass StrictModeLocatorEngine:\n    \"\"\"\n    Generates strict-mode locators with automatic duplicate handling\n    Priority: data-testid > ARIA roles > unique attributes > text content > CSS with filters\n    \"\"\"\n    \n    PRIORITY_ORDER = {\n        'data-testid': 1,\n        'data-test': 1,\n        'aria-label': 2,\n        'role': 2,\n        'id': 3,\n        'name': 4,\n        'placeholder': 5,\n        'text': 6,\n        'css': 7,\n        'xpath': 8\n    }\n    \n    def __init__(self, mcp_client=None):\n        \"\"\"\n        Initialize locator engine\n        \n        Args:\n            mcp_client: MCP client for live element validation\n        \"\"\"\n        self.mcp_client = mcp_client\n    \n    def generate_locators(self, element_data: Dict) -> List[LocatorStrategy]:\n        \"\"\"\n        Generate multiple locator strategies for an element, ordered by priority\n        \n        Args:\n            element_data: Dictionary containing element attributes and properties\n            \n        Returns:\n            List of LocatorStrategy objects, ordered by priority (highest first)\n        \"\"\"\n        strategies = []\n        \n        # Strategy 1: data-testid or data-test attributes (highest priority)\n        if 'data-testid' in element_data.get('attributes', {}):\n            testid = element_data['attributes']['data-testid']\n            strategies.append(LocatorStrategy(\n                priority=self.PRIORITY_ORDER['data-testid'],\n                strategy_type='data-testid',\n                locator=f\"page.get_by_test_id('{testid}')\",\n                selector_type='data-testid',\n                is_unique=True,\n                confidence=0.95\n            ))\n        \n        if 'data-test' in element_data.get('attributes', {}):\n            testid = element_data['attributes']['data-test']\n            strategies.append(LocatorStrategy(\n                priority=self.PRIORITY_ORDER['data-test'],\n                strategy_type='data-test',\n                locator=f\"page.locator('[data-test=\\\"{testid}\\\"]')\",\n                selector_type='css',\n                is_unique=True,\n                confidence=0.95\n            ))\n        \n        # Strategy 2: ARIA role + accessible name\n        role = element_data.get('role')\n        aria_label = element_data.get('attributes', {}).get('aria-label')\n        \n        if role:\n            if aria_label:\n                strategies.append(LocatorStrategy(\n                    priority=self.PRIORITY_ORDER['role'],\n                    strategy_type='role-with-name',\n                    locator=f\"page.get_by_role('{role}', name='{self._escape_quotes(aria_label)}')\",\n                    selector_type='role',\n                    is_unique=True,\n                    confidence=0.90\n                ))\n            else:\n                strategies.append(LocatorStrategy(\n                    priority=self.PRIORITY_ORDER['role'],\n                    strategy_type='role-only',\n                    locator=f\"page.get_by_role('{role}')\",\n                    selector_type='role',\n                    is_unique=False,\n                    confidence=0.70\n                ))\n        \n        # Strategy 3: Unique ID attribute\n        if 'id' in element_data.get('attributes', {}):\n            elem_id = element_data['attributes']['id']\n            strategies.append(LocatorStrategy(\n                priority=self.PRIORITY_ORDER['id'],\n                strategy_type='id',\n                locator=f\"page.locator('#{elem_id}')\",\n                selector_type='css',\n                is_unique=True,\n                confidence=0.85\n            ))\n        \n        # Strategy 4: Name attribute (for form inputs)\n        if 'name' in element_data.get('attributes', {}):\n            name = element_data['attributes']['name']\n            strategies.append(LocatorStrategy(\n                priority=self.PRIORITY_ORDER['name'],\n                strategy_type='name',\n                locator=f\"page.locator('[name=\\\"{name}\\\"]')\",\n                selector_type='css',\n                is_unique=False,\n                confidence=0.75\n            ))\n        \n        # Strategy 5: Placeholder (for inputs)\n        if 'placeholder' in element_data.get('attributes', {}):\n            placeholder = element_data['attributes']['placeholder']\n            strategies.append(LocatorStrategy(\n                priority=self.PRIORITY_ORDER['placeholder'],\n                strategy_type='placeholder',\n                locator=f\"page.get_by_placeholder('{self._escape_quotes(placeholder)}')\",\n                selector_type='text',\n                is_unique=False,\n                confidence=0.70\n            ))\n        \n        # Strategy 6: Text content\n        text_content = element_data.get('text', '').strip()\n        if text_content and len(text_content) < 100:\n            strategies.append(LocatorStrategy(\n                priority=self.PRIORITY_ORDER['text'],\n                strategy_type='text',\n                locator=f\"page.get_by_text('{self._escape_quotes(text_content)}')\",\n                selector_type='text',\n                is_unique=False,\n                confidence=0.65\n            ))\n        \n        # Strategy 7: CSS selector with tag and classes\n        css_selector = self._build_css_selector(element_data)\n        if css_selector:\n            strategies.append(LocatorStrategy(\n                priority=self.PRIORITY_ORDER['css'],\n                strategy_type='css',\n                locator=f\"page.locator('{css_selector}')\",\n                selector_type='css',\n                is_unique=False,\n                confidence=0.60\n            ))\n        \n        # Sort by priority (lower number = higher priority)\n        strategies.sort(key=lambda s: (s.priority, -s.confidence))\n        \n        return strategies\n    \n    def generate_best_locator(self, element_data: Dict, duplicate_count: Optional[int] = None) -> str:\n        \"\"\"\n        Generate the best locator for an element, handling duplicates automatically\n        \n        Args:\n            element_data: Dictionary containing element attributes and properties\n            duplicate_count: If element has duplicates, which index to target (0-based)\n            \n        Returns:\n            Python Playwright locator code as string\n        \"\"\"\n        strategies = self.generate_locators(element_data)\n        \n        if not strategies:\n            # Fallback to XPath\n            return \"page.locator('//body')\"\n        \n        # Get the best strategy (first in sorted list)\n        best_strategy = strategies[0]\n        locator = best_strategy.locator\n        \n        # Handle duplicates\n        if duplicate_count is not None and duplicate_count > 0:\n            if not best_strategy.is_unique:\n                # Use .nth() for non-unique locators\n                locator = f\"{locator}.nth({duplicate_count})\"\n            else:\n                logger.warning(f\"Element marked as unique but has duplicates, using .nth({duplicate_count})\")\n                locator = f\"{locator}.nth({duplicate_count})\"\n        \n        # Add .first() for non-unique locators without specific index\n        elif not best_strategy.is_unique and duplicate_count is None:\n            locator = f\"{locator}.first()\"\n        \n        return locator\n    \n    def generate_with_filter(self, element_data: Dict, filter_options: Dict) -> str:\n        \"\"\"\n        Generate locator with additional filter options\n        \n        Args:\n            element_data: Dictionary containing element attributes\n            filter_options: Filter criteria (has_text, has_not_text, has, has_not)\n            \n        Returns:\n            Filtered locator code\n        \"\"\"\n        base_locator = self.generate_best_locator(element_data)\n        \n        filters = []\n        if 'has_text' in filter_options:\n            filters.append(f\"has_text='{self._escape_quotes(filter_options['has_text'])}'\")\n        if 'has_not_text' in filter_options:\n            filters.append(f\"has_not_text='{self._escape_quotes(filter_options['has_not_text'])}'\")\n        \n        if filters:\n            filter_str = ', '.join(filters)\n            return f\"{base_locator}.filter({filter_str})\"\n        \n        return base_locator\n    \n    def validate_locator(self, locator: str, page_snapshot: Dict = None) -> Tuple[bool, str]:\n        \"\"\"\n        Validate if locator is strict-mode compliant and not brittle\n        \n        Args:\n            locator: Playwright locator code\n            page_snapshot: Current page DOM snapshot (optional, for future live validation)\n            \n        Returns:\n            Tuple of (is_valid, reason)\n        \"\"\"\n        from app.engines.playwright_mcp.selector_validator import SelectorConfidence\n        \n        # Use score_locator_code for full Playwright locator strings\n        if 'page.' in locator or locator.startswith('get_by'):\n            confidence, reason = SelectorValidator.score_locator_code(locator)\n        else:\n            confidence, reason = SelectorValidator.validate_selector(locator)\n        \n        # Accept HIGH, MEDIUM, and LOW confidence selectors\n        # Only reject REJECTED confidence (brittle patterns)\n        if confidence != SelectorConfidence.REJECTED:\n            return (True, reason)\n        else:\n            return (False, reason)\n    \n    def _build_css_selector(self, element_data: Dict) -> str:\n        \"\"\"Build a CSS selector from element data\"\"\"\n        tag = element_data.get('tag', 'div')\n        classes = element_data.get('classes', [])\n        \n        if classes:\n            class_str = '.' + '.'.join(classes[:3])  # Limit to first 3 classes\n            return f\"{tag}{class_str}\"\n        \n        return tag\n    \n    def _escape_quotes(self, text: str) -> str:\n        \"\"\"Escape quotes in text for Python string literals\"\"\"\n        return text.replace(\"'\", \"\\\\'\").replace('\"', '\\\\\"')\n    \n    def chain_locators(self, parent_locator: str, child_locator: str) -> str:\n        \"\"\"\n        Chain locators for nested elements\n        \n        Args:\n            parent_locator: Parent element locator\n            child_locator: Child element locator relative to parent\n            \n        Returns:\n            Chained locator code\n        \"\"\"\n        # Extract the selector from child_locator\n        # Example: page.get_by_role('button') -> get_by_role('button')\n        if child_locator.startswith('page.'):\n            child_method = child_locator[5:]  # Remove 'page.'\n            return f\"{parent_locator}.{child_method}\"\n        \n        return f\"{parent_locator}.locator('{child_locator}')\"\n","size_bytes":11179},"app/utils/timeout.py":{"content":"\"\"\"\nCross-platform timeout utility\nWorks on Windows, Linux, and macOS with proper cancellation\n\"\"\"\nimport threading\nimport logging\nfrom typing import Callable, Any, Optional\nfrom concurrent.futures import ThreadPoolExecutor, TimeoutError as FutureTimeoutError\n\nlogger = logging.getLogger(__name__)\n\n\nclass TimeoutError(Exception):\n    \"\"\"Raised when operation times out\"\"\"\n    pass\n\n\ndef run_with_timeout(func: Callable, timeout_seconds: int, *args, **kwargs) -> Any:\n    \"\"\"\n    Run a function with a timeout (cross-platform)\n    \n    Note: This implementation returns promptly on timeout but cannot\n    forcefully terminate the underlying function if it's stuck. The\n    worker thread continues in the background but HTTP request returns.\n    \n    Args:\n        func: Function to execute\n        timeout_seconds: Timeout in seconds\n        *args: Positional arguments to pass to func\n        **kwargs: Keyword arguments to pass to func\n        \n    Returns:\n        Result from func\n        \n    Raises:\n        TimeoutError: If function execution exceeds timeout\n    \"\"\"\n    executor = ThreadPoolExecutor(max_workers=1)\n    future = executor.submit(func, *args, **kwargs)\n    \n    try:\n        result = future.result(timeout=timeout_seconds)\n        executor.shutdown(wait=False)\n        return result\n    except FutureTimeoutError:\n        logger.warning(f\"â±ï¸ Operation timed out after {timeout_seconds} seconds\")\n        future.cancel()\n        executor.shutdown(wait=False)\n        raise TimeoutError(f\"Operation timed out after {timeout_seconds} seconds\")\n    except Exception as e:\n        logger.error(f\"âŒ Error during timed execution: {str(e)}\")\n        executor.shutdown(wait=False)\n        raise\n","size_bytes":1714},"app/engines/playwright_mcp/selector_validator.py":{"content":"\"\"\"\nSelector Validator for Playwright MCP Code Generator\nValidates and scores selectors for stability and CI/CD compatibility\n\nRejects brittle patterns:\n- nth-child() selectors\n- XPath with numeric indices\n- Hashed/dynamic CSS classes\n- ID selectors with timestamps or UUIDs\n\"\"\"\n\nimport re\nfrom typing import Dict, Tuple, Optional\nfrom enum import Enum\n\n\nclass SelectorConfidence(Enum):\n    \"\"\"Confidence levels for selector stability\"\"\"\n    HIGH = \"high\"\n    MEDIUM = \"medium\"\n    LOW = \"low\"\n    REJECTED = \"rejected\"\n\n\nclass SelectorValidator:\n    \"\"\"Validates selectors for stability and best practices\"\"\"\n    \n    BRITTLE_PATTERNS = [\n        (r'nth-child\\(', \"nth-child is brittle and order-dependent\"),\n        (r'nth-of-type\\(', \"nth-of-type is brittle and order-dependent\"),\n        (r':nth-\\w+\\(', \"nth-based selectors are fragile\"),\n        (r'\\[\\d+\\]', \"XPath numeric indices break with DOM changes\"),\n        (r'//\\w+\\[\\d+\\]', \"XPath with numeric indices is unstable\"),\n        (r'\\b[a-f0-9]{6,}\\b', \"Hashed classnames change with builds\"),\n        (r'css-[a-z0-9]+', \"CSS-in-JS hashed classes are unstable\"),\n        (r'\\w+-\\d{13,}', \"Timestamp-based identifiers are dynamic\"),\n        (r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', \"UUID selectors are unreliable\"),\n    ]\n    \n    SEMANTIC_PATTERNS = [\n        (r'get_by_test_id', SelectorConfidence.HIGH),\n        (r'get_by_role.*name=', SelectorConfidence.HIGH),\n        (r'get_by_label', SelectorConfidence.HIGH),\n        (r'get_by_placeholder', SelectorConfidence.HIGH),\n        (r'get_by_text', SelectorConfidence.MEDIUM),\n        (r'get_by_role', SelectorConfidence.MEDIUM),\n        (r'data-testid', SelectorConfidence.HIGH),\n        (r'aria-label=', SelectorConfidence.HIGH),\n        (r'role=', SelectorConfidence.MEDIUM),\n    ]\n    \n    @classmethod\n    def validate_selector(cls, selector: str) -> Tuple[SelectorConfidence, Optional[str]]:\n        \"\"\"\n        Validate a selector and return confidence score with reasoning\n        \n        Args:\n            selector: The selector string to validate\n            \n        Returns:\n            Tuple of (confidence_level, reason)\n        \"\"\"\n        if not selector or not isinstance(selector, str):\n            return SelectorConfidence.REJECTED, \"Empty or invalid selector\"\n        \n        selector_lower = selector.lower()\n        \n        for pattern, reason in cls.BRITTLE_PATTERNS:\n            if re.search(pattern, selector_lower, re.IGNORECASE):\n                return SelectorConfidence.REJECTED, reason\n        \n        for pattern, confidence in cls.SEMANTIC_PATTERNS:\n            if re.search(pattern, selector_lower, re.IGNORECASE):\n                return confidence, f\"Uses {pattern.replace('.*', '')} (stable)\"\n        \n        if selector.startswith('#') and re.search(r'[a-zA-Z]', selector):\n            return SelectorConfidence.MEDIUM, \"ID selector (stable if ID is static)\"\n        \n        if 'button' in selector_lower or 'input' in selector_lower:\n            return SelectorConfidence.LOW, \"Generic tag selector (may be ambiguous)\"\n        \n        return SelectorConfidence.LOW, \"CSS selector without semantic attributes\"\n    \n    @classmethod\n    def is_acceptable(cls, selector: str) -> bool:\n        \"\"\"Check if selector is acceptable for CI/CD use\"\"\"\n        confidence, _ = cls.validate_selector(selector)\n        return confidence != SelectorConfidence.REJECTED\n    \n    @classmethod\n    def score_locator_code(cls, locator_code: str) -> Tuple[SelectorConfidence, Optional[str]]:\n        \"\"\"\n        Score a complete Playwright locator code snippet\n        \n        Args:\n            locator_code: Full Playwright locator like 'page.get_by_role(\"button\", name=\"Submit\")'\n            \n        Returns:\n            Tuple of (confidence_level, reason)\n        \"\"\"\n        if not locator_code:\n            return SelectorConfidence.REJECTED, \"No locator code provided\"\n        \n        if 'get_by_test_id' in locator_code:\n            return SelectorConfidence.HIGH, \"data-testid is the most stable selector\"\n        \n        if 'get_by_role' in locator_code and 'name=' in locator_code:\n            return SelectorConfidence.HIGH, \"Role with accessible name is very stable\"\n        \n        if 'get_by_label' in locator_code:\n            return SelectorConfidence.HIGH, \"Label-based selector is stable\"\n        \n        if 'get_by_placeholder' in locator_code:\n            return SelectorConfidence.HIGH, \"Placeholder is a stable attribute\"\n        \n        if 'get_by_role' in locator_code:\n            return SelectorConfidence.MEDIUM, \"Role without name is moderately stable\"\n        \n        if 'get_by_text' in locator_code:\n            return SelectorConfidence.MEDIUM, \"Text-based selectors can break if content changes\"\n        \n        if '.locator(' in locator_code:\n            selector_match = re.search(r'\\.locator\\([\"\\']([^\"\\']+)[\"\\']', locator_code)\n            if selector_match:\n                selector = selector_match.group(1)\n                return cls.validate_selector(selector)\n        \n        return SelectorConfidence.LOW, \"Unknown locator type\"\n    \n    @classmethod\n    def get_improvement_suggestion(cls, current_selector: str, element_info: Dict) -> Optional[str]:\n        \"\"\"\n        Suggest improvements for a selector based on available element information\n        \n        Args:\n            current_selector: Current selector being used\n            element_info: Dict with element attributes (role, aria-label, data-testid, etc.)\n            \n        Returns:\n            Suggestion string or None\n        \"\"\"\n        suggestions = []\n        \n        if element_info.get('data_testid'):\n            suggestions.append(f\"Add data-testid='{element_info['data_testid']}' for best stability\")\n        \n        if element_info.get('role') and element_info.get('name'):\n            suggestions.append(f\"Use getByRole('{element_info['role']}', name='{element_info['name']}')\")\n        \n        if element_info.get('aria_label'):\n            suggestions.append(f\"Use getByLabel('{element_info['aria_label']}')\")\n        \n        if suggestions:\n            return \"Consider: \" + \"; \".join(suggestions)\n        \n        return None\n\n\ndef calculate_selector_confidence(\n    role: Optional[str],\n    name: Optional[str],\n    aria_label: Optional[str],\n    placeholder: Optional[str],\n    test_id: Optional[str],\n    text: Optional[str],\n    selector: Optional[str]\n) -> Tuple[SelectorConfidence, str]:\n    \"\"\"\n    Calculate overall confidence based on available element attributes\n    \n    Returns:\n        Tuple of (confidence_level, explanation)\n    \"\"\"\n    if test_id:\n        return SelectorConfidence.HIGH, \"Has data-testid attribute (best for automation)\"\n    \n    if role and name:\n        return SelectorConfidence.HIGH, f\"Has role='{role}' with accessible name\"\n    \n    if aria_label:\n        return SelectorConfidence.HIGH, \"Has aria-label attribute\"\n    \n    if placeholder:\n        return SelectorConfidence.HIGH, \"Has placeholder attribute\"\n    \n    if role:\n        return SelectorConfidence.MEDIUM, \"Has role but no accessible name\"\n    \n    if text and len(text) < 50:\n        return SelectorConfidence.MEDIUM, \"Uses visible text (may change)\"\n    \n    if selector:\n        confidence, reason = SelectorValidator.validate_selector(selector)\n        return confidence, reason or \"Using fallback CSS selector\"\n    \n    return SelectorConfidence.LOW, \"No stable attributes available\"\n","size_bytes":7493},"app/utils/credentials.py":{"content":"\"\"\"\nCredential placeholder replacement utilities\n\"\"\"\nimport re\nimport logging\nfrom app.models import CredentialVault\n\nlogger = logging.getLogger(__name__)\n\n\ndef replace_credential_placeholders(instruction: str) -> tuple[str, list[str]]:\n    \"\"\"\n    Replace credential placeholders in the instruction with actual values.\n    Also detect credential names mentioned in the instruction and inject URL, username, and password.\n    \n    Supports two modes:\n    1. Placeholder format: {{credential_name}} - replaces with password only (legacy mode)\n    2. Natural language: \"log in to gmail\" - injects URL, username, and password\n    \n    Args:\n        instruction: The instruction string that may contain placeholders or credential names\n        \n    Returns:\n        Tuple of (processed_instruction, list_of_credentials_used)\n        \n    Example:\n        Input: \"log in to gmail\"\n        Output: (\"Go to https://mail.google.com and log in with username user@gmail.com and password MyActualPassword123\", [\"gmail\"])\n    \"\"\"\n    processed_instruction = instruction\n    credentials_used = []\n    missing_credentials = []\n    decryption_errors = []\n    \n    # Get all credentials from database\n    all_credentials = CredentialVault.query.all()\n    \n    # First, handle placeholder format {{credential_name}}\n    placeholder_pattern = r'\\{\\{([a-zA-Z0-9_]+)\\}\\}'\n    placeholders = re.findall(placeholder_pattern, instruction)\n    \n    for credential_name in placeholders:\n        credential = CredentialVault.query.filter_by(name=credential_name).first()\n        \n        if credential:\n            try:\n                # Get the decrypted value\n                actual_value = credential.get_credential()\n                \n                # Replace the placeholder with the actual value\n                placeholder = f\"{{{{{credential_name}}}}}\"\n                processed_instruction = processed_instruction.replace(placeholder, actual_value)\n                \n                if credential_name not in credentials_used:\n                    credentials_used.append(credential_name)\n                logger.info(f\"ðŸ” Replaced credential placeholder: {{{{{{credential_name}}}}}}\")\n                \n            except ValueError as e:\n                logger.error(f\"Encryption error for credential '{credential_name}': {str(e)}\")\n                raise ValueError(\n                    f\"Cannot decrypt credentials: {str(e)} \"\n                    \"Please set the ENCRYPTION_KEY environment variable or Replit Secret.\"\n                )\n            except Exception as e:\n                logger.error(f\"Failed to decrypt credential '{credential_name}': {str(e)}\")\n                decryption_errors.append(f\"{credential_name}: {str(e)}\")\n        else:\n            logger.warning(f\"âš ï¸  Credential not found: {{{{{{credential_name}}}}}}\")\n            missing_credentials.append(credential_name)\n    \n    # Second, detect credential names in natural language (case-insensitive)\n    instruction_lower = processed_instruction.lower()\n    \n    for credential in all_credentials:\n        credential_name_lower = credential.name.lower()\n        \n        # Check if credential name is mentioned in the instruction\n        # Look for patterns like \"log in to gmail\", \"login to gmail\", \"sign in to gmail\"\n        login_patterns = [\n            f\"log in to {credential_name_lower}\",\n            f\"login to {credential_name_lower}\",\n            f\"sign in to {credential_name_lower}\",\n            f\"signin to {credential_name_lower}\",\n            f\"log into {credential_name_lower}\",\n            f\"sign into {credential_name_lower}\",\n            f\"authenticate to {credential_name_lower}\",\n            f\"authenticate with {credential_name_lower}\",\n        ]\n        \n        # Also check if just the credential name is mentioned with context words\n        if any(pattern in instruction_lower for pattern in login_patterns):\n            try:\n                password = credential.get_credential()\n                username = credential.username or \"\"\n                url = credential.url or \"\"\n                \n                # Build the replacement text with all credential info\n                replacement_parts = []\n                \n                if url:\n                    replacement_parts.append(f\"go to {url}\")\n                \n                if username and password:\n                    replacement_parts.append(f\"log in with username {username} and password {password}\")\n                elif password:\n                    replacement_parts.append(f\"log in with password {password}\")\n                \n                if replacement_parts:\n                    replacement_text = \" and \".join(replacement_parts)\n                    \n                    # Find and replace the login pattern in the instruction\n                    for pattern in login_patterns:\n                        if pattern in instruction_lower:\n                            # Find the actual text in the original instruction (preserving case)\n                            start_idx = instruction_lower.find(pattern)\n                            end_idx = start_idx + len(pattern)\n                            original_text = processed_instruction[start_idx:end_idx]\n                            \n                            # Replace with detailed credential information\n                            processed_instruction = (\n                                processed_instruction[:start_idx] +\n                                replacement_text +\n                                processed_instruction[end_idx:]\n                            )\n                            \n                            if credential.name not in credentials_used:\n                                credentials_used.append(credential.name)\n                            logger.info(f\"ðŸ” Detected and expanded credential reference: {credential.name}\")\n                            logger.info(f\"   URL: {url if url else 'Not set'}\")\n                            logger.info(f\"   Username: {username if username else 'Not set'}\")\n                            logger.info(f\"   Password: {'*' * len(password) if password else 'Not set'}\")\n                            break\n                \n            except ValueError as e:\n                logger.error(f\"Encryption error for credential '{credential.name}': {str(e)}\")\n                raise ValueError(\n                    f\"Cannot decrypt credentials: {str(e)} \"\n                    \"Please set the ENCRYPTION_KEY environment variable or Replit Secret.\"\n                )\n            except Exception as e:\n                logger.error(f\"Failed to decrypt credential '{credential.name}': {str(e)}\")\n                decryption_errors.append(f\"{credential.name}: {str(e)}\")\n    \n    if decryption_errors:\n        raise ValueError(\n            f\"Failed to decrypt credentials: {'; '.join(decryption_errors)}\"\n        )\n    \n    if missing_credentials:\n        raise ValueError(\n            f\"Missing credentials: {', '.join(missing_credentials)}. \"\n            f\"Please add these credentials in the Credentials page before using them in automations.\"\n        )\n    \n    return processed_instruction, credentials_used\n\n\ndef has_credential_placeholders(instruction: str) -> bool:\n    \"\"\"\n    Check if the instruction contains any credential placeholders.\n    \n    Args:\n        instruction: The instruction string to check\n        \n    Returns:\n        True if placeholders are found, False otherwise\n    \"\"\"\n    placeholder_pattern = r'\\{\\{([a-zA-Z0-9_]+)\\}\\}'\n    return bool(re.search(placeholder_pattern, instruction))\n\n\ndef extract_credential_names(instruction: str) -> list[str]:\n    \"\"\"\n    Extract credential names from placeholders in the instruction.\n    \n    Args:\n        instruction: The instruction string that may contain placeholders\n        \n    Returns:\n        List of credential names found in placeholders\n    \"\"\"\n    placeholder_pattern = r'\\{\\{([a-zA-Z0-9_]+)\\}\\}'\n    return re.findall(placeholder_pattern, instruction)\n","size_bytes":8006},"app/models.py":{"content":"\"\"\"\nDatabase Models for AI Browser Automation\n\"\"\"\nimport json\nfrom datetime import datetime\nfrom flask_sqlalchemy import SQLAlchemy\nfrom sqlalchemy.orm import DeclarativeBase\nfrom app.utils.encryption import credential_encryption\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\ndb = SQLAlchemy(model_class=Base)\n\n\nclass AutomationPlan(db.Model):\n    \"\"\"Model for storing automation plans generated by Planner Agent\"\"\"\n    \n    __tablename__ = 'automation_plans'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, index=True)\n    execution_id = db.Column(db.Integer, db.ForeignKey('execution_history.id'), nullable=True)\n    \n    goal = db.Column(db.Text, nullable=False)\n    start_url = db.Column(db.Text, nullable=False)\n    plan_yaml = db.Column(db.Text, nullable=False)\n    validated_locators = db.Column(db.Text, nullable=True)\n    plan_metadata = db.Column(db.Text, nullable=True)\n    \n    def to_dict(self):\n        \"\"\"Convert model to dictionary\"\"\"\n        return {\n            'id': self.id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'execution_id': self.execution_id,\n            'goal': self.goal,\n            'start_url': self.start_url,\n            'plan_yaml': self.plan_yaml,\n            'validated_locators': self.validated_locators,\n            'plan_metadata': self.plan_metadata\n        }\n\n\nclass GeneratedScript(db.Model):\n    \"\"\"Model for storing Python Playwright scripts generated by Generator Agent\"\"\"\n    \n    __tablename__ = 'generated_scripts'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, index=True)\n    execution_id = db.Column(db.Integer, db.ForeignKey('execution_history.id'), nullable=True)\n    plan_id = db.Column(db.Integer, db.ForeignKey('automation_plans.id'), nullable=True)\n    \n    script_type = db.Column(db.String(20), nullable=False, default='original')\n    python_code = db.Column(db.Text, nullable=False)\n    script_hash = db.Column(db.String(64), nullable=True)\n    \n    is_healed = db.Column(db.Boolean, nullable=False, default=False)\n    healing_iterations = db.Column(db.Integer, nullable=True, default=0)\n    \n    def to_dict(self):\n        \"\"\"Convert model to dictionary\"\"\"\n        return {\n            'id': self.id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'execution_id': self.execution_id,\n            'plan_id': self.plan_id,\n            'script_type': self.script_type,\n            'python_code': self.python_code,\n            'script_hash': self.script_hash,\n            'is_healed': self.is_healed,\n            'healing_iterations': self.healing_iterations\n        }\n\n\nclass TraceFile(db.Model):\n    \"\"\"Model for storing Playwright trace files for Healer Agent\"\"\"\n    \n    __tablename__ = 'trace_files'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, index=True)\n    execution_id = db.Column(db.Integer, db.ForeignKey('execution_history.id'), nullable=True)\n    script_id = db.Column(db.Integer, db.ForeignKey('generated_scripts.id'), nullable=True)\n    \n    trace_path = db.Column(db.Text, nullable=False)\n    trace_analysis = db.Column(db.Text, nullable=True)\n    identified_issues = db.Column(db.Text, nullable=True)\n    \n    def to_dict(self):\n        \"\"\"Convert model to dictionary\"\"\"\n        return {\n            'id': self.id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'execution_id': self.execution_id,\n            'script_id': self.script_id,\n            'trace_path': self.trace_path,\n            'trace_analysis': self.trace_analysis,\n            'identified_issues': self.identified_issues\n        }\n\n\nclass ExecutionHistory(db.Model):\n    \"\"\"Model for storing automation execution history\"\"\"\n    \n    __tablename__ = 'execution_history'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, index=True)\n    \n    prompt = db.Column(db.Text, nullable=False)\n    engine = db.Column(db.String(50), nullable=False)\n    headless = db.Column(db.Boolean, nullable=False, default=False)\n    \n    success = db.Column(db.Boolean, nullable=False, default=False)\n    error_message = db.Column(db.Text, nullable=True)\n    \n    screenshot_path = db.Column(db.Text, nullable=True)  # JSON array of screenshot paths\n    execution_logs = db.Column(db.Text, nullable=True)\n    \n    iterations = db.Column(db.Integer, nullable=True)\n    execution_time = db.Column(db.Float, nullable=True)\n    \n    automation_plans = db.relationship('AutomationPlan', backref='execution', lazy=True)\n    generated_scripts = db.relationship('GeneratedScript', backref='execution', lazy=True)\n    trace_files = db.relationship('TraceFile', backref='execution', lazy=True)\n    \n    def to_dict(self):\n        \"\"\"Convert model to dictionary\"\"\"\n        screenshots = []\n        if self.screenshot_path:\n            try:\n                screenshots = json.loads(self.screenshot_path)\n            except (json.JSONDecodeError, TypeError):\n                screenshots = [self.screenshot_path] if self.screenshot_path else []\n        \n        # Get generated and healed scripts\n        generated_script = None\n        healed_script = None\n        \n        # Find the most recent generated script (non-healed)\n        for script in sorted(self.generated_scripts, key=lambda x: x.created_at, reverse=True):\n            if not script.is_healed and not generated_script:\n                generated_script = script.python_code\n            elif script.is_healed and not healed_script:\n                healed_script = script.python_code\n        \n        return {\n            'id': self.id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'prompt': self.prompt,\n            'engine': self.engine,\n            'headless': self.headless,\n            'success': self.success,\n            'error_message': self.error_message,\n            'screenshot_path': self.screenshot_path,\n            'screenshots': screenshots,\n            'execution_logs': self.execution_logs,\n            'iterations': self.iterations,\n            'execution_time': self.execution_time,\n            'generated_script': generated_script,\n            'healed_script': healed_script\n        }\n\n\nclass CredentialVault(db.Model):\n    \"\"\"Model for securely storing website credentials with encryption\"\"\"\n    \n    __tablename__ = 'credential_vault'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, index=True)\n    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    name = db.Column(db.String(100), nullable=False, unique=True, index=True)\n    service = db.Column(db.String(200), nullable=True)\n    url = db.Column(db.Text, nullable=True)\n    username = db.Column(db.String(200), nullable=True)\n    encrypted_value = db.Column(db.Text, nullable=False)\n    description = db.Column(db.Text, nullable=True)\n    \n    def set_credential(self, plaintext_value: str):\n        \"\"\"Encrypt and store a credential value\"\"\"\n        self.encrypted_value = credential_encryption.encrypt(plaintext_value)\n    \n    def get_credential(self) -> str:\n        \"\"\"Decrypt and return the credential value\"\"\"\n        return credential_encryption.decrypt(self.encrypted_value)\n    \n    def to_dict(self, include_value=False):\n        \"\"\"\n        Convert model to dictionary\n        \n        Args:\n            include_value: If True, include the decrypted credential value.\n                          Should only be True when actually using the credential.\n        \"\"\"\n        result = {\n            'id': self.id,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None,\n            'name': self.name,\n            'service': self.service,\n            'url': self.url,\n            'username': self.username,\n            'description': self.description\n        }\n        \n        if include_value:\n            result['value'] = self.get_credential()\n        \n        return result\n","size_bytes":8439},"app/services/engine_orchestrator.py":{"content":"\"\"\"\nEngine Orchestrator\nManages and coordinates all browser automation engines with enhanced validation and healing\n\"\"\"\nfrom typing import Dict, Any, Tuple, Optional\nimport logging\nimport asyncio\nimport app.engines.playwright_mcp as playwright_mcp_codebase\nimport app.engines.browser_use as browser_use_codebase\nfrom app.middleware.security import sanitize_error_message\n# Code generation imports removed - using pure execution mode only\n\nlogger = logging.getLogger(__name__)\n\n\nclass EngineOrchestrator:\n    \"\"\"\n    Orchestrates browser automation engines (Playwright MCP and Browser-Use)\n    Handles engine instantiation, caching, and execution delegation\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the orchestrator with empty engine caches\"\"\"\n        self.playwright_engines = {}\n        self.browser_use_engines = {}\n    \n    def get_playwright_engine(self, headless: bool) -> Tuple[Any, Any]:\n        \"\"\"\n        Get or create Playwright MCP engine instance\n        \n        Args:\n            headless: Run in headless mode\n            \n        Returns:\n            Tuple of (mcp_client, browser_agent)\n        \"\"\"\n        if headless not in self.playwright_engines:\n            mcp_client, browser_agent = playwright_mcp_codebase.create_engine(headless=headless)\n            self.playwright_engines[headless] = (mcp_client, browser_agent)\n        \n        return self.playwright_engines[headless]\n    \n    def get_browser_use_engine(self, headless: bool):\n        \"\"\"\n        Get or create Browser-Use engine instance\n        Caches instances per headless mode for better performance\n        \n        Args:\n            headless: Run in headless mode\n            \n        Returns:\n            BrowserUseEngine instance\n        \"\"\"\n        if headless not in self.browser_use_engines:\n            self.browser_use_engines[headless] = browser_use_codebase.create_engine(headless=headless)\n        \n        return self.browser_use_engines[headless]\n    \n    \n    def execute_instruction_with_progress(self, instruction: str, engine_type: str, headless: bool, progress_callback=None) -> Dict[str, Any]:\n        \"\"\"\n        Execute an instruction with progress updates via callback\n        \n        Args:\n            instruction: Natural language instruction\n            engine_type: 'playwright_mcp' or 'browser_use'\n            headless: Run in headless mode\n            progress_callback: Optional callback function for progress updates\n            \n        Returns:\n            Execution result dictionary\n        \"\"\"\n        return self.execute_instruction(instruction, engine_type, headless, progress_callback)\n    \n    def execute_instruction(self, instruction: str, engine_type: str, headless: bool, progress_callback=None) -> Dict[str, Any]:\n        \"\"\"\n        Execute an instruction using the specified engine\n        \n        Engine Behavior:\n        - 'playwright_mcp': Direct execution with Playwright MCP\n        - 'browser_use': Direct execution with Browser-Use\n        \n        Args:\n            instruction: Natural language instruction\n            engine_type: 'playwright_mcp' or 'browser_use'\n            headless: Run in headless mode\n            progress_callback: Optional callback function for progress updates\n            \n        Returns:\n            Dict with execution results\n        \"\"\"\n        valid_engines = ['playwright_mcp', 'browser_use']\n        if engine_type not in valid_engines:\n            logger.error(f\"Invalid engine type: {engine_type}\")\n            return {\n                'success': False,\n                'error': f\"Invalid engine type: {engine_type}. Must be one of: {', '.join(valid_engines)}\",\n                'steps': [],\n                'iterations': 0,\n                'engine': engine_type,\n                'headless': headless\n            }\n        \n        # Direct execution only - no code generation\n        logger.info(\"ðŸš€ Direct execution mode - no code generation\")\n        \n        result = None\n        try:\n            if engine_type == 'playwright_mcp':\n                # Direct execution with Playwright MCP\n                client, agent = self.get_playwright_engine(headless)\n                \n                try:\n                    if not client.initialized:\n                        logger.info(\"Initializing Playwright MCP client...\")\n                        client.initialize()\n                    \n                    # Execute the automation directly\n                    logger.info(\"ðŸŽ­ Executing automation with Playwright MCP...\")\n                    result = agent.execute_instruction(instruction, mode=\"direct\", progress_callback=progress_callback)\n                except Exception as e:\n                    logger.error(f\"Playwright MCP error: {str(e)}, attempting to reinitialize\")\n                    self._reset_playwright_engine(headless)\n                    raise\n                \n            elif engine_type == 'browser_use':\n                engine = self.get_browser_use_engine(headless)\n                result = engine.execute_instruction_sync(instruction, progress_callback=progress_callback, save_screenshot=True)\n            \n            if result is not None:\n                result['engine'] = engine_type\n                result['headless'] = headless\n                \n                # No code generation or healing - just return execution results\n                \n                return result\n            else:\n                raise ValueError(\"Engine returned no result\")\n            \n        except Exception as e:\n            logger.error(f\"Engine execution error ({engine_type}): {str(e)}\", exc_info=True)\n            user_message = sanitize_error_message(e)\n            \n            return {\n                'success': False,\n                'error': 'Execution failed',\n                'message': user_message,\n                'steps': [],\n                'iterations': 0,\n                'engine': engine_type,\n                'headless': headless\n            }\n    \n    def _reset_playwright_engine(self, headless: bool):\n        \"\"\"\n        Reset Playwright engine if it crashes or becomes unresponsive\n        \n        Args:\n            headless: Headless mode setting\n        \"\"\"\n        if headless in self.playwright_engines:\n            logger.warning(f\"Resetting Playwright engine (headless={headless})\")\n            try:\n                client, _ = self.playwright_engines[headless]\n                if hasattr(client, 'cleanup'):\n                    client.cleanup()\n            except Exception as e:\n                logger.error(f\"Error during Playwright cleanup: {str(e)}\")\n            finally:\n                del self.playwright_engines[headless]\n    \n    def get_tools(self, engine_type: str) -> list:\n        \"\"\"\n        Get available tools for the specified engine\n        \n        Args:\n            engine_type: 'playwright_mcp' or 'browser_use'\n            \n        Returns:\n            List of available tools\n        \"\"\"\n        if engine_type == 'playwright_mcp':\n            client, _ = self.get_playwright_engine(headless=True)\n            \n            if not client.initialized:\n                client.initialize()\n            \n            return client.list_tools()\n        else:\n            return [\n                {'name': 'browser_use_agent', 'description': 'AI-powered browser automation'}\n            ]\n    \n    def cleanup_after_timeout(self, engine_type: str, headless: bool):\n        \"\"\"\n        Clean up resources after a timed-out execution\n        \n        Args:\n            engine_type: Engine that was executing when timeout occurred\n            headless: Headless mode setting\n        \"\"\"\n        logger.warning(f\"Cleaning up after timeout for {engine_type} (headless={headless})\")\n        \n        try:\n            if engine_type == 'playwright_mcp':\n                self._reset_playwright_engine(headless)\n            elif engine_type == 'browser_use':\n                # Reset browser_use engine by removing it from cache\n                # This forces a fresh engine on next request\n                if headless in self.browser_use_engines:\n                    logger.info(f\"Removing browser_use engine from cache (headless={headless})\")\n                    del self.browser_use_engines[headless]\n        except Exception as e:\n            logger.error(f\"Error during timeout cleanup: {str(e)}\")\n    \n    \n    def reset_agent(self, engine_type: str, headless: bool = True):\n        \"\"\"\n        Reset the conversation history for the specified engine\n        \n        Args:\n            engine_type: 'playwright_mcp' or 'browser_use'\n            headless: Headless mode (for Playwright MCP)\n        \"\"\"\n        if engine_type == 'playwright_mcp':\n            _, agent = self.get_playwright_engine(headless)\n            agent.reset_conversation()\n","size_bytes":8812},"replit.md":{"content":"# AI Browser Automation\n\n## Overview\nThis project is an AI-powered web automation application built with Flask and Playwright, designed to provide a web interface for automating browser tasks using AI agents. Its purpose is to enable users to easily create and manage complex web automations. The application supports multiple AI engines for flexible automation and can generate reusable Python Playwright scripts. It emphasizes security, privacy, and state persistence, making it suitable for various automation needs.\n\n## User Preferences\n- **AI Model**: Configured to use `gpt-4.1-2025-04-14-eastus-dz` for all AI operations\n  - Model is read from `config/config.ini` and applied across all engines (browser-use, Playwright MCP, and all three agents: Planner, Generator, Healer)\n\n## System Architecture\nThe application uses Python 3.12 with the Flask web framework, SQLite for local data storage, and Playwright with Chromium for browser automation. It integrates with a Node.js-based Playwright MCP server for enhanced automation capabilities.\n\n### Key Features\n- **Browser Automation**: AI-guided web browsing actions.\n- **Multiple AI Engines**: Supports `browser-use` and `Playwright MCP`.\n- **Code Generation**: Both engines can generate reusable Python Playwright scripts with accurate locators. The Playwright MCP engine uses a three-agent system (Planner â†’ Generator â†’ Healer) for robust code generation with validated, self-healing locators.\n- **Web Interface**: User-friendly dashboard for managing automations.\n- **Security**: API key authentication, rate limiting, and CORS protection.\n- **Privacy-First**: No telemetry or cloud sync by default.\n- **State Persistence**: Ability to save and restore browser states.\n- **Screenshot & PDF Generation**: Capture and display of automation results.\n\n### Project Structure\nThe codebase is organized into logical directories:\n- `app/`: Contains the Flask application, including engines, middleware, routes, services, static assets, templates, and utilities.\n- `auth/`: Handles OAuth authentication.\n- `config/`: Stores configuration files.\n- `integrations/`: Manages external integrations, specifically the Playwright MCP Node.js server.\n- `instance/`: Used for SQLite database storage.\n- `main.py`: The application's entry point.\n- `requirements.txt`: Lists Python dependencies.\n\n### Configuration\n- **Environment Variables**: OAuth credentials for AI features (e.g., `OAUTH_TOKEN_URL`, `OAUTH_CLIENT_ID`) and security settings (`SESSION_SECRET`, `API_KEY`) are managed via Replit Secrets.\n- **Application Configuration**: Detailed settings for browser, AI models, logging, performance, and advanced features are controlled through `config/config.ini`.\n\n### Database\n- **Type**: SQLite, located at `instance/automation_history.db`.\n- **Management**: Tables are automatically created on startup, and data is included in Replit snapshots.\n\n## External Dependencies\n- **Python Packages**:\n    - `Flask`: Web framework.\n    - `Playwright`: Browser automation library.\n    - `SQLAlchemy`: Database ORM.\n    - `Gunicorn`: Production WSGI server.\n    - `Anthropic`, `OpenAI`, `Google GenAI`: SDKs for various AI providers.\n- **Node.js Packages**:\n    - `@playwright/mcp`: Playwright MCP server.\n    - `playwright`: Browser automation library (Node.js version).\n- **System Dependencies**:\n    - Chromium browser dependencies (e.g., X11, Mesa, Cairo, Pango) are installed to support Playwright.","size_bytes":3446},"auth/oauth_handler.py":{"content":"\"\"\"\nOAuth 2.0 Token Handler for Gateway Authentication\nHandles OAuth token fetching, caching, and certificate management\n\"\"\"\nimport os\nimport sys\nimport logging\nimport requests\nfrom typing import Dict, Optional, Any\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timedelta\nimport threading\n\ntry:\n    from dotenv import load_dotenv  # type: ignore\n    load_dotenv(override=True)  # type: ignore\nexcept ImportError:\n    pass\n\nlogging.basicConfig(level=logging.INFO)\n\n\ndef enable_certs():\n    \"\"\"\n    Enable certificate handling for secure gateway connections\n    Sets SSL certificate verification and paths\n    \"\"\"\n    cert_path = os.environ.get(\"SSL_CERT_FILE\") or os.environ.get(\"REQUESTS_CA_BUNDLE\")\n    if cert_path and os.path.exists(cert_path):\n        os.environ[\"REQUESTS_CA_BUNDLE\"] = cert_path\n        os.environ[\"SSL_CERT_FILE\"] = cert_path\n        logging.info(f\"SSL certificates enabled from: {cert_path}\")\n    else:\n        logging.debug(\"No custom SSL certificate path configured\")\n\n\n@dataclass\nclass OAuthConfig:\n    \"\"\"\n    OAuth configuration for keeping track of OAuth token config\n    \"\"\"\n    token_url: str = field(default=\"\")\n    client_id: str = field(default=\"\")\n    client_secret: str = field(default=\"\")\n    grant_type: str = field(default=\"\")\n    scope: str = field(default=\"\")\n    \n    def __post_init__(self):\n        \"\"\"Validate required fields\"\"\"\n        if not self.token_url:\n            raise ValueError(\"OAUTH_TOKEN_URL is required\")\n        if not self.client_id:\n            raise ValueError(\"OAUTH_CLIENT_ID is required\")\n        if not self.client_secret:\n            raise ValueError(\"OAUTH_CLIENT_SECRET is required\")\n\n\nclass OAuthTokenFetcher:\n    \"\"\"\n    Class for fetching and caching OAuth tokens\n    Handles refetching before token expiry\n    \"\"\"\n    OAUTH_HEADERS = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n    \n    def __init__(self, oauth_config: OAuthConfig):\n        \"\"\"\n        Initialize OAuth token fetcher\n        \n        Args:\n            oauth_config: OAuth configuration object\n        \"\"\"\n        self._oauth_config = oauth_config\n        self._token: Optional[Dict] = None\n        self._refresh_after: Optional[datetime] = None\n        self.early_refresh_seconds: int = int(os.environ.get(\"OAUTH_EARLY_REFRESH_SECONDS\", \"300\"))\n        \n    def _fetch_token(self) -> Dict:\n        \"\"\"\n        Fetch a new OAuth token from the token endpoint\n        \n        Returns:\n            Token response dictionary\n            \n        Raises:\n            requests.RequestException: If token fetch fails\n        \"\"\"\n        oauth_config = self._oauth_config\n        oauth_payload = {\n            \"client_id\": oauth_config.client_id,\n            \"client_secret\": oauth_config.client_secret,\n            \"grant_type\": oauth_config.grant_type,\n            \"scope\": oauth_config.scope\n        }\n        \n        response = requests.post(\n            oauth_config.token_url,\n            data=oauth_payload,\n            headers=self.OAUTH_HEADERS\n        )\n        response.raise_for_status()\n        return response.json()\n    \n    def get_token(self) -> Dict:\n        \"\"\"\n        Get OAuth token, fetching if needed or cache is expired\n        \n        Returns:\n            Token dictionary with 'access_token' and 'expires_in' keys\n        \"\"\"\n        datetime_now = datetime.now().timestamp()\n        \n        if (\n            self._token is None or \n            self._refresh_after is None or \n            datetime_now > self._refresh_after.timestamp()\n        ):\n            self._token = self._fetch_token()\n            \n            expires_in = int(self._token.get(\"expires_in\", 3600))\n            self._refresh_after = datetime.now() + timedelta(\n                seconds=(expires_in - self.early_refresh_seconds)\n            )\n            \n            logging.info(f\"OAuth token refreshed. Expires in {expires_in}s, will refresh after {self.early_refresh_seconds}s\")\n        \n        return self._token\n\n\nclass OAuthTokenManager:\n    \"\"\"\n    Singleton manager for OAuth tokens\n    Ensures token fetcher persists across requests for proper caching\n    \"\"\"\n    _instance: Optional['OAuthTokenManager'] = None\n    _lock: Optional[threading.Lock] = threading.Lock()\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n    \n    def __init__(self):\n        \"\"\"Initialize the token manager (only once)\"\"\"\n        if self._initialized:\n            return\n        \n        self._token_fetcher: Optional[OAuthTokenFetcher] = None\n        self._initialized = True\n        \n    def _initialize_fetcher(self):\n        \"\"\"Initialize the OAuth token fetcher with configuration from environment\"\"\"\n        enable_certs()\n        \n        required_env_vars = {\n            \"OAUTH_TOKEN_URL\": os.environ.get(\"OAUTH_TOKEN_URL\"),\n            \"OAUTH_CLIENT_ID\": os.environ.get(\"OAUTH_CLIENT_ID\"),\n            \"OAUTH_CLIENT_SECRET\": os.environ.get(\"OAUTH_CLIENT_SECRET\"),\n            \"OAUTH_GRANT_TYPE\": os.environ.get(\"OAUTH_GRANT_TYPE\"),\n            \"OAUTH_SCOPE\": os.environ.get(\"OAUTH_SCOPE\")\n        }\n        \n        missing_vars = [var for var, val in required_env_vars.items() if not val]\n        if missing_vars:\n            logging.error(f\"Missing required environment variables: {', '.join(missing_vars)}\")\n            raise EnvironmentError(f\"Missing required environment variables: {', '.join(missing_vars)}\")\n        \n        oauth_config = OAuthConfig(\n            token_url=str(required_env_vars[\"OAUTH_TOKEN_URL\"]),\n            client_id=str(required_env_vars[\"OAUTH_CLIENT_ID\"]),\n            client_secret=str(required_env_vars[\"OAUTH_CLIENT_SECRET\"]),\n            grant_type=str(required_env_vars[\"OAUTH_GRANT_TYPE\"]),\n            scope=str(required_env_vars[\"OAUTH_SCOPE\"])\n        )\n        \n        self._token_fetcher = OAuthTokenFetcher(oauth_config)\n        logging.info(\"OAuth token fetcher initialized\")\n    \n    def get_token(self, max_retries: int = 3) -> str:\n        \"\"\"\n        Get OAuth access token with retry logic and caching\n        Thread-safe singleton ensures token cache persists across requests\n        \n        Args:\n            max_retries: Maximum number of retry attempts\n            \n        Returns:\n            OAuth access token string\n            \n        Raises:\n            Exception: If all retry attempts fail\n        \"\"\"\n        if self._lock is not None:\n            with self._lock:\n                if self._token_fetcher is None:\n                    self._initialize_fetcher()\n        else:\n            if self._token_fetcher is None:\n                self._initialize_fetcher()\n        \n        for attempt in range(1, max_retries + 1):\n            try:\n                token = self._token_fetcher.get_token()  # type: ignore\n                return token[\"access_token\"]\n            except Exception as e:\n                if attempt == max_retries:\n                    logging.error(f\"OAuth token fetch failed after {max_retries} attempts: {e}\")\n                    raise\n                logging.warning(f\"OAuth token fetch attempt {attempt} failed: {e}. Retrying...\")\n        \n        raise Exception(\"Failed to fetch OAuth token\")\n\n\ndef get_oauth_token_with_retry(max_retries: int = 3) -> str:\n    \"\"\"\n    Get OAuth access token with retry logic\n    Uses singleton token manager to ensure tokens are cached across requests\n    \n    Args:\n        max_retries: Maximum number of retry attempts\n        \n    Returns:\n        OAuth access token string\n        \n    Raises:\n        Exception: If all retry attempts fail\n    \"\"\"\n    manager = OAuthTokenManager()\n    return manager.get_token(max_retries)\n","size_bytes":7763},"app/engines/browser_use/performance_monitor.py":{"content":"\"\"\"\nPerformance Monitoring and Metrics Tracking\nTracks automation performance, timing, and resource usage\n\"\"\"\nimport time\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nfrom collections import defaultdict\n\nlogger = logging.getLogger(__name__)\n\n\nclass PerformanceMonitor:\n    \"\"\"\n    Monitor and track performance metrics for browser automation\n    Tracks timing, success rates, and resource usage\n    \"\"\"\n    \n    def __init__(self, track_detailed_metrics: bool = True):\n        \"\"\"\n        Initialize performance monitor\n        \n        Args:\n            track_detailed_metrics: Track detailed per-operation metrics\n        \"\"\"\n        self.track_detailed_metrics = track_detailed_metrics\n        self.metrics = {\n            \"total_operations\": 0,\n            \"successful_operations\": 0,\n            \"failed_operations\": 0,\n            \"total_duration\": 0.0,\n            \"start_time\": datetime.now().isoformat()\n        }\n        \n        self.operation_metrics: Dict[str, Dict[str, Any]] = defaultdict(lambda: {\n            \"count\": 0,\n            \"success_count\": 0,\n            \"fail_count\": 0,\n            \"total_duration\": 0.0,\n            \"min_duration\": float('inf'),\n            \"max_duration\": 0.0\n        })\n        \n        self.timing_stack: List[Dict[str, Any]] = []\n        \n        logger.info(\"ðŸ“Š Performance monitor initialized\")\n    \n    def start_operation(self, operation_name: str) -> str:\n        \"\"\"\n        Start tracking an operation\n        \n        Args:\n            operation_name: Name of the operation\n            \n        Returns:\n            Operation ID for stopping later\n        \"\"\"\n        operation_id = f\"{operation_name}_{len(self.timing_stack)}\"\n        \n        timing_info = {\n            \"operation_id\": operation_id,\n            \"operation_name\": operation_name,\n            \"start_time\": time.time(),\n            \"start_timestamp\": datetime.now().isoformat()\n        }\n        \n        self.timing_stack.append(timing_info)\n        \n        if self.track_detailed_metrics:\n            logger.debug(f\"â±ï¸  Started: {operation_name}\")\n        \n        return operation_id\n    \n    def end_operation(self, operation_id: str, success: bool = True, metadata: Optional[Dict] = None):\n        \"\"\"\n        End tracking an operation\n        \n        Args:\n            operation_id: ID returned from start_operation\n            success: Whether operation succeeded\n            metadata: Optional metadata about the operation\n        \"\"\"\n        if not self.timing_stack:\n            logger.warning(\"âš ï¸  No operation to end\")\n            return\n        \n        timing_info = self.timing_stack.pop()\n        \n        if timing_info[\"operation_id\"] != operation_id:\n            logger.warning(f\"âš ï¸  Operation ID mismatch: expected {timing_info['operation_id']}, got {operation_id}\")\n        \n        duration = time.time() - timing_info[\"start_time\"]\n        operation_name = timing_info[\"operation_name\"]\n        \n        self.metrics[\"total_operations\"] += 1\n        self.metrics[\"total_duration\"] += duration\n        \n        if success:\n            self.metrics[\"successful_operations\"] += 1\n        else:\n            self.metrics[\"failed_operations\"] += 1\n        \n        op_metrics = self.operation_metrics[operation_name]\n        op_metrics[\"count\"] += 1\n        op_metrics[\"total_duration\"] += duration\n        op_metrics[\"min_duration\"] = min(op_metrics[\"min_duration\"], duration)\n        op_metrics[\"max_duration\"] = max(op_metrics[\"max_duration\"], duration)\n        \n        if success:\n            op_metrics[\"success_count\"] += 1\n        else:\n            op_metrics[\"fail_count\"] += 1\n        \n        if self.track_detailed_metrics:\n            status = \"âœ…\" if success else \"âŒ\"\n            logger.info(f\"{status} {operation_name} completed in {duration:.2f}s\")\n    \n    def record_metric(self, metric_name: str, value: Any):\n        \"\"\"\n        Record a custom metric\n        \n        Args:\n            metric_name: Name of the metric\n            value: Metric value\n        \"\"\"\n        if \"custom_metrics\" not in self.metrics:\n            self.metrics[\"custom_metrics\"] = {}\n        \n        self.metrics[\"custom_metrics\"][metric_name] = value\n        \n        if self.track_detailed_metrics:\n            logger.debug(f\"ðŸ“Š Metric recorded: {metric_name} = {value}\")\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"\n        Get performance summary\n        \n        Returns:\n            Dictionary with performance metrics\n        \"\"\"\n        total_ops = self.metrics[\"total_operations\"]\n        \n        summary = {\n            \"overview\": {\n                \"total_operations\": total_ops,\n                \"successful_operations\": self.metrics[\"successful_operations\"],\n                \"failed_operations\": self.metrics[\"failed_operations\"],\n                \"success_rate\": (self.metrics[\"successful_operations\"] / max(total_ops, 1)) * 100,\n                \"total_duration\": self.metrics[\"total_duration\"],\n                \"average_duration\": self.metrics[\"total_duration\"] / max(total_ops, 1),\n                \"start_time\": self.metrics[\"start_time\"],\n                \"current_time\": datetime.now().isoformat()\n            },\n            \"operation_breakdown\": {}\n        }\n        \n        for op_name, op_metrics in self.operation_metrics.items():\n            count = op_metrics[\"count\"]\n            summary[\"operation_breakdown\"][op_name] = {\n                \"count\": count,\n                \"success_count\": op_metrics[\"success_count\"],\n                \"fail_count\": op_metrics[\"fail_count\"],\n                \"success_rate\": (op_metrics[\"success_count\"] / max(count, 1)) * 100,\n                \"total_duration\": op_metrics[\"total_duration\"],\n                \"average_duration\": op_metrics[\"total_duration\"] / max(count, 1),\n                \"min_duration\": op_metrics[\"min_duration\"] if op_metrics[\"min_duration\"] != float('inf') else 0,\n                \"max_duration\": op_metrics[\"max_duration\"]\n            }\n        \n        if \"custom_metrics\" in self.metrics:\n            summary[\"custom_metrics\"] = self.metrics[\"custom_metrics\"]\n        \n        return summary\n    \n    def get_top_slowest_operations(self, limit: int = 5) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get the slowest operations\n        \n        Args:\n            limit: Number of operations to return\n            \n        Returns:\n            List of slowest operations with metrics\n        \"\"\"\n        operations = []\n        \n        for op_name, op_metrics in self.operation_metrics.items():\n            if op_metrics[\"count\"] > 0:\n                avg_duration = op_metrics[\"total_duration\"] / op_metrics[\"count\"]\n                operations.append({\n                    \"operation\": op_name,\n                    \"average_duration\": avg_duration,\n                    \"max_duration\": op_metrics[\"max_duration\"],\n                    \"count\": op_metrics[\"count\"]\n                })\n        \n        operations.sort(key=lambda x: x[\"average_duration\"], reverse=True)\n        return operations[:limit]\n    \n    def reset(self):\n        \"\"\"Reset all metrics\"\"\"\n        self.metrics = {\n            \"total_operations\": 0,\n            \"successful_operations\": 0,\n            \"failed_operations\": 0,\n            \"total_duration\": 0.0,\n            \"start_time\": datetime.now().isoformat()\n        }\n        self.operation_metrics.clear()\n        self.timing_stack.clear()\n        \n        logger.info(\"ðŸ”„ Performance metrics reset\")\n    \n    def log_summary(self):\n        \"\"\"Log a formatted summary of metrics\"\"\"\n        summary = self.get_summary()\n        \n        logger.info(\"=\" * 80)\n        logger.info(\"ðŸ“Š PERFORMANCE SUMMARY\")\n        logger.info(\"=\" * 80)\n        logger.info(f\"Total Operations: {summary['overview']['total_operations']}\")\n        logger.info(f\"Success Rate: {summary['overview']['success_rate']:.1f}%\")\n        logger.info(f\"Total Duration: {summary['overview']['total_duration']:.2f}s\")\n        logger.info(f\"Average Duration: {summary['overview']['average_duration']:.2f}s\")\n        \n        if summary['operation_breakdown']:\n            logger.info(\"\\nðŸ“‹ Operation Breakdown:\")\n            for op_name, metrics in summary['operation_breakdown'].items():\n                logger.info(f\"  â€¢ {op_name}: {metrics['count']} ops, \"\n                          f\"avg {metrics['average_duration']:.2f}s, \"\n                          f\"success {metrics['success_rate']:.1f}%\")\n        \n        logger.info(\"=\" * 80)\n","size_bytes":8538},"app/engines/playwright_mcp/agents/generator_agent.py":{"content":"\"\"\"\nGenerator Agent\nConverts automation plans into production-ready standalone Python Playwright scripts\n\"\"\"\nimport logging\nimport yaml\nimport json\nimport hashlib\nfrom typing import Dict, Any, Optional\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\n\nclass GeneratorAgent:\n    \"\"\"\n    Generator Agent that transforms YAML automation plans into executable Python Playwright code\n    Generates production-ready scripts with async/await, error handling, retry logic, and logging\n    \"\"\"\n    \n    def __init__(self, llm_client, locator_engine, model='gpt-4.1-2025-04-14-eastus-dz'):\n        \"\"\"\n        Initialize Generator Agent\n        \n        Args:\n            llm_client: LLM client for code generation\n            locator_engine: StrictModeLocatorEngine instance\n            model: Model name to use for code generation\n        \"\"\"\n        self.llm_client = llm_client\n        self.locator_engine = locator_engine\n        self.model = model\n    \n    def generate_script(self, plan_yaml: str, progress_callback=None) -> Dict[str, Any]:\n        \"\"\"\n        Generate Python Playwright script from automation plan\n        \n        Args:\n            plan_yaml: YAML automation plan\n            progress_callback: Optional callback for progress updates\n            \n        Returns:\n            Dictionary containing python_code, script_hash, and metadata\n        \"\"\"\n        try:\n            if progress_callback:\n                progress_callback('generator_init', {\n                    'message': 'ðŸŽ¨ Generator Agent: Parsing automation plan...'\n                })\n            \n            # Parse the YAML plan\n            plan = yaml.safe_load(plan_yaml)\n            \n            logger.info(f\"ðŸŽ¨ Generator Agent: Generating Python script for '{plan.get('goal', 'Unknown')}'\")\n            \n            if progress_callback:\n                progress_callback('generator_building', {\n                    'message': 'ðŸŽ¨ Generator Agent: Building production-ready Python code...'\n                })\n            \n            # Generate the Python code using LLM\n            python_code = self._generate_with_llm(plan)\n            \n            # Calculate script hash for versioning\n            script_hash = hashlib.sha256(python_code.encode()).hexdigest()\n            \n            if progress_callback:\n                progress_callback('generator_complete', {\n                    'message': 'ðŸŽ¨ Generator Agent: Python script generated successfully!',\n                    'lines': len(python_code.split('\\n'))\n                })\n            \n            logger.info(\"âœ… Generator Agent: Successfully generated Python Playwright script\")\n            \n            return {\n                'python_code': python_code,\n                'script_hash': script_hash,\n                'metadata': json.dumps({\n                    'lines_of_code': len(python_code.split('\\n')),\n                    'plan_steps': len(plan.get('steps', [])),\n                    'generated_at': datetime.utcnow().isoformat()\n                })\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Generator Agent error: {e}\", exc_info=True)\n            raise\n    \n    def _generate_with_llm(self, plan: Dict) -> str:\n        \"\"\"Generate Python code using LLM\"\"\"\n        \n        prompt = self._build_generation_prompt(plan)\n        \n        response = self.llm_client.chat.completions.create(\n            model=self.model,\n            max_tokens=8192,\n            temperature=0.1,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": prompt\n                }\n            ]\n        )\n        \n        # Extract code from response\n        code = self._extract_python_code(response)\n        \n        return code\n    \n    def _build_generation_prompt(self, plan: Dict) -> str:\n        \"\"\"Build prompt for code generation\"\"\"\n        plan_yaml = yaml.dump(plan, default_flow_style=False)\n        \n        # Extract validated locators from plan\n        validated_locators = self._extract_validated_locators_info(plan)\n        \n        return f\"\"\"Generate Python Playwright script from plan. Use validated locators when available, otherwise derive strict-mode locators from element metadata.\n\n```yaml\n{plan_yaml}\n```\n\nLOCATOR STATUS (prefer 'validated' status locators):\n{validated_locators}\n\nRequirements: async/await, try/except, retry logic (3x), logging, timeouts, strict-mode locators, comments. Template:\n```python\nimport asyncio\nimport logging\nfrom playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeout\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nasync def retry_async(func, max_retries=3, delay=1.0):\n    \\\"\\\"\\\"Retry helper for flaky operations\\\"\\\"\\\"\n    for attempt in range(max_retries):\n        try:\n            return await func()\n        except Exception as e:\n            if attempt == max_retries - 1:\n                raise\n            logger.warning(f\"Attempt {{attempt + 1}} failed: {{e}}, retrying...\")\n            await asyncio.sleep(delay)\n\n\nasync def main():\n    \\\"\\\"\\\"Main automation function\\\"\\\"\\\"\n    async with async_playwright() as p:\n        # Launch browser\n        logger.info(\"Launching browser...\")\n        browser = await p.chromium.launch(headless=False)\n        \n        try:\n            # Create context with viewport\n            context = await browser.new_context(\n                viewport={{'width': 1280, 'height': 720}}\n            )\n            page = await context.new_page()\n            \n            # Set default timeout\n            page.set_default_timeout(30000)\n            \n            # Execute automation steps\n            logger.info(\"Starting automation...\")\n            \n            # [GENERATED STEPS GO HERE]\n            \n            logger.info(\"âœ… Automation completed successfully\")\n            \n        except PlaywrightTimeout as e:\n            logger.error(f\"âŒ Timeout error: {{e}}\")\n            raise\n        except Exception as e:\n            logger.error(f\"âŒ Automation failed: {{e}}\")\n            raise\n        finally:\n            # Cleanup\n            await browser.close()\n            logger.info(\"Browser closed\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\nIMPORTANT RULES:\n1. PREFER validated locators (validation_status='validated') - these are production-ready\n2. For unvalidated steps, use the best available locator strategy from the element data\n3. If no locator is provided, generate one using Playwright's get_by_role/get_by_text methods based on element attributes\n4. Use strict-mode compatible methods: get_by_role(), get_by_test_id(), get_by_label(), get_by_text()\n5. Avoid brittle selectors: no nth-child(), no numeric indices, no hashed class names\n6. Include full error handling, retry logic, and logging\n7. Make script ready to execute immediately\n8. CRITICAL: Locator creation is NOT async - NEVER use 'await' when creating locators\n   âŒ WRONG: button = await page.get_by_role('button', name='Submit')\n   âœ… CORRECT: button = page.get_by_role('button', name='Submit')\n   Only await the ACTION on the locator: await button.click()\n\nGenerate complete, production-ready script with robust locators.\"\"\"\n    \n    def _extract_validated_locators_info(self, plan: Dict) -> str:\n        \"\"\"Extract and format validated locators information from plan\"\"\"\n        locators_info = []\n        \n        steps = plan.get('steps', [])\n        for step in steps:\n            if 'element' not in step:\n                continue\n            \n            element_data = step.get('element', {})\n            if not isinstance(element_data, dict):\n                continue\n            \n            step_num = step.get('step_number', '?')\n            action = step.get('action', 'unknown')\n            locator = element_data.get('locator', 'NOT SPECIFIED')\n            validation_status = element_data.get('validation_status', 'unknown')\n            validation_reason = element_data.get('validation_reason', '')\n            \n            locators_info.append(\n                f\"Step {step_num} ({action}): {locator}\"\n                f\" [status: {validation_status}, reason: {validation_reason}]\"\n            )\n        \n        if not locators_info:\n            return \"No element interactions in this plan.\"\n        \n        return \"\\n\".join(locators_info)\n    \n    def _extract_python_code(self, response) -> str:\n        \"\"\"Extract Python code from LLM response\"\"\"\n        import re\n        \n        # Get text content from OpenAI response\n        text = response.choices[0].message.content if response.choices[0].message.content else \"\"\n        \n        # Look for Python code blocks\n        python_pattern = r'```python\\s*\\n(.*?)\\n```'\n        matches = re.findall(python_pattern, text, re.DOTALL)\n        \n        if matches:\n            return matches[0].strip()\n        \n        # If no code block found, try to extract code directly\n        # Look for lines that start with import or async def\n        lines = text.split('\\n')\n        code_started = False\n        code_lines = []\n        \n        for line in lines:\n            if line.startswith(('import ', 'from ', 'async def', 'def ', '#')):\n                code_started = True\n            if code_started:\n                code_lines.append(line)\n        \n        if code_lines:\n            return '\\n'.join(code_lines).strip()\n        \n        # Fallback: return the entire text\n        return text.strip()\n    \n    def generate_action_handler_code(self, action: str, element_data: Dict, value: Optional[str] = None) -> str:\n        \"\"\"\n        Generate Python code for a specific action\n        \n        Args:\n            action: Action type (click, fill, select, etc.)\n            element_data: Element information from plan\n            value: Optional value for fill/select actions\n            \n        Returns:\n            Python code string for the action\n        \"\"\"\n        locator = element_data.get('locator', 'page.locator(\"body\")')\n        \n        handlers = {\n            'click': f'await retry_async(lambda: {locator}.click())',\n            'fill': f'await {locator}.fill(\"{value or \"\"}\")',\n            'press': f'await {locator}.press(\"{value or \"Enter\"}\")',\n            'select': f'await {locator}.select_option(value=\"{value or \"\"}\")',\n            'check': f'await {locator}.check()',\n            'uncheck': f'await {locator}.uncheck()',\n            'hover': f'await {locator}.hover()',\n            'double_click': f'await retry_async(lambda: {locator}.dblclick())',\n            'right_click': f'await {locator}.click(button=\"right\")',\n            'extract_text': f'text = await {locator}.inner_text()',\n            'extract_value': f'value = await {locator}.input_value()',\n            'wait_visible': f'await {locator}.wait_for(state=\"visible\")',\n            'wait_hidden': f'await {locator}.wait_for(state=\"hidden\")',\n        }\n        \n        return handlers.get(action, f'# Unknown action: {action}')\n","size_bytes":11094},"app/__init__.py":{"content":"\"\"\"\nFlask Application Factory\n\"\"\"\nimport os\nimport logging\nimport sys\nimport atexit\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\n# PRIVACY: Disable all external data transmission from browser-use library\n# Set these BEFORE importing any browser-use components\nos.environ.setdefault('ANONYMIZED_TELEMETRY', 'false')\nos.environ.setdefault('BROWSER_USE_CLOUD_SYNC', 'false')\n\nfrom flask import Flask\nfrom flask_cors import CORS\nfrom app.models import db\nfrom app.services.engine_orchestrator import EngineOrchestrator\nfrom app.routes.api import create_api_routes\nfrom app.utils.logging_config import LoggingConfigurator\n\n\ndef create_app():\n    \"\"\"\n    Create and configure the Flask application\n    \n    Returns:\n        Configured Flask app instance\n    \"\"\"\n    # Configure logging from config.ini\n    logging_config = LoggingConfigurator()\n    logging_config.configure()\n    \n    logger = logging.getLogger(__name__)\n    logger.info(\"ðŸš€ Starting AI Browser Automation application\")\n    \n    # Log privacy settings confirmation\n    telemetry_status = os.environ.get('ANONYMIZED_TELEMETRY', 'not set')\n    cloud_sync_status = os.environ.get('BROWSER_USE_CLOUD_SYNC', 'not set')\n    logger.info(\"=\" * 80)\n    logger.info(\"ðŸ”’ PRIVACY SETTINGS\")\n    logger.info(\"=\" * 80)\n    logger.info(f\"Anonymized Telemetry: {telemetry_status} (should be 'false')\")\n    logger.info(f\"Cloud Sync: {cloud_sync_status} (should be 'false')\")\n    if telemetry_status.lower()[:1] in 'ty1' or cloud_sync_status.lower()[:1] in 'ty1':\n        logger.warning(\"âš ï¸  WARNING: External data transmission may be ENABLED!\")\n        logger.warning(\"âš ï¸  Set ANONYMIZED_TELEMETRY=false and BROWSER_USE_CLOUD_SYNC=false\")\n    else:\n        logger.info(\"âœ… All external data transmission DISABLED\")\n        logger.info(\"âœ… No telemetry or cloud sync - data stays on your system\")\n    logger.info(\"=\" * 80)\n    \n    app = Flask(__name__)\n    \n    # Session secret key - MUST be set in production\n    session_secret = os.environ.get(\"SESSION_SECRET\")\n    if not session_secret:\n        # Generate ephemeral random key for local development only\n        import secrets\n        session_secret = secrets.token_hex(32)\n        logger.warning(\"âš ï¸  SESSION_SECRET not set! Using ephemeral random key for local dev.\")\n        logger.warning(\"âš ï¸  Set SESSION_SECRET environment variable for production!\")\n    \n    app.config['SECRET_KEY'] = session_secret\n    \n    # Use SQLite database\n    app.config[\"SQLALCHEMY_DATABASE_URI\"] = \"sqlite:///automation_history.db\"\n    logger.info(\"ðŸ“ Using SQLite database\")\n    app.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n        \"pool_recycle\": 300,\n        \"pool_pre_ping\": True,\n    }\n    \n    db.init_app(app)\n    \n    with app.app_context():\n        db.create_all()\n        logger.info(\"âœ… Database initialized successfully\")\n    \n    allowed_origins = os.environ.get('CORS_ALLOWED_ORIGINS', '*').split(',')\n    CORS(app, \n         resources={r\"/api/*\": {\"origins\": allowed_origins}},\n         methods=[\"GET\", \"POST\", \"OPTIONS\", \"DELETE\"],\n         allow_headers=[\"Content-Type\", \"X-API-Key\"],\n         supports_credentials=True)\n    \n    logger.info(f\"ðŸ”’ CORS configured with origins: {allowed_origins}\")\n    logger.info(\"ðŸ“¦ Initializing Engine Orchestrator\")\n    orchestrator = EngineOrchestrator()\n    \n    logger.info(\"ðŸ”— Registering API routes\")\n    api_routes = create_api_routes(orchestrator)\n    app.register_blueprint(api_routes)\n    \n    # Add cache control headers to prevent browser caching issues\n    @app.after_request\n    def add_cache_control_headers(response):\n        \"\"\"Add Cache-Control headers to all responses to prevent caching\"\"\"\n        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, public, max-age=0'\n        response.headers['Pragma'] = 'no-cache'\n        response.headers['Expires'] = '0'\n        return response\n    \n    # Handle favicon request to prevent 404 errors\n    @app.route('/favicon.ico')\n    def favicon():\n        \"\"\"Return 204 No Content for favicon requests\"\"\"\n        from flask import Response\n        return Response(status=204)\n    \n    # Serve automation outputs (screenshots, PDFs, etc.)\n    @app.route('/automation_outputs/<path:filename>')\n    def serve_automation_outputs(filename):\n        \"\"\"Serve files from automation_outputs directory (legacy)\"\"\"\n        from flask import send_from_directory\n        import os\n        output_dir = os.path.join(project_root, 'automation_outputs')\n        return send_from_directory(output_dir, filename)\n    \n    # Serve screenshots from automation_outputs/screenshots folder\n    @app.route('/screenshots/<path:filename>')\n    def serve_screenshots(filename):\n        \"\"\"Serve files from screenshots directory\"\"\"\n        from flask import send_from_directory\n        import os\n        screenshots_dir = os.path.join(project_root, 'automation_outputs', 'screenshots')\n        # Create directory if it doesn't exist\n        os.makedirs(screenshots_dir, exist_ok=True)\n        return send_from_directory(screenshots_dir, filename)\n    \n    # Register cleanup handler for MCP server on app shutdown\n    def cleanup_mcp_server():\n        \"\"\"Cleanup handler for persistent MCP server\"\"\"\n        try:\n            from app.engines.playwright_mcp import shutdown_server, get_server_status\n            status = get_server_status()\n            if status['persistent_running']:\n                logger.info(\"ðŸ§¹ Shutting down persistent MCP server on app exit...\")\n                shutdown_server()\n                logger.info(\"âœ… MCP server cleanup complete\")\n        except Exception as e:\n            logger.error(f\"âš ï¸  Error during MCP server cleanup: {e}\")\n    \n    atexit.register(cleanup_mcp_server)\n    \n    logger.info(\"âœ… Application initialization complete\")\n    \n    return app\n","size_bytes":6017},"app/engines/playwright_mcp/agents/healer_agent.py":{"content":"\"\"\"\nHealer Agent\nAnalyzes Playwright trace files and automatically patches failing Python scripts\n\"\"\"\nimport logging\nimport json\nimport re\nimport hashlib\nfrom typing import Dict, Any, Optional, List\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\n\nclass HealerAgent:\n    \"\"\"\n    Healer Agent that analyzes trace files from failed executions\n    and automatically patches Python Playwright scripts with fixes\n    \"\"\"\n    \n    def __init__(self, llm_client, model='gpt-4.1-2025-04-14-eastus-dz'):\n        \"\"\"\n        Initialize Healer Agent\n        \n        Args:\n            llm_client: LLM client for intelligent healing\n            model: Model name to use for healing\n        \"\"\"\n        self.llm_client = llm_client\n        self.model = model\n    \n    def heal_script(\n        self,\n        python_code: str,\n        error_message: str,\n        trace_path: Optional[str] = None,\n        max_iterations: int = 3,\n        progress_callback=None\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Heal a failing Python script by analyzing errors and applying fixes\n        \n        Args:\n            python_code: Original failing Python code\n            error_message: Error message from failed execution\n            trace_path: Optional path to Playwright trace file\n            max_iterations: Maximum healing iterations\n            progress_callback: Optional callback for progress updates\n            \n        Returns:\n            Dictionary containing healed_code, healing_iterations, and fixes_applied\n        \"\"\"\n        try:\n            if progress_callback:\n                progress_callback('healer_init', {\n                    'message': 'ðŸ”§ Healer Agent: Analyzing failure...',\n                    'error': error_message[:200]\n                })\n            \n            logger.info(f\"ðŸ”§ Healer Agent: Starting script healing (max {max_iterations} iterations)\")\n            \n            current_code = python_code\n            healing_iteration = 0\n            fixes_applied = []\n            \n            while healing_iteration < max_iterations:\n                healing_iteration += 1\n                \n                if progress_callback:\n                    progress_callback('healer_analyzing', {\n                        'message': f'ðŸ”§ Healer Agent: Iteration {healing_iteration}/{max_iterations}...',\n                        'iteration': healing_iteration\n                    })\n                \n                logger.info(f\"ðŸ”§ Healing iteration {healing_iteration}/{max_iterations}\")\n                \n                # Analyze the error and generate a fix\n                analysis = self._analyze_error(current_code, error_message, trace_path)\n                \n                if not analysis.get('fixable', False):\n                    logger.warning(\"âš ï¸ Healer: Error appears to be unfixable\")\n                    if progress_callback:\n                        progress_callback('healer_unfixable', {\n                            'message': 'âš ï¸ Healer: Cannot automatically fix this error',\n                            'reason': analysis.get('reason', 'Unknown')\n                        })\n                    break\n                \n                # Apply the fix\n                healed_code = self._apply_fix(current_code, analysis)\n                \n                if healed_code == current_code:\n                    logger.warning(\"âš ï¸ Healer: No changes made, stopping\")\n                    break\n                \n                fix_description = analysis.get('fix_description', 'Unknown fix')\n                fixes_applied.append({\n                    'iteration': healing_iteration,\n                    'type': analysis.get('error_type', 'unknown'),\n                    'description': fix_description\n                })\n                \n                logger.info(f\"âœ… Applied fix: {fix_description}\")\n                \n                current_code = healed_code\n                \n                # In a real implementation, we would re-run the script here\n                # For now, we'll stop after one successful fix\n                break\n            \n            script_hash = hashlib.sha256(current_code.encode()).hexdigest()\n            \n            if progress_callback:\n                progress_callback('healer_complete', {\n                    'message': f'ðŸ”§ Healer Agent: Healing complete ({len(fixes_applied)} fixes applied)',\n                    'fixes': len(fixes_applied)\n                })\n            \n            logger.info(f\"âœ… Healer Agent: Completed with {len(fixes_applied)} fixes\")\n            \n            return {\n                'healed_code': current_code,\n                'script_hash': script_hash,\n                'healing_iterations': healing_iteration,\n                'fixes_applied': json.dumps(fixes_applied),\n                'success': len(fixes_applied) > 0\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Healer Agent error: {e}\", exc_info=True)\n            raise\n    \n    def _analyze_error(\n        self,\n        code: str,\n        error_message: str,\n        trace_path: Optional[str]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Analyze error and determine if it's fixable\n        \n        Returns:\n            Dictionary with error analysis and fix strategy\n        \"\"\"\n        \n        # Quick pattern-based fixes for common errors\n        common_fixes = self._check_common_errors(error_message)\n        if common_fixes:\n            return common_fixes\n        \n        # Use LLM for complex error analysis\n        return self._analyze_with_llm(code, error_message, trace_path)\n    \n    def _check_common_errors(self, error_message: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Check for common, easily fixable errors\"\"\"\n        \n        # Timeout errors\n        if 'timeout' in error_message.lower() or 'timed out' in error_message.lower():\n            return {\n                'fixable': True,\n                'error_type': 'timeout',\n                'fix_description': 'Increase timeout duration',\n                'fix_strategy': 'increase_timeout'\n            }\n        \n        # Locator not found errors\n        if 'locator' in error_message.lower() and ('not found' in error_message.lower() or 'no element' in error_message.lower()):\n            return {\n                'fixable': True,\n                'error_type': 'locator_not_found',\n                'fix_description': 'Update locator strategy',\n                'fix_strategy': 'fix_locator'\n            }\n        \n        # Element not visible/attached\n        if 'not visible' in error_message.lower() or 'not attached' in error_message.lower():\n            return {\n                'fixable': True,\n                'error_type': 'element_state',\n                'fix_description': 'Add wait for element visibility',\n                'fix_strategy': 'wait_for_visible'\n            }\n        \n        # Multiple elements matched\n        if 'strict mode violation' in error_message.lower() or 'multiple elements' in error_message.lower():\n            return {\n                'fixable': True,\n                'error_type': 'multiple_matches',\n                'fix_description': 'Add .first() or .nth() to locator',\n                'fix_strategy': 'strict_mode_fix'\n            }\n        \n        return None\n    \n    def _analyze_with_llm(\n        self,\n        code: str,\n        error_message: str,\n        trace_path: Optional[str]\n    ) -> Dict[str, Any]:\n        \"\"\"Use LLM to analyze complex errors\"\"\"\n        \n        prompt = f\"\"\"Analyze Playwright error:\n\nScript:\n```python\n{code}\n```\n\nError:\n```\n{error_message}\n```\n\n{f\"Trace: {trace_path}\" if trace_path else \"\"}\n\nJSON response:\n{{\"fixable\": bool, \"error_type\": \"timeout|locator|network|state\", \"fix_description\": \"...\", \"fix_strategy\": \"increase_timeout|fix_locator|add_wait|strict_mode\", \"reason\": \"...\"}}\"\"\"\n        \n        response = self.llm_client.chat.completions.create(\n            model=self.model,\n            max_tokens=1024,\n            temperature=0.1,\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n        \n        # Extract JSON from response\n        text = response.choices[0].message.content if response.choices[0].message.content else \"\"\n        \n        try:\n            # Extract JSON from code blocks or directly\n            json_pattern = r'```json\\s*\\n(.*?)\\n```'\n            matches = re.findall(json_pattern, text, re.DOTALL)\n            \n            if matches:\n                return json.loads(matches[0])\n            else:\n                return json.loads(text)\n        except Exception as e:\n            logger.error(f\"Failed to parse LLM analysis: {e}\")\n            return {\n                'fixable': False,\n                'error_type': 'unknown',\n                'reason': 'Failed to analyze error'\n            }\n    \n    def _apply_fix(self, code: str, analysis: Dict[str, Any]) -> str:\n        \"\"\"Apply fix to code based on analysis\"\"\"\n        \n        fix_strategy = analysis.get('fix_strategy', '')\n        \n        if fix_strategy == 'increase_timeout':\n            return self._fix_timeout(code)\n        elif fix_strategy == 'fix_locator':\n            return self._fix_locator(code, analysis)\n        elif fix_strategy == 'wait_for_visible':\n            return self._add_wait_for_visible(code)\n        elif fix_strategy == 'strict_mode_fix':\n            return self._fix_strict_mode(code)\n        else:\n            # Use LLM to generate the fix\n            return self._apply_fix_with_llm(code, analysis)\n    \n    def _fix_timeout(self, code: str) -> str:\n        \"\"\"Increase timeout values in code\"\"\"\n        # Increase page.set_default_timeout\n        code = re.sub(\n            r'page\\.set_default_timeout\\((\\d+)\\)',\n            lambda m: f'page.set_default_timeout({int(m.group(1)) * 2})',\n            code\n        )\n        \n        # Increase specific timeout parameters\n        code = re.sub(\n            r'timeout=(\\d+)',\n            lambda m: f'timeout={int(m.group(1)) * 2}',\n            code\n        )\n        \n        return code\n    \n    def _fix_strict_mode(self, code: str) -> str:\n        \"\"\"Add .first() to locators that might match multiple elements\"\"\"\n        # Find locator calls without .first() or .nth()\n        pattern = r'(page\\.(get_by_\\w+|locator)\\([^)]+\\))(?!\\.(?:first|nth|count|all)\\(\\))'\n        \n        def add_first(match):\n            locator = match.group(1)\n            # Don't add .first() to simple getters like get_by_test_id\n            if 'get_by_test_id' in locator or 'get_by_label' in locator:\n                return locator\n            return f\"{locator}.first()\"\n        \n        return re.sub(pattern, add_first, code)\n    \n    def _add_wait_for_visible(self, code: str) -> str:\n        \"\"\"Add wait_for visibility checks before interactions\"\"\"\n        # This is complex - for now, just add a delay\n        # In real implementation, would parse AST and add waits\n        return code\n    \n    def _fix_locator(self, code: str, analysis: Dict[str, Any]) -> str:\n        \"\"\"Fix broken locators\"\"\"\n        # This would require more sophisticated analysis\n        # For now, return unchanged\n        return code\n    \n    def _apply_fix_with_llm(self, code: str, analysis: Dict[str, Any]) -> str:\n        \"\"\"Use LLM to apply complex fixes\"\"\"\n        \n        prompt = f\"\"\"Fix this script based on the analysis:\n\nCode:\n```python\n{code}\n```\n\nAnalysis:\n```json\n{json.dumps(analysis)}\n```\n\nReturn the fixed Python code only.\"\"\"\n        \n        response = self.llm_client.chat.completions.create(\n            model=self.model,\n            max_tokens=8192,\n            temperature=0.1,\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n        \n        # Extract code from OpenAI response\n        text = response.choices[0].message.content if response.choices[0].message.content else \"\"\n        \n        # Extract Python code block\n        python_pattern = r'```python\\s*\\n(.*?)\\n```'\n        matches = re.findall(python_pattern, text, re.DOTALL)\n        \n        if matches:\n            return matches[0].strip()\n        \n        return code  # Return unchanged if fix failed\n","size_bytes":12169},"app/engines/playwright_mcp/agent/conversation_agent.py":{"content":"\"\"\"\nOpenAI-powered Browser Agent\nInterprets natural language instructions and executes browser actions\nUses direct execution mode for browser automation tasks\nIncludes three-agent workflow for Playwright Python code generation\n\"\"\"\nimport json\nimport os\nimport logging\nimport time\nimport configparser\nfrom pathlib import Path\nfrom typing import List, Dict, Any, Optional\nfrom dotenv import load_dotenv\nfrom openai import OpenAI\nfrom auth.oauth_handler import get_oauth_token_with_retry\nfrom app.utils.logging_config import (\n    should_log_llm_requests, \n    should_log_llm_responses,\n    should_log_browser_actions,\n    should_log_page_state,\n    should_log_performance\n)\n# Import three-agent system\nfrom app.engines.playwright_mcp.agents import (\n    StrictModeLocatorEngine,\n    PlannerAgent,\n    GeneratorAgent,\n    HealerAgent\n)\n# Load .env file from project root with explicit path\nproject_root = Path(__file__).parent.parent.parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\n\nclass BrowserAgent:\n    \"\"\"\n    AI agent that performs browser automation based on natural language instructions\n    \n    Uses direct execution mode to control browsers via Playwright MCP tools\n    \"\"\"\n    \n    def __init__(self, mcp_client: Any, workspace_root: str = \".\"):\n        \"\"\"\n        Initialize the Browser Agent\n        \n        Args:\n            mcp_client: MCP client for browser automation\n            workspace_root: Root directory for specs/ and tests/ (default: current directory)\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        self.mcp_client = mcp_client\n        \n        gateway_base_url = os.environ.get('GW_BASE_URL')\n        if not gateway_base_url:\n            raise ValueError(\"GW_BASE_URL must be set as environment variable to connect to the gateway endpoint.\")\n        \n        try:\n            oauth_token = get_oauth_token_with_retry(max_retries=3)\n        except Exception as e:\n            raise ValueError(f\"Failed to obtain OAuth token: {str(e)}. Please check your OAuth configuration.\")\n        \n        self.client = OpenAI(\n            base_url=gateway_base_url,\n            api_key=oauth_token,\n            default_headers={\n                \"Authorization\": f\"Bearer {oauth_token}\"\n            }\n        )\n        self.model = config.get('openai', 'model', fallback='gpt-4.1-2025-04-14-eastus-dz')\n        self.conversation_history = []\n        self.max_iterations = config.getint('agent', 'max_steps', fallback=40)\n        \n        # Expose chat_model for Planner/Generator agents to access\n        self.chat_model = self.client\n        \n        # Logging configuration\n        self.logger = logging.getLogger(__name__)\n        self.log_llm_requests = should_log_llm_requests()\n        self.log_llm_responses = should_log_llm_responses()\n        self.log_browser_actions = should_log_browser_actions()\n        self.log_page_state = should_log_page_state()\n        self.log_performance = should_log_performance()\n        \n        # Store gateway URL for logging\n        self.gateway_base_url = gateway_base_url\n        \n        # Verification keywords to detect validation requirements\n        self.verification_keywords = [\n            'verify', 'check', 'ensure', 'validate', 'assert', \n            'confirm', 'test', 'must', 'should contain', 'should have',\n            'expect', 'required', 'make sure', 'assert that'\n        ]\n        \n        # Initialize three-agent system for Python code generation\n        self.locator_engine = StrictModeLocatorEngine(mcp_client=self.mcp_client)\n        self.planner_agent = PlannerAgent(\n            mcp_client=self.mcp_client,\n            llm_client=self.client,\n            locator_engine=self.locator_engine,\n            model=self.model\n        )\n        self.generator_agent = GeneratorAgent(\n            llm_client=self.client,\n            locator_engine=self.locator_engine,\n            model=self.model\n        )\n        self.healer_agent = HealerAgent(llm_client=self.client, model=self.model)\n        \n        # Code generation mode controls workflow behavior\n        # False: Direct execution (fast, no code generation)\n        # True: Integrated workflow (Plan â†’ Generate â†’ Execute â†’ Heal)\n        self.generate_python_code = True\n        \n        # Execution strategy\n        # \"direct\": BrowserAgent directly controls browser (no code gen)\n        # \"code_first\": Plan â†’ Generate code â†’ Execute code â†’ Heal if needed\n        self.execution_strategy = \"code_first\"\n        \n        \n    def _has_verification_requirements(self, instruction: str) -> bool:\n        \"\"\"\n        Check if the instruction contains verification/validation requirements\n        \n        Args:\n            instruction: User's instruction\n            \n        Returns:\n            True if instruction contains verification keywords\n        \"\"\"\n        instruction_lower = instruction.lower()\n        return any(keyword in instruction_lower for keyword in self.verification_keywords)\n    \n    def _check_verification_failure(self, final_message: str, steps: List[Dict], instruction: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Check if verification failed based on final message and steps\n        \n        Args:\n            final_message: Final message from LLM\n            steps: List of executed steps\n            instruction: Original instruction\n            \n        Returns:\n            Dict with verification failure info if detected, None otherwise\n        \"\"\"\n        if not final_message:\n            return None\n        \n        message_lower = final_message.lower()\n        \n        # First check for explicit success indicators - if found, verification passed\n        success_indicators = [\n            'verification passed', 'check passed', 'verified successfully',\n            'validation passed', 'assertion passed', 'confirmed successfully'\n        ]\n        if any(indicator in message_lower for indicator in success_indicators):\n            return None  # Verification explicitly passed\n        \n        # More specific failure indicators to avoid false positives\n        failure_indicators = [\n            'verification failed', 'check failed', 'assertion failed',\n            'validation failed', 'not found', 'does not exist',\n            'could not find', 'unable to find', 'did not find',\n            'missing element', 'element missing', 'cannot locate',\n            'no such element', 'not present on', 'not visible',\n            'failed to verify', 'failed to validate', 'failed to confirm'\n        ]\n        \n        has_verification = self._has_verification_requirements(instruction)\n        has_failure = any(indicator in message_lower for indicator in failure_indicators)\n        \n        if has_verification and has_failure:\n            return {\n                'verification_failed': True,\n                'reason': final_message[:300],  # Limit length\n                'instruction': instruction,\n                'completed_steps': len(steps)\n            }\n        \n        return None\n    \n    def execute_instruction(self, instruction: str, mode: str = \"direct\", progress_callback=None) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            mode: Must be \"direct\" (other modes have been removed)\n            progress_callback: Optional callback for progress updates\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        # Only direct mode is supported now\n        if mode != \"direct\":\n            return {\n                \"success\": False,\n                \"error\": f\"Invalid mode: {mode}\",\n                \"message\": \"Only 'direct' mode is supported. Other modes have been removed.\",\n                \"mode\": mode\n            }\n        \n        # Route based on execution strategy\n        if self.execution_strategy == \"code_first\":\n            return self._execute_code_first_mode(instruction, progress_callback)\n        else:\n            return self._execute_direct_mode(instruction, progress_callback)\n    \n    \n    def _execute_direct_mode(self, instruction: str, progress_callback=None) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            progress_callback: Optional callback for progress updates\n            \n        Returns:\n            Dictionary with execution results and steps taken\n        \"\"\"\n        # Send init progress\n        if progress_callback:\n            progress_callback('init', {'message': 'Initializing Playwright MCP agent...', 'instruction': instruction})\n        \n        if not self.mcp_client.initialized:\n            self.mcp_client.initialize()\n        \n        # Send browser init progress\n        if progress_callback:\n            progress_callback('browser_init', {'message': 'Playwright MCP server ready...'})\n        \n        tools = self.mcp_client.get_tools_schema()\n        \n        # Send agent create progress\n        if progress_callback:\n            progress_callback('agent_create', {'message': 'Creating AI conversation agent...'})\n        \n        self.conversation_history = [\n            {\n                \"role\": \"system\",\n                \"content\": \"\"\"You are an intelligent browser automation assistant that follows a structured OBSERVEâ†’REASONâ†’ACTâ†’VERIFY workflow.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nðŸŽ¯ CORE WORKFLOW (MANDATORY)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nFor EVERY task, you MUST follow this cycle:\n\n1. **OBSERVE** - Gather context BEFORE acting\n   - If task specifies a URL: browser_navigate to it, THEN immediately browser_snapshot\n   - If task doesn't specify URL: Start with browser_snapshot to see current page\n   - You must have a snapshot showing elements before any interaction (clicks, fills, etc.)\n   - Use browser_snapshot to inspect page structure and identify available elements\n\n2. **REASON** - Think before you act\n   - State your THOUGHT: explain your plan for the next 1-3 steps\n   - Identify which elements you'll interact with (using [ref=eN] from snapshots)\n   - Anticipate what should happen after your action\n\n3. **ACT** - Execute ONE focused action\n   - Use the appropriate tool based on your reasoning\n   - Reference elements from snapshots using [ref=eN] notation\n   - Wait for action to complete before next OBSERVE\n\n4. **VERIFY** - Confirm the action succeeded\n   - After critical actions, take another snapshot to verify state changed as expected\n   - For verification tasks (with keywords: verify, check, ensure, validate, assert, confirm), \n     you MUST actively check the condition using browser_snapshot or browser_text\n   - Report clear success/failure: \"Verification passed: [what was confirmed]\" OR \"Verification failed: [specific reason]\"\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nðŸ› ï¸ TOOL SELECTION GUIDE\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nUse this decision table to choose the right tool:\n\n| WHEN TO USE                           | TOOL                    | EXAMPLE                                    |\n|---------------------------------------|-------------------------|---------------------------------------------|\n| Starting task, going to URL           | browser_navigate        | browser_navigate(url=\"https://example.com\")|\n| Need to see page structure/elements   | browser_snapshot        | browser_snapshot()                         |\n| Click button/link/element             | browser_click           | browser_click(element_ref=\"[ref=e3]\")      |\n| Type into input field                 | browser_fill            | browser_fill(element_ref=\"[ref=e5]\", value=\"text\") |\n| Select from native <select> dropdown  | browser_select          | browser_select(element_ref=\"[ref=e2]\", value=\"option1\") |\n| Extract visible text from element     | browser_text            | browser_text(element_ref=\"[ref=e7]\")       |\n| Get element attributes (href, src)    | browser_attribute       | browser_attribute(element_ref=\"[ref=e4]\", name=\"href\") |\n| Scroll page or element                | browser_scroll          | browser_scroll(direction=\"down\", amount=500)|\n| Hover over element                    | browser_hover           | browser_hover(element_ref=\"[ref=e6]\")      |\n| Press keyboard key (Enter, Tab, etc)  | browser_press           | browser_press(key=\"Enter\")                 |\n| Wait for page to load/settle          | browser_wait            | browser_wait(milliseconds=1000)            |\n| Take screenshot (debugging only)      | browser_screenshot      | browser_screenshot()                       |\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nðŸ” ELEMENT REFERENCES\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nWhen you call browser_snapshot, you'll receive YAML with elements like:\n```\nelements:\n  - ref: e1\n    tag: button\n    text: \"Submit\"\n    aria_label: \"Submit form\"\n```\n\nALWAYS use the [ref=eN] notation when calling action tools:\nâœ… CORRECT: browser_click(element_ref=\"[ref=e1]\")\nâŒ WRONG: browser_click(element_ref=\"Submit button\")\nâŒ WRONG: browser_click(element_ref=\"e1\")\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâš™ï¸ DROPDOWN HANDLING (Advanced)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n**Native HTML <select>**: Use browser_select directly with value/label/index\n**Custom JS dropdowns** (Material-UI, Ant Design, etc):\n   1. browser_click to open â†’ 2. browser_wait briefly â†’ 3. browser_snapshot to see options â†’ 4. browser_click on option [ref]\n**Dropdown with search**: browser_click to open â†’ browser_fill to search â†’ browser_snapshot â†’ browser_click on result\n**Long lists**: Use browser_scroll within dropdown if needed, or prefer search/filter\n**Multi-select**: Click each option, don't close dropdown until all selected\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nðŸš¨ ERROR HANDLING & RECOVERY\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nIf a tool call FAILS or returns an error:\n1. Take a browser_snapshot to reassess the current page state\n2. STATE YOUR THOUGHT about what went wrong and your recovery plan\n3. Try an alternative approach (different element, different tool, wait first)\n4. If element not found: browser_scroll to find it, or browser_wait for it to load\n5. If stuck after 3 attempts: clearly report the failure with specific reason\n\nCommon recoveries:\n- \"Element not found\" â†’ Take snapshot, verify element exists, try different ref\n- \"Click failed\" â†’ Try browser_hover first, then browser_click\n- \"Page didn't load\" â†’ Use browser_wait, then browser_snapshot to confirm\n- \"Dropdown not opening\" â†’ Try browser_hover before browser_click\n- \"Network timeout\" â†’ browser_wait longer, then retry navigation\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nâœ… TASK COMPLETION CRITERIA\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nBefore declaring task complete:\n1. Have you completed ALL steps requested by the user?\n2. Have you VERIFIED the final state (if verification keywords present)?\n3. Have you confirmed success with browser_snapshot or browser_text?\n\nOnly then respond with your completion message (no more tool calls).\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nðŸ“‹ EXAMPLE WORKFLOW\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nUser: \"Go to example.com and search for 'playwright'\"\n\nTHOUGHT: I need to navigate to example.com, observe the page structure, find the search box, fill it, and submit.\n\n[Tool: browser_navigate(url=\"https://example.com\")]\n[Tool: browser_snapshot()]\n\nTHOUGHT: I can see element [ref=e5] is a search input. I'll fill it with 'playwright' and then look for a search button.\n\n[Tool: browser_fill(element_ref=\"[ref=e5]\", value=\"playwright\")]\n[Tool: browser_snapshot()]\n\nTHOUGHT: Element [ref=e8] is the search button. I'll click it and verify results loaded.\n\n[Tool: browser_click(element_ref=\"[ref=e8]\")]\n[Tool: browser_wait(milliseconds=1500)]\n[Tool: browser_snapshot()]\n\nTHOUGHT: Search results are now visible on the page. Task complete.\n\nResponse: \"Successfully searched for 'playwright' on example.com. Search results are now displayed.\"\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nRemember: OBSERVEâ†’REASONâ†’ACTâ†’VERIFY. Always observe first, reason about your plan, act decisively, then verify the result.\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\"\"\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": instruction\n            }\n        ]\n        \n        steps = []\n        iteration = 0\n        \n        # Send execution start progress\n        if progress_callback:\n            progress_callback('execution_start', {'message': 'Agent is now executing automation steps...'})\n        \n        while iteration < self.max_iterations:\n            iteration += 1\n            \n            try:\n                # Log LLM request details\n                if self.log_llm_requests:\n                    self.logger.debug(\"=\" * 80)\n                    self.logger.debug(f\"ðŸ“¤ LLM REQUEST (Iteration {iteration}/{self.max_iterations})\")\n                    self.logger.debug(f\"Model: {self.model}\")\n                    self.logger.debug(f\"Gateway: {self.gateway_base_url}\")\n                    self.logger.debug(f\"Messages count: {len(self.conversation_history)}\")\n                    self.logger.debug(f\"Tools available: {len(tools)}\")\n                    self.logger.debug(\"=\" * 80)\n                \n                if self.log_performance:\n                    start_time = time.time()\n                \n                response = self.client.chat.completions.create(\n                    model=self.model,\n                    messages=self.conversation_history,  # type: ignore\n                    tools=tools,\n                    tool_choice=\"auto\",\n                    max_tokens=4096\n                )\n                \n                if self.log_performance:\n                    elapsed = time.time() - start_time\n                    self.logger.debug(f\"â±ï¸  LLM response received in {elapsed:.2f}s\")\n                \n                # Log LLM response details\n                if self.log_llm_responses:\n                    self.logger.debug(\"=\" * 80)\n                    self.logger.debug(f\"ðŸ“¥ LLM RESPONSE (Iteration {iteration})\")\n                    self.logger.debug(f\"Finish reason: {response.choices[0].finish_reason}\")\n                    if response.usage:\n                        self.logger.debug(f\"Tokens - Prompt: {response.usage.prompt_tokens}, Completion: {response.usage.completion_tokens}, Total: {response.usage.total_tokens}\")\n                    self.logger.debug(\"=\" * 80)\n                \n                message = response.choices[0].message\n                self.conversation_history.append(message.model_dump())\n                \n                if message.tool_calls:\n                    for tool_call in message.tool_calls:\n                        tool_name = tool_call.function.name  # type: ignore\n                        tool_args = json.loads(tool_call.function.arguments)  # type: ignore\n                        \n                        # Concise step-based logging for key actions\n                        action_desc = self._format_action_description(tool_name, tool_args)\n                        self.logger.info(f\"Step {len(steps) + 1}: {action_desc}\")\n                        \n                        try:\n                            if self.log_performance:\n                                action_start = time.time()\n                            \n                            result = self.mcp_client.call_tool(tool_name, tool_args)\n                            \n                            if self.log_performance:\n                                action_elapsed = time.time() - action_start\n                                self.logger.debug(f\"â±ï¸  Action '{tool_name}' completed in {action_elapsed:.2f}s\")\n                            \n                            # Log action result\n                            if self.log_browser_actions:\n                                self.logger.debug(f\"âœ… Action '{tool_name}' succeeded\")\n                                if self.log_page_state and result:\n                                    self.logger.debug(f\"Result preview: {str(result)[:200]}...\")\n                            \n                            step_info = {\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": True,\n                                \"result\": result\n                            }\n                            steps.append(step_info)\n                            \n                            # Send step progress update\n                            if progress_callback:\n                                progress_callback('step', {\n                                    'step_number': len(steps),\n                                    'action': action_desc[:150],\n                                    'total_steps': len(steps)\n                                })\n                            \n                            # Capture screenshot after navigation or significant actions\n                            if tool_name in ['browser_navigate', 'browser_click', 'browser_fill']:\n                                try:\n                                    snapshot_result = self.mcp_client.call_tool('browser_snapshot', {})\n                                    if snapshot_result and isinstance(snapshot_result, dict):\n                                        screenshot_path = snapshot_result.get('screenshot_path')\n                                        if screenshot_path:\n                                            step_info['screenshot_path'] = screenshot_path\n                                            if progress_callback:\n                                                self.logger.info(f\"ðŸ“¸ Step {len(steps)} screenshot: {screenshot_path}\")\n                                                progress_callback('screenshot', {\n                                                    'path': screenshot_path,\n                                                    'url': snapshot_result.get('url', ''),\n                                                    'step_number': len(steps)\n                                                })\n                                except Exception as screenshot_error:\n                                    self.logger.warning(f\"âš ï¸  Screenshot capture failed: {screenshot_error}\")\n                            \n                            # Sanitize tool result to remove metadata fields that cause API errors\n                            sanitized_content = self._sanitize_tool_result(result)\n                            \n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": sanitized_content\n                            })\n                            \n                        except Exception as e:\n                            error_msg = str(e)\n                            \n                            # Log action failure\n                            if self.log_browser_actions:\n                                self.logger.error(\"=\" * 80)\n                                self.logger.error(f\"âŒ Action '{tool_name}' FAILED\")\n                                self.logger.error(f\"Error: {error_msg}\")\n                                self.logger.error(\"=\" * 80)\n                            \n                            steps.append({\n                                \"tool\": tool_name,\n                                \"arguments\": tool_args,\n                                \"success\": False,\n                                \"error\": error_msg\n                            })\n                            \n                            # Error messages are already plain strings, safe to use directly\n                            self.conversation_history.append({\n                                \"role\": \"tool\",\n                                \"tool_call_id\": tool_call.id,\n                                \"content\": f\"Error: {error_msg}\"\n                            })\n                else:\n                    final_response = message.content or \"Task completed\"\n                    \n                    # Check for verification failures\n                    verification_failure = self._check_verification_failure(final_response, steps, instruction)\n                    if verification_failure:\n                        self.logger.error(\"=\" * 80)\n                        self.logger.error(\"âŒ VERIFICATION FAILED\")\n                        self.logger.error(f\"Instruction: {verification_failure['instruction']}\")\n                        self.logger.error(f\"Reason: {verification_failure['reason']}\")\n                        self.logger.error(f\"Completed Steps: {verification_failure['completed_steps']}\")\n                        self.logger.error(\"=\" * 80)\n                        \n                        # Return verification failure result\n                        return {\n                            \"success\": False,\n                            \"error\": f\"Verification failed: {verification_failure['reason']}\",\n                            \"error_type\": \"VerificationError\",\n                            \"verification_failed\": True,\n                            \"verification_details\": verification_failure,\n                            \"message\": final_response,\n                            \"steps\": steps,\n                            \"iterations\": iteration\n                        }\n                    \n                    # Log completion status\n                    self.logger.info(\"=\" * 80)\n                    self.logger.info(f\"âœ… Execution Completed Successfully\")\n                    self.logger.info(f\"Total Steps: {len(steps)}\")\n                    self.logger.info(\"=\" * 80)\n                    \n                    # Collect screenshot paths from steps\n                    screenshot_paths = [\n                        step.get('screenshot_path') \n                        for step in steps \n                        if step.get('screenshot_path')\n                    ]\n                    \n                    # Generate Python Playwright code using three-agent workflow\n                    python_code = None\n                    if self.generate_python_code:\n                        try:\n                            python_code = self._generate_python_code_from_execution(\n                                instruction=instruction,\n                                steps=steps,\n                                final_message=final_response,\n                                progress_callback=progress_callback\n                            )\n                        except Exception as gen_error:\n                            self.logger.warning(f\"âš ï¸ Python code generation failed: {gen_error}\")\n                            # Continue anyway - code generation is optional\n                    \n                    # Return execution results\n                    return {\n                        \"success\": True,\n                        \"message\": final_response,\n                        \"steps\": steps,\n                        \"iterations\": iteration,\n                        \"screenshot_paths\": screenshot_paths,\n                        \"playwright_code\": python_code\n                    }\n                    \n            except Exception as e:\n                self.logger.error(\"=\" * 80)\n                self.logger.error(f\"âŒ Execution Failed â€” {type(e).__name__}\")\n                self.logger.error(f\"Error: {str(e)}\")\n                self.logger.error(\"=\" * 80)\n                import traceback\n                self.logger.debug(traceback.format_exc())\n                \n                return {\n                    \"success\": False,\n                    \"error\": str(e),\n                    \"steps\": steps,\n                    \"iterations\": iteration\n                }\n        \n        # Max iterations reached\n        self.logger.info(\"=\" * 80)\n        self.logger.info(\"âŒ Execution Failed â€” Maximum iterations reached\")\n        self.logger.info(f\"Completed Steps: {len(steps)}\")\n        self.logger.info(\"=\" * 80)\n        \n        # Collect screenshot paths from steps\n        screenshot_paths = [\n            step.get('screenshot_path') \n            for step in steps \n            if step.get('screenshot_path')\n        ]\n        \n        return {\n            \"success\": False,\n            \"error\": \"Max iterations reached\",\n            \"steps\": steps,\n            \"iterations\": iteration,\n            \"screenshot_paths\": screenshot_paths\n        }\n    \n    def _sanitize_tool_result(self, result: Any) -> str:\n        \"\"\"\n        Sanitize tool result to remove metadata fields that the API gateway doesn't expect.\n        \n        The API expects a simple string output, not complex nested objects with metadata.\n        This prevents 400 Bad Request errors caused by malformed JSON in tool outputs.\n        \n        Args:\n            result: Raw tool result from MCP client\n            \n        Returns:\n            Sanitized string representation suitable for API gateway\n        \"\"\"\n        if result is None:\n            return \"null\"\n        \n        # If result is a string, return it directly\n        if isinstance(result, str):\n            return result\n        \n        # If result is a dict, extract meaningful content and remove metadata fields\n        if isinstance(result, dict):\n            # Remove metadata fields that cause API errors\n            sanitized = {}\n            metadata_fields = {'message', 'id', '_metadata', '__meta__'}\n            \n            for key, value in result.items():\n                # Skip metadata fields\n                if key in metadata_fields:\n                    continue\n                # Include all other fields\n                sanitized[key] = value\n            \n            # If we removed everything, return a simple success message\n            if not sanitized:\n                return json.dumps({\"status\": \"success\"})\n            \n            # Return clean JSON without metadata\n            return json.dumps(sanitized, indent=2)\n        \n        # For other types, convert to string\n        return str(result)\n    \n    def _format_action_description(self, tool_name: str, tool_args: Dict[str, Any]) -> str:\n        \"\"\"\n        Format a concise action description for logging\n        \n        Args:\n            tool_name: Name of the tool/action\n            tool_args: Tool arguments\n            \n        Returns:\n            Concise human-readable description\n        \"\"\"\n        # Map tool names to user-friendly action names\n        action_map = {\n            'browser_navigate': 'Navigate',\n            'browser_click': 'Click',\n            'browser_fill': 'Fill',\n            'browser_snapshot': 'Snapshot',\n            'browser_scroll': 'Scroll',\n            'browser_hover': 'Hover',\n            'browser_select': 'Select',\n            'browser_extract': 'Extract',\n            'browser_wait': 'Wait'\n        }\n        \n        action = action_map.get(tool_name, tool_name.replace('browser_', '').title())\n        \n        # Format based on specific action types\n        if tool_name == 'browser_navigate':\n            url = tool_args.get('url', '')\n            return f\"{action} to {url}\"\n        elif tool_name == 'browser_click':\n            ref = tool_args.get('element_ref', tool_args.get('selector', ''))\n            return f\"{action} element {ref}\"\n        elif tool_name == 'browser_fill':\n            ref = tool_args.get('element_ref', tool_args.get('selector', ''))\n            value = tool_args.get('value', '')\n            # Truncate long values\n            value_display = value[:50] + '...' if len(value) > 50 else value\n            return f\"{action} '{value_display}' in {ref}\"\n        elif tool_name == 'browser_snapshot':\n            return f\"{action} page state\"\n        else:\n            # Generic format for other actions\n            return f\"{action} - {str(tool_args)[:80]}\"\n    \n    def _execute_code_first_mode(self, instruction: str, progress_callback=None) -> Dict[str, Any]:\n        \"\"\"\n        Execute using integrated three-agent workflow: Plan â†’ Generate â†’ Execute â†’ Heal\n        This avoids duplication by planning once and using that plan for both code generation and execution.\n        \n        Args:\n            instruction: User's natural language instruction\n            progress_callback: Optional callback for progress updates\n            \n        Returns:\n            Dictionary with execution results, steps, and generated code\n        \"\"\"\n        try:\n            # Initialize MCP client\n            if progress_callback:\n                progress_callback('init', {'message': 'Initializing integrated workflow...', 'instruction': instruction})\n            \n            if not self.mcp_client.initialized:\n                self.mcp_client.initialize()\n            \n            # Determine start URL\n            if progress_callback:\n                progress_callback('analyzing', {'message': 'Analyzing task requirements...'})\n            \n            # Extract URL if mentioned in instruction, otherwise use a default\n            start_url = self._extract_url_from_instruction(instruction) or \"https://example.com\"\n            \n            # Step 1: Planner creates automation plan\n            if progress_callback:\n                progress_callback('planning', {'message': 'ðŸŽ­ Planner: Creating automation plan...'})\n            \n            self.logger.info(\"ðŸŽ­ Step 1/3: Planning automation strategy...\")\n            plan_result = self.planner_agent.create_plan(\n                goal=instruction,\n                start_url=start_url,\n                progress_callback=progress_callback\n            )\n            \n            plan_yaml = plan_result.get('plan_yaml', '')\n            if not plan_yaml:\n                return {\n                    \"success\": False,\n                    \"error\": \"Planner failed to create a plan\",\n                    \"message\": \"Could not create automation plan. Please try again.\",\n                    \"steps\": []\n                }\n            \n            # Step 2: Generator creates Python code from plan\n            if progress_callback:\n                progress_callback('generating', {'message': 'ðŸŽ¨ Generator: Writing Python code...'})\n            \n            self.logger.info(\"ðŸŽ¨ Step 2/3: Generating Python Playwright script...\")\n            gen_result = self.generator_agent.generate_script(\n                plan_yaml=plan_yaml,\n                progress_callback=progress_callback\n            )\n            \n            python_code = gen_result.get('python_code', '')\n            \n            # Step 3: Execute the task using direct browser control\n            # (We use the plan as guidance but execute directly for reliability)\n            if progress_callback:\n                progress_callback('executing', {'message': 'âš¡ Executing automation task...'})\n            \n            self.logger.info(\"âš¡ Step 3/3: Executing automation...\")\n            execution_result = self._execute_direct_mode(instruction, progress_callback)\n            \n            # Combine results: execution outcome + generated code\n            execution_result['python_code'] = python_code\n            execution_result['plan_yaml'] = plan_yaml\n            execution_result['workflow'] = 'integrated_code_first'\n            \n            self.logger.info(\"âœ… Integrated workflow completed successfully\")\n            return execution_result\n            \n        except Exception as e:\n            self.logger.error(f\"âŒ Integrated workflow failed: {e}\", exc_info=True)\n            return {\n                \"success\": False,\n                \"error\": str(e),\n                \"message\": f\"Integrated workflow encountered an error: {str(e)}\",\n                \"steps\": [],\n                \"python_code\": None\n            }\n    \n    def _extract_url_from_instruction(self, instruction: str) -> Optional[str]:\n        \"\"\"\n        Extract URL from instruction text\n        \n        Args:\n            instruction: User instruction\n            \n        Returns:\n            URL if found, None otherwise\n        \"\"\"\n        import re\n        url_pattern = r'https?://[^\\s<>\"{}|\\\\^`\\[\\]]+'\n        match = re.search(url_pattern, instruction)\n        return match.group(0) if match else None\n    \n    def reset_conversation(self):\n        \"\"\"Reset the conversation history\"\"\"\n        self.conversation_history = []\n    \n    def _generate_python_code_from_execution(\n        self,\n        instruction: str,\n        steps: List[Dict],\n        final_message: str,\n        progress_callback=None\n    ) -> str:\n        \"\"\"\n        Generate standalone Python Playwright code from successful execution\n        Uses the three-agent workflow: Plan â†’ Generate â†’ (Heal if needed)\n        \n        Args:\n            instruction: Original automation instruction\n            steps: List of executed steps\n            final_message: Final completion message\n            progress_callback: Optional callback for progress updates\n            \n        Returns:\n            Generated Python Playwright code as string\n        \"\"\"\n        try:\n            self.logger.info(\"ðŸŽ¨ Starting Python code generation with three-agent workflow...\")\n            \n            # Extract start URL from steps\n            start_url = self._extract_url_from_steps(steps, instruction)\n            \n            if not start_url:\n                self.logger.warning(\"âš ï¸ Could not determine start URL, using simple generation\")\n                return self._generate_simple_python_code(instruction, steps)\n            \n            # Step 1: Use Planner Agent to create structured plan\n            if progress_callback:\n                progress_callback('code_gen_planning', {\n                    'message': 'ðŸŽ­ Creating automation plan...'\n                })\n            \n            self.logger.info(\"ðŸŽ­ Step 1/2: Running Planner Agent...\")\n            plan_result = self.planner_agent.create_plan(\n                goal=instruction,\n                start_url=start_url,\n                progress_callback=progress_callback\n            )\n            \n            plan_yaml = plan_result.get('plan_yaml', '')\n            \n            if not plan_yaml:\n                self.logger.warning(\"âš ï¸ Planner did not generate a plan, using simple generation\")\n                return self._generate_simple_python_code(instruction, steps)\n            \n            # Step 2: Use Generator Agent to create Python code\n            if progress_callback:\n                progress_callback('code_gen_generating', {\n                    'message': 'ðŸŽ¨ Generating Python Playwright script...'\n                })\n            \n            self.logger.info(\"ðŸŽ¨ Step 2/2: Running Generator Agent...\")\n            gen_result = self.generator_agent.generate_script(\n                plan_yaml=plan_yaml,\n                progress_callback=progress_callback\n            )\n            \n            python_code = gen_result.get('python_code', '')\n            \n            if not python_code:\n                self.logger.warning(\"âš ï¸ Generator did not produce code, using simple generation\")\n                return self._generate_simple_python_code(instruction, steps)\n            \n            self.logger.info(\"âœ… Python code generation complete!\")\n            \n            # Note: Healer Agent would be called here if we detected execution errors\n            # For now, we return the generated code directly\n            \n            return python_code\n            \n        except Exception as e:\n            self.logger.error(f\"âŒ Python code generation failed: {e}\", exc_info=True)\n            # Fallback to simple generation\n            return self._generate_simple_python_code(instruction, steps)\n    \n    def _extract_url_from_steps(self, steps: List[Dict], instruction: str) -> Optional[str]:\n        \"\"\"Extract starting URL from execution steps or instruction\"\"\"\n        # Look for navigation steps\n        for step in steps:\n            if step.get('tool') == 'browser_navigate':\n                args = step.get('arguments', {})\n                if isinstance(args, dict) and 'url' in args:\n                    return args['url']\n        \n        # Try to extract URL from instruction\n        import re\n        url_pattern = r'https?://[^\\s<>\"]+'\n        matches = re.findall(url_pattern, instruction)\n        if matches:\n            return matches[0]\n        \n        # Default to a placeholder\n        return \"https://example.com\"\n    \n    def _generate_simple_python_code(self, instruction: str, steps: List[Dict]) -> str:\n        \"\"\"\n        Generate simple Python code as fallback when three-agent workflow fails\n        \n        Args:\n            instruction: Original instruction\n            steps: Executed steps\n            \n        Returns:\n            Basic Python Playwright script\n        \"\"\"\n        # Extract URL\n        start_url = self._extract_url_from_steps(steps, instruction)\n        \n        # Build basic script\n        code = f'''\"\"\"\nPlaywright Python Automation Script\nGenerated from: {instruction}\n\"\"\"\nimport asyncio\nimport logging\nfrom playwright.async_api import async_playwright\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nasync def main():\n    \"\"\"Main automation function\"\"\"\n    async with async_playwright() as p:\n        # Launch browser\n        logger.info(\"Launching browser...\")\n        browser = await p.chromium.launch(headless=False)\n        \n        try:\n            # Create context\n            context = await browser.new_context(\n                viewport={{'width': 1280, 'height': 720}}\n            )\n            page = await context.new_page()\n            page.set_default_timeout(30000)\n            \n            logger.info(\"Starting automation...\")\n            \n            # Navigate to starting URL\n            await page.goto(\"{start_url}\", wait_until=\"networkidle\")\n            logger.info(f\"Navigated to {{page.url}}\")\n            \n            # TODO: Add automation steps based on: {instruction}\n            # This is a basic template - customize based on your needs\n            \n            logger.info(\"âœ… Automation completed successfully\")\n            \n        except Exception as e:\n            logger.error(f\"âŒ Automation failed: {{e}}\")\n            raise\n        finally:\n            await browser.close()\n            logger.info(\"Browser closed\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n'''\n        return code\n","size_bytes":45986},"app/engines/browser_use/data_extractor.py":{"content":"\"\"\"\nAdvanced Data Extraction Capabilities\nStructured data scraping, table extraction, and content parsing\n\"\"\"\nimport json\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\n\nclass DataExtractor:\n    \"\"\"\n    Advanced data extraction for web automation\n    Handles tables, lists, structured data, and custom selectors\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize data extractor\"\"\"\n        logger.info(\"ðŸ“Š Data extractor initialized\")\n    \n    async def extract_table(self, page, selector: str = \"table\", \n                          include_headers: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Extract data from HTML table\n        \n        Args:\n            page: Playwright page object\n            selector: CSS selector for table\n            include_headers: Extract header row\n            \n        Returns:\n            Dictionary with table data\n        \"\"\"\n        try:\n            table_data = await page.evaluate(f\"\"\"(selector) => {{\n                const table = document.querySelector(selector);\n                if (!table) return null;\n                \n                const rows = Array.from(table.querySelectorAll('tr'));\n                const data = [];\n                \n                rows.forEach((row, index) => {{\n                    const cells = Array.from(row.querySelectorAll('td, th'));\n                    const rowData = cells.map(cell => cell.textContent.trim());\n                    if (rowData.length > 0) {{\n                        data.push(rowData);\n                    }}\n                }});\n                \n                return data;\n            }}\"\"\", selector)\n            \n            if not table_data:\n                return {\"success\": False, \"error\": \"Table not found\"}\n            \n            result = {\n                \"success\": True,\n                \"rows\": table_data,\n                \"row_count\": len(table_data),\n                \"column_count\": len(table_data[0]) if table_data else 0\n            }\n            \n            if include_headers and table_data:\n                result[\"headers\"] = table_data[0]\n                result[\"data\"] = table_data[1:]\n            \n            logger.info(f\"ðŸ“Š Table extracted: {result['row_count']} rows, {result['column_count']} columns\")\n            return result\n            \n        except Exception as e:\n            logger.error(f\"âŒ Table extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_list(self, page, selector: str, item_selector: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract items from a list\n        \n        Args:\n            page: Playwright page object\n            selector: CSS selector for list container\n            item_selector: Optional selector for individual items\n            \n        Returns:\n            Dictionary with list items\n        \"\"\"\n        try:\n            if item_selector:\n                query = f\"{selector} {item_selector}\"\n            else:\n                query = f\"{selector} li\"\n            \n            items = await page.evaluate(f\"\"\"(query) => {{\n                const elements = document.querySelectorAll(query);\n                return Array.from(elements).map(el => el.textContent.trim());\n            }}\"\"\", query)\n            \n            logger.info(f\"ðŸ“‹ List extracted: {len(items)} items\")\n            \n            return {\n                \"success\": True,\n                \"items\": items,\n                \"item_count\": len(items)\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ List extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_structured_data(self, page, schema: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"\n        Extract structured data using a schema\n        \n        Args:\n            page: Playwright page object\n            schema: Dictionary mapping field names to CSS selectors\n            \n        Returns:\n            Dictionary with extracted data\n        \"\"\"\n        try:\n            extracted_data = {}\n            \n            for field_name, selector in schema.items():\n                try:\n                    value = await page.evaluate(f\"\"\"(selector) => {{\n                        const element = document.querySelector(selector);\n                        return element ? element.textContent.trim() : null;\n                    }}\"\"\", selector)\n                    \n                    extracted_data[field_name] = value\n                except:\n                    extracted_data[field_name] = None\n            \n            logger.info(f\"ðŸ“¦ Structured data extracted: {len(extracted_data)} fields\")\n            \n            return {\n                \"success\": True,\n                \"data\": extracted_data,\n                \"field_count\": len(extracted_data)\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Structured data extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_all_links(self, page, base_url: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract all links from page\n        \n        Args:\n            page: Playwright page object\n            base_url: Optional base URL for relative links\n            \n        Returns:\n            Dictionary with links\n        \"\"\"\n        try:\n            links = await page.evaluate(\"\"\"() => {\n                const anchors = document.querySelectorAll('a[href]');\n                return Array.from(anchors).map(a => ({\n                    text: a.textContent.trim(),\n                    href: a.href,\n                    rel_href: a.getAttribute('href')\n                }));\n            }\"\"\")\n            \n            logger.info(f\"ðŸ”— Links extracted: {len(links)} links\")\n            \n            return {\n                \"success\": True,\n                \"links\": links,\n                \"link_count\": len(links),\n                \"page_url\": page.url\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Link extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_images(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract all images from page\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with image data\n        \"\"\"\n        try:\n            images = await page.evaluate(\"\"\"() => {\n                const imgs = document.querySelectorAll('img');\n                return Array.from(imgs).map(img => ({\n                    src: img.src,\n                    alt: img.alt,\n                    width: img.width,\n                    height: img.height\n                }));\n            }\"\"\")\n            \n            logger.info(f\"ðŸ–¼ï¸  Images extracted: {len(images)} images\")\n            \n            return {\n                \"success\": True,\n                \"images\": images,\n                \"image_count\": len(images)\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Image extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_metadata(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract page metadata (title, description, etc.)\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with metadata\n        \"\"\"\n        try:\n            metadata = await page.evaluate(\"\"\"() => {\n                const getMeta = (name) => {\n                    const element = document.querySelector(`meta[name=\"${name}\"], meta[property=\"${name}\"]`);\n                    return element ? element.content : null;\n                };\n                \n                return {\n                    title: document.title,\n                    description: getMeta('description') || getMeta('og:description'),\n                    keywords: getMeta('keywords'),\n                    author: getMeta('author'),\n                    og_title: getMeta('og:title'),\n                    og_image: getMeta('og:image'),\n                    canonical: document.querySelector('link[rel=\"canonical\"]')?.href\n                };\n            }\"\"\")\n            \n            metadata[\"url\"] = page.url\n            \n            logger.info(f\"â„¹ï¸  Metadata extracted from: {page.url}\")\n            \n            return {\n                \"success\": True,\n                \"metadata\": metadata\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Metadata extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    async def extract_text_content(self, page, selector: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Extract text content from page or specific element\n        \n        Args:\n            page: Playwright page object\n            selector: Optional CSS selector for specific element\n            \n        Returns:\n            Dictionary with text content\n        \"\"\"\n        try:\n            if selector:\n                text = await page.evaluate(f\"\"\"(selector) => {{\n                    const element = document.querySelector(selector);\n                    return element ? element.textContent.trim() : null;\n                }}\"\"\", selector)\n            else:\n                text = await page.evaluate(\"\"\"() => {\n                    return document.body.textContent.trim();\n                }\"\"\")\n            \n            logger.info(f\"ðŸ“ Text content extracted: {len(text)} characters\")\n            \n            return {\n                \"success\": True,\n                \"text\": text,\n                \"length\": len(text) if text else 0\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Text extraction failed: {str(e)}\")\n            return {\"success\": False, \"error\": str(e)}\n","size_bytes":10037},"app/services/locator_extractor.py":{"content":"\"\"\"\nIntelligent Locator Extraction System\nGenerates high-quality Playwright locators with smart prioritization and confidence scoring\n\"\"\"\nimport re\nfrom typing import Dict, List, Optional, Tuple\nfrom dataclasses import dataclass\nfrom enum import Enum\n\n\nclass LocatorStrategy(Enum):\n    \"\"\"Locator strategies in priority order\"\"\"\n    ROLE = \"role\"  # Highest priority - semantic, accessible\n    LABEL = \"label\"  # Form elements with labels\n    PLACEHOLDER = \"placeholder\"  # Input placeholders\n    TEST_ID = \"testid\"  # Explicit test identifiers\n    TEXT = \"text\"  # Visible text content\n    ALT_TEXT = \"alt\"  # Image alt text\n    TITLE = \"title\"  # Title attribute\n    CSS = \"css\"  # CSS selectors (lowest priority)\n\n\n@dataclass\nclass LocatorResult:\n    \"\"\"Result of locator extraction\"\"\"\n    strategy: LocatorStrategy\n    locator: str\n    confidence: float  # 0.0 to 1.0\n    is_unique: bool\n    alternatives: List[Tuple[LocatorStrategy, str, float]]  # Alternative locators\n    warnings: List[str]  # Potential issues\n\n\nclass IntelligentLocatorExtractor:\n    \"\"\"\n    Extracts intelligent locators from DOM elements with quality scoring\n    \n    Features:\n    - Smart prioritization (role > label > testid > text > css)\n    - Avoids brittle selectors (nth-child, complex paths)\n    - Provides confidence scores for each locator\n    - Suggests alternative locators\n    - Warns about potential stability issues\n    \"\"\"\n    \n    # Confidence scores for each strategy\n    CONFIDENCE_SCORES = {\n        LocatorStrategy.ROLE: 0.95,\n        LocatorStrategy.LABEL: 0.90,\n        LocatorStrategy.PLACEHOLDER: 0.85,\n        LocatorStrategy.TEST_ID: 0.88,\n        LocatorStrategy.TEXT: 0.75,\n        LocatorStrategy.ALT_TEXT: 0.80,\n        LocatorStrategy.TITLE: 0.70,\n        LocatorStrategy.CSS: 0.50\n    }\n    \n    # Brittle selector patterns to avoid\n    BRITTLE_PATTERNS = [\n        r':nth-child\\(',\n        r':nth-of-type\\(',\n        r'>\\s*div\\s*>\\s*div',  # Deep div nesting\n        r'\\[class\\*=\"[^\"]*random[^\"]*\"\\]',  # Randomized classes\n        r'\\[class\\*=\"[^\"]*hash[^\"]*\"\\]',\n    ]\n    \n    # Semantic HTML roles\n    ARIA_ROLES = {\n        'button', 'link', 'checkbox', 'radio', 'textbox', 'searchbox',\n        'combobox', 'listbox', 'option', 'menu', 'menuitem', 'tab',\n        'tabpanel', 'dialog', 'alert', 'navigation', 'main', 'heading',\n        'img', 'list', 'listitem', 'row', 'cell', 'table', 'banner',\n        'contentinfo', 'complementary', 'form', 'search', 'region'\n    }\n    \n    def __init__(self):\n        \"\"\"Initialize the locator extractor\"\"\"\n        self.locator_cache = {}\n    \n    def extract_locator(\n        self,\n        element_info: Dict,\n        action_type: Optional[str] = None\n    ) -> LocatorResult:\n        \"\"\"\n        Extract the best locator for an element\n        \n        Args:\n            element_info: Dictionary containing element properties\n                {\n                    'tag': 'button',\n                    'text': 'Click me',\n                    'role': 'button',\n                    'aria_label': 'Submit form',\n                    'placeholder': 'Enter text',\n                    'test_id': 'submit-btn',\n                    'id': 'btn-123',\n                    'class': 'btn btn-primary',\n                    'name': 'submit',\n                    'type': 'submit',\n                    'alt': 'Logo',\n                    'title': 'Submit the form'\n                }\n            action_type: Type of action (click, fill, etc.)\n        \n        Returns:\n            LocatorResult with best locator and alternatives\n        \"\"\"\n        all_locators = []\n        warnings = []\n        \n        # Try each strategy in priority order\n        locator_functions = [\n            self._extract_role_locator,\n            self._extract_label_locator,\n            self._extract_placeholder_locator,\n            self._extract_testid_locator,\n            self._extract_text_locator,\n            self._extract_alt_locator,\n            self._extract_title_locator,\n            self._extract_css_locator\n        ]\n        \n        for func in locator_functions:\n            result = func(element_info)\n            if result:\n                strategy, locator = result\n                confidence = self._calculate_confidence(strategy, locator, element_info)\n                all_locators.append((strategy, locator, confidence))\n        \n        if not all_locators:\n            # Fallback to basic CSS\n            tag = element_info.get('tag', 'div')\n            return LocatorResult(\n                strategy=LocatorStrategy.CSS,\n                locator=f\"page.locator('{tag}')\",\n                confidence=0.30,\n                is_unique=False,\n                alternatives=[],\n                warnings=[\"No semantic locators found, using generic tag selector\"]\n            )\n        \n        # Best locator is first one (highest priority with highest confidence)\n        best = all_locators[0]\n        alternatives = all_locators[1:] if len(all_locators) > 1 else []\n        \n        # Check for brittle patterns\n        brittle_warnings = self._check_brittle_patterns(best[1])\n        warnings.extend(brittle_warnings)\n        \n        return LocatorResult(\n            strategy=best[0],\n            locator=best[1],\n            confidence=best[2],\n            is_unique=True,  # Assume unique for now (would need DOM context to verify)\n            alternatives=alternatives,\n            warnings=warnings\n        )\n    \n    def _extract_role_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract role-based locator (highest priority)\"\"\"\n        role = element_info.get('role') or self._infer_role(element_info)\n        \n        if not role or role not in self.ARIA_ROLES:\n            return None\n        \n        # Check for accessible name (aria-label, label, text)\n        name = (\n            element_info.get('aria_label') or\n            element_info.get('label') or\n            element_info.get('text', '').strip()\n        )\n        \n        if name:\n            # Clean and escape the name\n            name = self._clean_text(name)\n            if role == 'button':\n                return (LocatorStrategy.ROLE, f\"page.getByRole('button', {{ name: '{name}' }})\")\n            elif role == 'link':\n                return (LocatorStrategy.ROLE, f\"page.getByRole('link', {{ name: '{name}' }})\")\n            elif role == 'textbox':\n                return (LocatorStrategy.ROLE, f\"page.getByRole('textbox', {{ name: '{name}' }})\")\n            elif role == 'checkbox':\n                return (LocatorStrategy.ROLE, f\"page.getByRole('checkbox', {{ name: '{name}' }})\")\n            elif role == 'heading':\n                return (LocatorStrategy.ROLE, f\"page.getByRole('heading', {{ name: '{name}' }})\")\n            else:\n                return (LocatorStrategy.ROLE, f\"page.getByRole('{role}', {{ name: '{name}' }})\")\n        else:\n            # Role without name (less specific)\n            return (LocatorStrategy.ROLE, f\"page.getByRole('{role}')\")\n    \n    def _extract_label_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract label-based locator (good for forms)\"\"\"\n        label = element_info.get('label') or element_info.get('aria_label')\n        \n        if label:\n            label = self._clean_text(label)\n            return (LocatorStrategy.LABEL, f\"page.getByLabel('{label}')\")\n        \n        return None\n    \n    def _extract_placeholder_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract placeholder-based locator (for inputs)\"\"\"\n        placeholder = element_info.get('placeholder')\n        \n        if placeholder:\n            placeholder = self._clean_text(placeholder)\n            return (LocatorStrategy.PLACEHOLDER, f\"page.getByPlaceholder('{placeholder}')\")\n        \n        return None\n    \n    def _extract_testid_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract test ID locator (explicit test identifiers)\"\"\"\n        test_id = (\n            element_info.get('data-testid') or\n            element_info.get('data-test-id') or\n            element_info.get('data-test') or\n            element_info.get('test_id')\n        )\n        \n        if test_id:\n            return (LocatorStrategy.TEST_ID, f\"page.getByTestId('{test_id}')\")\n        \n        return None\n    \n    def _extract_text_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract text-based locator\"\"\"\n        text = element_info.get('text', '').strip()\n        \n        if text and len(text) > 0 and len(text) < 100:  # Reasonable text length\n            text = self._clean_text(text)\n            # Check if it's exact match or partial\n            if len(text) < 50:\n                return (LocatorStrategy.TEXT, f\"page.getByText('{text}')\")\n            else:\n                # Use partial match for long text\n                partial = text[:30]\n                return (LocatorStrategy.TEXT, f\"page.getByText('{partial}', {{ exact: false }})\")\n        \n        return None\n    \n    def _extract_alt_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract alt text locator (for images)\"\"\"\n        alt = element_info.get('alt')\n        \n        if alt:\n            alt = self._clean_text(alt)\n            return (LocatorStrategy.ALT_TEXT, f\"page.getByAltText('{alt}')\")\n        \n        return None\n    \n    def _extract_title_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract title-based locator\"\"\"\n        title = element_info.get('title')\n        \n        if title:\n            title = self._clean_text(title)\n            return (LocatorStrategy.TITLE, f\"page.getByTitle('{title}')\")\n        \n        return None\n    \n    def _extract_css_locator(self, element_info: Dict) -> Optional[Tuple[LocatorStrategy, str]]:\n        \"\"\"Extract CSS locator (last resort)\"\"\"\n        # Priority: ID > stable class > tag + attributes\n        \n        elem_id = element_info.get('id')\n        if elem_id and not self._looks_dynamic(elem_id):\n            return (LocatorStrategy.CSS, f\"page.locator('#{elem_id}')\")\n        \n        # Use stable classes (avoid hashed/random ones)\n        classes = element_info.get('class', '').split()\n        stable_classes = [c for c in classes if not self._looks_dynamic(c)]\n        \n        if stable_classes:\n            class_selector = '.' + '.'.join(stable_classes[:2])  # Max 2 classes\n            tag = element_info.get('tag', '')\n            if tag:\n                return (LocatorStrategy.CSS, f\"page.locator('{tag}{class_selector}')\")\n            else:\n                return (LocatorStrategy.CSS, f\"page.locator('{class_selector}')\")\n        \n        # Fallback to tag + type/name\n        tag = element_info.get('tag', 'div')\n        elem_type = element_info.get('type')\n        name = element_info.get('name')\n        \n        if elem_type:\n            return (LocatorStrategy.CSS, f\"page.locator('{tag}[type=\\\"{elem_type}\\\"]')\")\n        elif name:\n            return (LocatorStrategy.CSS, f\"page.locator('{tag}[name=\\\"{name}\\\"]')\")\n        else:\n            return (LocatorStrategy.CSS, f\"page.locator('{tag}')\")\n    \n    def _infer_role(self, element_info: Dict) -> Optional[str]:\n        \"\"\"Infer ARIA role from element properties\"\"\"\n        tag = element_info.get('tag', '').lower()\n        elem_type = element_info.get('type', '').lower()\n        \n        # Map HTML elements to ARIA roles\n        role_map = {\n            'button': 'button',\n            'a': 'link',\n            'input': {\n                'text': 'textbox',\n                'email': 'textbox',\n                'password': 'textbox',\n                'search': 'searchbox',\n                'tel': 'textbox',\n                'url': 'textbox',\n                'number': 'textbox',\n                'checkbox': 'checkbox',\n                'radio': 'radio',\n                'submit': 'button',\n                'button': 'button'\n            },\n            'textarea': 'textbox',\n            'select': 'combobox',\n            'img': 'img',\n            'nav': 'navigation',\n            'main': 'main',\n            'header': 'banner',\n            'footer': 'contentinfo',\n            'aside': 'complementary',\n            'form': 'form',\n            'h1': 'heading',\n            'h2': 'heading',\n            'h3': 'heading',\n            'h4': 'heading',\n            'h5': 'heading',\n            'h6': 'heading',\n            'ul': 'list',\n            'ol': 'list',\n            'li': 'listitem',\n            'table': 'table',\n            'tr': 'row',\n            'td': 'cell',\n            'th': 'cell'\n        }\n        \n        if tag in role_map:\n            role_value = role_map[tag]\n            if isinstance(role_value, dict):\n                return role_value.get(elem_type, 'textbox' if tag == 'input' else None)\n            return role_value\n        \n        return None\n    \n    def _calculate_confidence(\n        self,\n        strategy: LocatorStrategy,\n        locator: str,\n        element_info: Dict\n    ) -> float:\n        \"\"\"Calculate confidence score for a locator\"\"\"\n        base_confidence = self.CONFIDENCE_SCORES[strategy]\n        \n        # Adjust based on locator characteristics\n        adjustments = 0.0\n        \n        # Bonus for specific attributes\n        if 'name:' in locator or \"name: '\" in locator:\n            adjustments += 0.05  # Has accessible name\n        \n        # Penalty for generic selectors\n        if locator.count('div') > 1:\n            adjustments -= 0.10  # Multiple divs\n        \n        # Penalty for complex selectors\n        if locator.count('>') > 2:\n            adjustments -= 0.15  # Deep nesting\n        \n        # Bonus for test IDs\n        if 'getByTestId' in locator:\n            adjustments += 0.10  # Explicit test identifier\n        \n        # Check for brittle patterns\n        for pattern in self.BRITTLE_PATTERNS:\n            if re.search(pattern, locator):\n                adjustments -= 0.20\n                break\n        \n        return max(0.0, min(1.0, base_confidence + adjustments))\n    \n    def _check_brittle_patterns(self, locator: str) -> List[str]:\n        \"\"\"Check for brittle selector patterns\"\"\"\n        warnings = []\n        \n        for pattern in self.BRITTLE_PATTERNS:\n            if re.search(pattern, locator):\n                warnings.append(f\"Brittle pattern detected: {pattern}\")\n        \n        if locator.count('>') > 3:\n            warnings.append(\"Deep selector nesting may be fragile\")\n        \n        if ':nth-child(' in locator or ':nth-of-type(' in locator:\n            warnings.append(\"Position-based selector may break if DOM changes\")\n        \n        return warnings\n    \n    def _looks_dynamic(self, value: str) -> bool:\n        \"\"\"Check if a class or ID looks dynamically generated\"\"\"\n        # Patterns that indicate dynamic values\n        dynamic_patterns = [\n            r'[a-f0-9]{8,}',  # Long hex strings\n            r'_[0-9a-z]{6,}$',  # Trailing hash\n            r'^[a-z]{1,2}[0-9]+$',  # Short prefix + numbers\n            r'random|hash|uuid|guid',\n        ]\n        \n        for pattern in dynamic_patterns:\n            if re.search(pattern, value.lower()):\n                return True\n        \n        return False\n    \n    def _clean_text(self, text: str) -> str:\n        \"\"\"Clean and escape text for use in selectors\"\"\"\n        # Remove extra whitespace\n        text = ' '.join(text.split())\n        # Escape single quotes\n        text = text.replace(\"'\", \"\\\\'\")\n        # Limit length\n        if len(text) > 100:\n            text = text[:97] + '...'\n        return text\n    \n    def get_quality_indicator(self, confidence: float) -> Dict[str, str]:\n        \"\"\"\n        Get visual quality indicator for UI display\n        \n        Returns:\n            {\n                'level': 'excellent' | 'good' | 'fair' | 'poor',\n                'color': 'green' | 'yellow' | 'orange' | 'red',\n                'emoji': 'ðŸŸ¢' | 'ðŸŸ¡' | 'ðŸŸ ' | 'ðŸ”´'\n            }\n        \"\"\"\n        if confidence >= 0.85:\n            return {'level': 'excellent', 'color': 'green', 'emoji': 'ðŸŸ¢'}\n        elif confidence >= 0.70:\n            return {'level': 'good', 'color': 'yellow', 'emoji': 'ðŸŸ¡'}\n        elif confidence >= 0.50:\n            return {'level': 'fair', 'color': 'orange', 'emoji': 'ðŸŸ '}\n        else:\n            return {'level': 'poor', 'color': 'red', 'emoji': 'ðŸ”´'}\n\n\ndef extract_locator_from_action(action_data: Dict) -> LocatorResult:\n    \"\"\"\n    Convenience function to extract locator from action data\n    \n    Args:\n        action_data: Action data with element information\n    \n    Returns:\n        LocatorResult\n    \"\"\"\n    extractor = IntelligentLocatorExtractor()\n    element_info = action_data.get('element', {})\n    action_type = action_data.get('action_type', None)\n    \n    return extractor.extract_locator(element_info, action_type)\n","size_bytes":16989},"app/routes/api.py":{"content":"\"\"\"\nAPI Routes\nRESTful endpoints for browser automation with security and validation\n\"\"\"\nimport os\nimport json\nimport logging\nimport threading\nfrom queue import Queue\nfrom datetime import datetime\nfrom flask import Blueprint, render_template, request, jsonify, Response, stream_with_context, current_app\nfrom app.models import db, ExecutionHistory, GeneratedScript, CredentialVault\nfrom app.services.engine_orchestrator import EngineOrchestrator\nfrom app.middleware.security import (\n    require_api_key,\n    rate_limit,\n    validate_engine_type,\n    validate_instruction,\n    sanitize_error_message\n)\nfrom app.utils.timeout import run_with_timeout, TimeoutError\nfrom app.utils.credentials import replace_credential_placeholders\n\nlogger = logging.getLogger(__name__)\n\ndef save_execution_to_history(instruction, engine_type, headless, result):\n    \"\"\"\n    Save execution result to history database\n    \n    Args:\n        instruction: The automation instruction\n        engine_type: The engine used (browser_use or playwright_mcp)\n        headless: Whether execution was headless\n        result: The execution result dictionary\n    \"\"\"\n    try:\n        # Handle screenshot paths - convert array to JSON or handle single path\n        screenshot_paths = result.get('screenshot_paths', [])\n        screenshot_path_json = None\n        \n        if screenshot_paths and isinstance(screenshot_paths, list):\n            screenshot_path_json = json.dumps(screenshot_paths)\n        elif result.get('screenshot_path'):\n            # Handle legacy single screenshot path\n            screenshot_path_json = json.dumps([result.get('screenshot_path')])\n        \n        # Map 'steps' to 'history' for display - BrowserAgent returns steps, not history\n        execution_history = result.get('history') or result.get('steps', [])\n        \n        history_entry = ExecutionHistory(\n            prompt=instruction,\n            engine=engine_type,\n            headless=headless,\n            success=result.get('success', False),\n            error_message=result.get('error') or result.get('message') if not result.get('success') else None,\n            screenshot_path=screenshot_path_json,\n            execution_logs=json.dumps(execution_history) if execution_history else None,\n            iterations=result.get('iterations'),\n            execution_time=result.get('execution_time')\n        )\n        \n        db.session.add(history_entry)\n        db.session.flush()  # Flush to get the history_entry.id\n        \n        # Save generated Python code if available (Playwright MCP engine only)\n        python_code = result.get('playwright_code')\n        if python_code:\n            import hashlib\n            script_hash = hashlib.sha256(python_code.encode()).hexdigest()\n            \n            generated_script = GeneratedScript(\n                execution_id=history_entry.id,\n                python_code=python_code,\n                script_hash=script_hash,\n                is_healed=False,\n                healing_iterations=0\n            )\n            db.session.add(generated_script)\n            logger.info(f\"ðŸ’¾ Saved generated Python script (hash: {script_hash[:8]}...)\")\n        \n        # Save healed code if available\n        if result.get('healed_code'):\n            import hashlib\n            healed_code = result.get('healed_code')\n            script_hash = hashlib.sha256(healed_code.encode()).hexdigest()\n            \n            healed_script = GeneratedScript(\n                execution_id=history_entry.id,\n                python_code=healed_code,\n                script_hash=script_hash,\n                is_healed=True,\n                healing_iterations=result.get('healing_iterations', 1)\n            )\n            db.session.add(healed_script)\n            logger.info(f\"ðŸ’¾ Saved healed Python script (hash: {script_hash[:8]}...)\")\n        \n        db.session.commit()\n        \n        logger.info(f\"ðŸ’¾ Saved execution to history (ID: {history_entry.id})\")\n        return history_entry.id\n        \n    except Exception as e:\n        db.session.rollback()\n        logger.error(f\"Failed to save execution to history: {str(e)}\", exc_info=True)\n        return None\n\n\ndef create_api_routes(orchestrator: EngineOrchestrator) -> Blueprint:\n    \"\"\"\n    Create API routes blueprint\n    \n    Args:\n        orchestrator: Engine orchestrator instance\n        \n    Returns:\n        Flask Blueprint with all routes\n    \"\"\"\n    api = Blueprint('api', __name__)\n    \n    @api.route('/')\n    def index():\n        \"\"\"Render dashboard page\"\"\"\n        return render_template('dashboard.html')\n    \n    @api.route('/history')\n    def history():\n        \"\"\"Render history page\"\"\"\n        return render_template('history.html')\n    \n    @api.route('/configuration')\n    def configuration():\n        \"\"\"Render configuration page\"\"\"\n        return render_template('configuration.html')\n    \n    @api.route('/credentials')\n    def credentials():\n        \"\"\"Render credentials manager page\"\"\"\n        return render_template('credentials.html')\n    \n    @api.route('/api/execute', methods=['POST'])\n    @require_api_key\n    @rate_limit\n    def execute_instruction():\n        \"\"\"Execute a browser automation instruction\"\"\"\n        try:\n            data = request.get_json()\n            \n            if not data:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid request',\n                    'message': 'Request body must be valid JSON'\n                }), 400\n            \n            instruction = data.get('instruction', '').strip()\n            engine_type = data.get('engine', 'browser_use')\n            headless = data.get('headless', False)\n            \n            is_valid, error_msg = validate_instruction(instruction)\n            if not is_valid:\n                logger.warning(f\"âš ï¸  Invalid instruction: {error_msg}\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid instruction',\n                    'message': error_msg\n                }), 400\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                logger.warning(f\"âš ï¸  Invalid engine type: {error_msg}\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            if not isinstance(headless, bool):\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid parameter',\n                    'message': 'headless must be a boolean'\n                }), 400\n            \n            # Store original instruction for database (with placeholders)\n            original_instruction = instruction\n            \n            # Replace credential placeholders with actual values\n            try:\n                processed_instruction, credentials_used = replace_credential_placeholders(instruction)\n                if credentials_used:\n                    logger.info(f\"ðŸ” Using {len(credentials_used)} credential(s): {', '.join(credentials_used)}\")\n            except ValueError as e:\n                logger.warning(f\"âš ï¸  Credential replacement failed: {str(e)}\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Missing credentials',\n                    'message': str(e)\n                }), 400\n            \n            logger.info(\"=\"*80)\n            logger.info(\"ðŸ“¨ NEW AUTOMATION REQUEST\")\n            logger.info(f\"ðŸ“ Instruction: {original_instruction}\")\n            logger.info(f\"ðŸ”§ Engine: {engine_type}\")\n            logger.info(f\"ðŸ‘ï¸  Headless: {headless}\")\n            logger.info(f\"ðŸŒ Client: {request.remote_addr}\")\n            logger.info(\"=\"*80)\n            \n            logger.info(\"ðŸš€ Starting automation execution...\")\n            \n            try:\n                result = run_with_timeout(\n                    orchestrator.execute_instruction,\n                    300,\n                    processed_instruction,\n                    engine_type,\n                    headless,\n                    None  # progress_callback\n                )\n            except TimeoutError as e:\n                logger.error(f\"â±ï¸  Automation timed out: {str(e)}\")\n                orchestrator.cleanup_after_timeout(engine_type, headless)\n                return jsonify({\n                    'success': False,\n                    'error': 'Timeout',\n                    'message': 'Operation timed out. The task took longer than 5 minutes to complete.',\n                    'timeout': True\n                }), 408\n            \n            if result.get('success'):\n                logger.info(f\"âœ… Automation completed successfully in {result.get('iterations', 0)} steps\")\n            else:\n                logger.error(f\"âŒ Automation failed: {result.get('error', 'Unknown error')}\")\n            \n            save_execution_to_history(original_instruction, engine_type, headless, result)\n            \n            logger.info(\"=\"*80)\n            \n            return jsonify(result)\n            \n        except Exception as e:\n            logger.error(f\"ðŸ’¥ Exception in execute_instruction: {str(e)}\", exc_info=True)\n            \n            user_message = sanitize_error_message(e)\n            \n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': user_message\n            }), 500\n    \n    @api.route('/api/execute/stream', methods=['POST'])\n    @require_api_key\n    @rate_limit\n    def execute_instruction_stream():\n        \"\"\"Execute a browser automation instruction with Server-Sent Events streaming\"\"\"\n        def generate_progress():\n            \"\"\"Generator function for SSE streaming\"\"\"\n            try:\n                data = request.get_json()\n                \n                if not data:\n                    yield f\"data: {json.dumps({'type': 'error', 'error': 'Invalid request', 'message': 'Request body must be valid JSON'})}\\n\\n\"\n                    return\n                \n                instruction = data.get('instruction', '').strip()\n                engine_type = data.get('engine', 'browser_use')\n                headless = data.get('headless', False)\n                \n                # Validation\n                is_valid, error_msg = validate_instruction(instruction)\n                if not is_valid:\n                    logger.warning(f\"âš ï¸  Invalid instruction: {error_msg}\")\n                    yield f\"data: {json.dumps({'type': 'error', 'error': 'Invalid instruction', 'message': error_msg})}\\n\\n\"\n                    return\n                \n                is_valid, error_msg = validate_engine_type(engine_type)\n                if not is_valid:\n                    logger.warning(f\"âš ï¸  Invalid engine type: {error_msg}\")\n                    yield f\"data: {json.dumps({'type': 'error', 'error': 'Invalid engine type', 'message': error_msg})}\\n\\n\"\n                    return\n                \n                if not isinstance(headless, bool):\n                    yield f\"data: {json.dumps({'type': 'error', 'error': 'Invalid parameter', 'message': 'headless must be a boolean'})}\\n\\n\"\n                    return\n                \n                # Store original instruction for database (with placeholders)\n                original_instruction = instruction\n                \n                # Replace credential placeholders with actual values\n                try:\n                    processed_instruction, credentials_used = replace_credential_placeholders(instruction)\n                    if credentials_used:\n                        logger.info(f\"ðŸ” Using {len(credentials_used)} credential(s): {', '.join(credentials_used)}\")\n                except ValueError as e:\n                    logger.warning(f\"âš ï¸  Credential replacement failed: {str(e)}\")\n                    yield f\"data: {json.dumps({'type': 'error', 'error': 'Missing credentials', 'message': str(e)})}\\n\\n\"\n                    return\n                \n                logger.info(\"=\"*80)\n                logger.info(\"ðŸ“¨ NEW AUTOMATION REQUEST (STREAMING)\")\n                logger.info(f\"ðŸ“ Instruction: {original_instruction}\")\n                logger.info(f\"ðŸ”§ Engine: {engine_type}\")\n                logger.info(f\"ðŸ‘ï¸  Headless: {headless}\")\n                logger.info(f\"ðŸŒ Client: {request.remote_addr}\")\n                logger.info(\"=\"*80)\n                \n                # Send start event\n                yield f\"data: {json.dumps({'type': 'start', 'message': 'Starting automation...'})}\\n\\n\"\n                \n                # Create a queue for progress updates\n                progress_queue = Queue()\n                result_holder = {}\n                \n                # Capture the Flask app object for use in the thread\n                app = current_app._get_current_object()\n                \n                def progress_callback(event_type, data):\n                    \"\"\"Callback function to send progress updates\"\"\"\n                    progress_queue.put({'type': event_type, 'data': data})\n                \n                def execute_in_thread():\n                    \"\"\"Execute automation in a separate thread\"\"\"\n                    try:\n                        result = orchestrator.execute_instruction_with_progress(\n                            processed_instruction,\n                            engine_type,\n                            headless,\n                            progress_callback\n                        )\n                        result_holder['result'] = result\n                        # Use app context for database operations in thread\n                        with app.app_context():\n                            save_execution_to_history(original_instruction, engine_type, headless, result)\n                        progress_queue.put({'type': 'done', 'result': result})\n                    except Exception as e:\n                        logger.error(f\"ðŸ’¥ Exception in threaded execution: {str(e)}\", exc_info=True)\n                        result_holder['error'] = str(e)\n                        error_result = {\n                            'success': False,\n                            'error': str(e),\n                            'message': sanitize_error_message(e)\n                        }\n                        # Use app context for database operations in thread\n                        with app.app_context():\n                            save_execution_to_history(original_instruction, engine_type, headless, error_result)\n                        progress_queue.put({'type': 'error', 'error': str(e), 'message': sanitize_error_message(e)})\n                \n                # Start execution in thread\n                execution_thread = threading.Thread(target=execute_in_thread)\n                execution_thread.daemon = True\n                execution_thread.start()\n                \n                # Stream progress updates\n                while True:\n                    event = progress_queue.get()\n                    \n                    if event['type'] == 'done':\n                        # Send final result\n                        yield f\"data: {json.dumps(event)}\\n\\n\"\n                        logger.info(\"âœ… Streaming completed successfully\")\n                        break\n                    elif event['type'] == 'error':\n                        # Send error and stop\n                        yield f\"data: {json.dumps(event)}\\n\\n\"\n                        logger.error(f\"âŒ Streaming failed: {event.get('error')}\")\n                        break\n                    else:\n                        # Send progress update\n                        yield f\"data: {json.dumps(event)}\\n\\n\"\n                \n                logger.info(\"=\"*80)\n                \n            except Exception as e:\n                logger.error(f\"ðŸ’¥ Exception in SSE streaming: {str(e)}\", exc_info=True)\n                yield f\"data: {json.dumps({'type': 'error', 'error': 'Internal error', 'message': sanitize_error_message(e)})}\\n\\n\"\n        \n        return Response(\n            stream_with_context(generate_progress()),\n            mimetype='text/event-stream',\n            headers={\n                'Cache-Control': 'no-cache',\n                'X-Accel-Buffering': 'no',\n                'Connection': 'keep-alive'\n            }\n        )\n    \n    @api.route('/api/tools', methods=['GET'])\n    def get_tools():\n        \"\"\"Get available browser tools\"\"\"\n        try:\n            engine_type = request.args.get('engine', 'browser_use')\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            tools = orchestrator.get_tools(engine_type)\n            \n            return jsonify({\n                'success': True,\n                'tools': tools,\n                'engine': engine_type\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error getting tools: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/reset', methods=['POST'])\n    @require_api_key\n    def reset_agent():\n        \"\"\"Reset the browser agent\"\"\"\n        try:\n            data = request.get_json() or {}\n            engine_type = data.get('engine', 'browser_use')\n            \n            is_valid, error_msg = validate_engine_type(engine_type)\n            if not is_valid:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid engine type',\n                    'message': error_msg\n                }), 400\n            \n            orchestrator.reset_agent(engine_type)\n            \n            return jsonify({\n                'success': True,\n                'message': 'Agent reset successfully',\n                'engine': engine_type\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error resetting agent: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/mcp/status', methods=['GET'])\n    def mcp_server_status():\n        \"\"\"Get Playwright MCP server status\"\"\"\n        try:\n            from app.engines.playwright_mcp import get_server_status\n            status = get_server_status()\n            \n            return jsonify({\n                'success': True,\n                'server_mode': status['mode'],\n                'persistent_running': status['persistent_running'],\n                'message': f\"MCP server in '{status['mode']}' mode\"\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error getting MCP server status: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/mcp/restart', methods=['POST'])\n    @require_api_key\n    def restart_mcp_server():\n        \"\"\"Restart persistent MCP server (only works in 'always_run' mode)\"\"\"\n        try:\n            from app.engines.playwright_mcp import shutdown_server, get_server_status\n            \n            status = get_server_status()\n            if status['mode'] != 'always_run':\n                return jsonify({\n                    'success': False,\n                    'error': 'Server not in always_run mode',\n                    'message': 'Server restart only available in always_run mode'\n                }), 400\n            \n            shutdown_server()\n            logger.info(\"ðŸ”„ MCP server restarted\")\n            \n            return jsonify({\n                'success': True,\n                'message': 'MCP server shutdown. It will restart on next request.'\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error restarting MCP server: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/health', methods=['GET'])\n    def health_check():\n        \"\"\"Health check endpoint\"\"\"\n        try:\n            from app.engines.playwright_mcp import get_server_status\n            mcp_status = get_server_status()\n            \n            return jsonify({\n                'status': 'healthy',\n                'engines': {\n                    'browser_use': 'available',\n                    'playwright_mcp': 'available'\n                },\n                'mcp_server': {\n                    'mode': mcp_status['mode'],\n                    'running': mcp_status['persistent_running']\n                },\n                'message': 'AI browser automation ready',\n                'security': {\n                    'authentication': 'enabled' if os.environ.get('API_KEY') else 'disabled',\n                    'rate_limiting': 'enabled'\n                }\n            })\n        except Exception as e:\n            logger.error(f\"Health check failed: {str(e)}\", exc_info=True)\n            return jsonify({\n                'status': 'unhealthy',\n                'error': 'Service unavailable'\n            }), 503\n    \n    @api.route('/api/history', methods=['GET'])\n    def get_history():\n        \"\"\"Get all execution history\"\"\"\n        try:\n            page = request.args.get('page', 1, type=int)\n            per_page = request.args.get('per_page', 20, type=int)\n            \n            history_query = ExecutionHistory.query.order_by(\n                ExecutionHistory.created_at.desc()\n            ).paginate(page=page, per_page=per_page, error_out=False)\n            \n            return jsonify({\n                'success': True,\n                'history': [item.to_dict() for item in history_query.items],\n                'total': history_query.total,\n                'page': page,\n                'pages': history_query.pages,\n                'per_page': per_page\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error getting history: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/history/<int:history_id>', methods=['GET'])\n    def get_history_item(history_id):\n        \"\"\"Get a specific execution history item\"\"\"\n        try:\n            item = ExecutionHistory.query.get(history_id)\n            \n            if not item:\n                return jsonify({\n                    'success': False,\n                    'error': 'Not found',\n                    'message': 'History item not found'\n                }), 404\n            \n            return jsonify({\n                'success': True,\n                'history': item.to_dict()\n            })\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error getting history item: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/history', methods=['DELETE'])\n    @require_api_key\n    def delete_all_history():\n        \"\"\"Delete all execution history\"\"\"\n        try:\n            count = ExecutionHistory.query.delete()\n            db.session.commit()\n            \n            logger.info(f\"ðŸ—‘ï¸  Deleted {count} history items\")\n            \n            return jsonify({\n                'success': True,\n                'message': f'Deleted {count} history items',\n                'count': count\n            })\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error deleting history: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/history/<int:history_id>', methods=['DELETE'])\n    @require_api_key\n    def delete_history_item(history_id):\n        \"\"\"Delete a specific execution history item\"\"\"\n        try:\n            item = ExecutionHistory.query.get(history_id)\n            \n            if not item:\n                return jsonify({\n                    'success': False,\n                    'error': 'Not found',\n                    'message': 'History item not found'\n                }), 404\n            \n            db.session.delete(item)\n            db.session.commit()\n            \n            logger.info(f\"ðŸ—‘ï¸  Deleted history item {history_id}\")\n            \n            return jsonify({\n                'success': True,\n                'message': 'History item deleted'\n            })\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error deleting history item: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    @api.route('/api/history/<int:history_id>/execute', methods=['POST'])\n    @require_api_key\n    @rate_limit\n    def execute_from_history(history_id):\n        \"\"\"\n        Execute a script from history with auto-healing\n        \n        Logic:\n        1. Execute the generated script (or healed script if both exist, healed takes precedence)\n        2. If it fails, trigger healer agent to fix it\n        3. Save healed script to database\n        4. If healed script fails, move it to generated_script and create new healed version\n        \"\"\"\n        import subprocess\n        import tempfile\n        from app.engines.playwright_mcp.agents.healer_agent import HealerAgent\n        from app.models import GeneratedScript\n        \n        try:\n            item = ExecutionHistory.query.get(history_id)\n            \n            if not item:\n                return jsonify({\n                    'success': False,\n                    'error': 'Not found',\n                    'message': 'History item not found'\n                }), 404\n            \n            # Get the script to execute\n            # If both exist, healed script takes precedence\n            healed_scripts = [s for s in item.generated_scripts if s.is_healed]\n            generated_scripts = [s for s in item.generated_scripts if not s.is_healed]\n            \n            script_to_execute = None\n            is_executing_healed = False\n            existing_healed_script = None\n            existing_generated_script = None\n            \n            if healed_scripts:\n                # Sort by created_at descending to get the most recent\n                healed_scripts.sort(key=lambda x: x.created_at, reverse=True)\n                script_to_execute = healed_scripts[0].python_code\n                is_executing_healed = True\n                existing_healed_script = healed_scripts[0]\n                logger.info(f\"ðŸ”„ Executing healed script from history #{history_id}\")\n            elif generated_scripts:\n                generated_scripts.sort(key=lambda x: x.created_at, reverse=True)\n                script_to_execute = generated_scripts[0].python_code\n                existing_generated_script = generated_scripts[0]\n                logger.info(f\"ðŸ”„ Executing generated script from history #{history_id}\")\n            else:\n                return jsonify({\n                    'success': False,\n                    'error': 'No script',\n                    'message': 'No generated script found for this history item'\n                }), 400\n            \n            # Execute the script\n            logger.info(\"â–¶ï¸  Executing script...\")\n            execution_result, error_message = _execute_python_script(script_to_execute)\n            \n            if execution_result['success']:\n                # Script passed without errors\n                logger.info(\"âœ… Script executed successfully without errors\")\n                return jsonify({\n                    'success': True,\n                    'message': 'Script executed successfully',\n                    'healing_needed': False\n                })\n            \n            # Script failed, trigger healing\n            logger.warning(f\"âŒ Script failed: {error_message}\")\n            logger.info(\"ðŸ”§ Triggering healer agent...\")\n            \n            # Initialize healer agent\n            from auth.oauth_handler import OAuthHandler\n            oauth_handler = OAuthHandler()\n            llm_client = oauth_handler.get_llm_client()\n            healer_agent = HealerAgent(llm_client)\n            \n            # Heal the script\n            heal_result = healer_agent.heal_script(\n                python_code=script_to_execute,\n                error_message=error_message,\n                max_iterations=3\n            )\n            \n            if not heal_result.get('success'):\n                logger.error(\"âŒ Healing failed\")\n                return jsonify({\n                    'success': False,\n                    'error': 'Healing failed',\n                    'message': 'Could not automatically fix the script errors'\n                }), 500\n            \n            healed_code = heal_result['healed_code']\n            healing_iterations = heal_result['healing_iterations']\n            \n            # If we were executing a healed script that failed:\n            # Move it to generated_script and create new healed version\n            if is_executing_healed and existing_healed_script:\n                logger.info(\"ðŸ”„ Healed script failed, moving to generated and creating new healed version...\")\n                \n                # Mark the old healed script as non-healed (move to generated)\n                existing_healed_script.is_healed = False\n                existing_healed_script.healing_iterations = 0\n                \n                # Create new healed script\n                new_healed_script = GeneratedScript(\n                    execution_id=history_id,\n                    python_code=healed_code,\n                    script_hash=heal_result['script_hash'],\n                    is_healed=True,\n                    healing_iterations=healing_iterations\n                )\n                db.session.add(new_healed_script)\n            else:\n                # Create new healed script from generated script\n                logger.info(\"ðŸ”§ Creating new healed script...\")\n                new_healed_script = GeneratedScript(\n                    execution_id=history_id,\n                    python_code=healed_code,\n                    script_hash=heal_result['script_hash'],\n                    is_healed=True,\n                    healing_iterations=healing_iterations\n                )\n                db.session.add(new_healed_script)\n            \n            db.session.commit()\n            logger.info(f\"âœ… Healed script saved to database\")\n            \n            return jsonify({\n                'success': True,\n                'message': 'Script healed successfully',\n                'healing_needed': True,\n                'healed_script': healed_code,\n                'healing_attempts': healing_iterations,\n                'healing_steps': len(json.loads(heal_result.get('fixes_applied', '[]')))\n            })\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error executing from history: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Internal error',\n                'message': sanitize_error_message(e)\n            }), 500\n    \n    def _execute_python_script(python_code: str) -> tuple:\n        \"\"\"\n        Execute a Python script and return success status and error message\n        \n        Returns:\n            Tuple of (result_dict, error_message)\n        \"\"\"\n        try:\n            # Create a temporary file with the script\n            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:\n                f.write(python_code)\n                script_path = f.name\n            \n            # Execute the script with timeout\n            result = subprocess.run(\n                ['python', script_path],\n                capture_output=True,\n                text=True,\n                timeout=60  # 60 second timeout\n            )\n            \n            # Clean up temp file\n            import os\n            os.unlink(script_path)\n            \n            if result.returncode == 0:\n                return ({'success': True}, None)\n            else:\n                error_msg = result.stderr or result.stdout or 'Unknown error'\n                return ({'success': False}, error_msg)\n                \n        except subprocess.TimeoutExpired:\n            return ({'success': False}, 'Script execution timed out after 60 seconds')\n        except Exception as e:\n            return ({'success': False}, str(e))\n    \n    @api.route('/api/credentials', methods=['GET'])\n    def list_credentials():\n        \"\"\"\n        List all stored credentials (without values)\n        \"\"\"\n        try:\n            credentials = CredentialVault.query.order_by(CredentialVault.created_at.desc()).all()\n            return jsonify({\n                'success': True,\n                'credentials': [cred.to_dict(include_value=False) for cred in credentials]\n            })\n        except Exception as e:\n            logger.error(f\"Error listing credentials: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Failed to list credentials',\n                'message': str(e)\n            }), 500\n    \n    @api.route('/api/credentials', methods=['POST'])\n    def create_credential():\n        \"\"\"\n        Create a new credential\n        \n        Request body:\n            {\n                \"name\": \"gmail_password\",\n                \"service\": \"Gmail\",\n                \"username\": \"user@example.com\",\n                \"value\": \"secretPassword123\",\n                \"description\": \"My Gmail password\"\n            }\n        \"\"\"\n        try:\n            data = request.get_json()\n            \n            if not data:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid request',\n                    'message': 'Request body must be valid JSON'\n                }), 400\n            \n            name = data.get('name', '').strip()\n            value = data.get('value', '').strip()\n            \n            if not name:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid input',\n                    'message': 'Credential name is required'\n                }), 400\n            \n            if not value:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid input',\n                    'message': 'Credential value is required'\n                }), 400\n            \n            # Check if credential with this name already exists\n            existing = CredentialVault.query.filter_by(name=name).first()\n            if existing:\n                return jsonify({\n                    'success': False,\n                    'error': 'Credential exists',\n                    'message': f'A credential with name \"{name}\" already exists'\n                }), 409\n            \n            # Create new credential\n            credential = CredentialVault(\n                name=name,\n                service=data.get('service', '').strip() or None,\n                url=data.get('url', '').strip() or None,\n                username=data.get('username', '').strip() or None,\n                description=data.get('description', '').strip() or None\n            )\n            credential.set_credential(value)\n            \n            db.session.add(credential)\n            db.session.commit()\n            \n            logger.info(f\"âœ… Created new credential: {name}\")\n            \n            return jsonify({\n                'success': True,\n                'message': 'Credential created successfully',\n                'credential': credential.to_dict(include_value=False)\n            }), 201\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error creating credential: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Failed to create credential',\n                'message': str(e)\n            }), 500\n    \n    @api.route('/api/credentials/<int:credential_id>', methods=['GET'])\n    def get_credential(credential_id):\n        \"\"\"\n        Get a specific credential (without value)\n        \"\"\"\n        try:\n            credential = CredentialVault.query.get(credential_id)\n            \n            if not credential:\n                return jsonify({\n                    'success': False,\n                    'error': 'Not found',\n                    'message': 'Credential not found'\n                }), 404\n            \n            return jsonify({\n                'success': True,\n                'credential': credential.to_dict(include_value=False)\n            })\n            \n        except Exception as e:\n            logger.error(f\"Error getting credential: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Failed to get credential',\n                'message': str(e)\n            }), 500\n    \n    @api.route('/api/credentials/<int:credential_id>', methods=['PUT'])\n    def update_credential(credential_id):\n        \"\"\"\n        Update an existing credential\n        \"\"\"\n        try:\n            credential = CredentialVault.query.get(credential_id)\n            \n            if not credential:\n                return jsonify({\n                    'success': False,\n                    'error': 'Not found',\n                    'message': 'Credential not found'\n                }), 404\n            \n            data = request.get_json()\n            \n            if not data:\n                return jsonify({\n                    'success': False,\n                    'error': 'Invalid request',\n                    'message': 'Request body must be valid JSON'\n                }), 400\n            \n            # Update fields if provided\n            if 'name' in data and data['name'].strip():\n                new_name = data['name'].strip()\n                # Check if another credential has this name\n                existing = CredentialVault.query.filter_by(name=new_name).first()\n                if existing and existing.id != credential_id:\n                    return jsonify({\n                        'success': False,\n                        'error': 'Credential exists',\n                        'message': f'A credential with name \"{new_name}\" already exists'\n                    }), 409\n                credential.name = new_name\n            \n            if 'service' in data:\n                credential.service = data['service'].strip() or None\n            \n            if 'url' in data:\n                credential.url = data['url'].strip() or None\n            \n            if 'username' in data:\n                credential.username = data['username'].strip() or None\n            \n            if 'description' in data:\n                credential.description = data['description'].strip() or None\n            \n            if 'value' in data and data['value'].strip():\n                credential.set_credential(data['value'].strip())\n            \n            db.session.commit()\n            \n            logger.info(f\"âœ… Updated credential: {credential.name}\")\n            \n            return jsonify({\n                'success': True,\n                'message': 'Credential updated successfully',\n                'credential': credential.to_dict(include_value=False)\n            })\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error updating credential: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Failed to update credential',\n                'message': str(e)\n            }), 500\n    \n    @api.route('/api/credentials/<int:credential_id>', methods=['DELETE'])\n    def delete_credential(credential_id):\n        \"\"\"\n        Delete a credential\n        \"\"\"\n        try:\n            credential = CredentialVault.query.get(credential_id)\n            \n            if not credential:\n                return jsonify({\n                    'success': False,\n                    'error': 'Not found',\n                    'message': 'Credential not found'\n                }), 404\n            \n            credential_name = credential.name\n            db.session.delete(credential)\n            db.session.commit()\n            \n            logger.info(f\"ðŸ—‘ï¸  Deleted credential: {credential_name}\")\n            \n            return jsonify({\n                'success': True,\n                'message': 'Credential deleted successfully'\n            })\n            \n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Error deleting credential: {str(e)}\", exc_info=True)\n            return jsonify({\n                'success': False,\n                'error': 'Failed to delete credential',\n                'message': str(e)\n            }), 500\n    \n    return api\n","size_bytes":42086},"app/engines/playwright_mcp/agent/__init__.py":{"content":"\"\"\"\nPlaywright MCP Agent Module\n\"\"\"\nfrom app.engines.playwright_mcp.agent.conversation_agent import BrowserAgent\n\n__all__ = ['BrowserAgent']\n","size_bytes":141},"app/engines/playwright_mcp/agents/planner_agent.py":{"content":"\"\"\"\nPlanner Agent\nExplores the application and generates structured automation plans with validated strict-mode locators\n\"\"\"\nimport logging\nimport yaml\nimport json\nfrom typing import Dict, List, Any, Optional\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\n\nclass PlannerAgent:\n    \"\"\"\n    Planner Agent that explores applications and creates structured automation plans\n    Generates YAML plans with validated locators and step-by-step actions\n    \"\"\"\n    \n    def __init__(self, mcp_client, llm_client, locator_engine, model='gpt-4.1-2025-04-14-eastus-dz'):\n        \"\"\"\n        Initialize Planner Agent\n        \n        Args:\n            mcp_client: MCP client for browser interactions\n            llm_client: LLM client for intelligent planning\n            locator_engine: StrictModeLocatorEngine instance\n            model: Model name to use for planning\n        \"\"\"\n        self.mcp_client = mcp_client\n        self.llm_client = llm_client\n        self.locator_engine = locator_engine\n        self.model = model\n        self.conversation_history = []\n    \n    def create_plan(self, goal: str, start_url: str, progress_callback=None) -> Dict[str, Any]:\n        \"\"\"\n        Create an automation plan by exploring the application\n        \n        Args:\n            goal: Natural language automation goal\n            start_url: Starting URL for exploration\n            progress_callback: Optional callback for progress updates\n            \n        Returns:\n            Dictionary containing plan_yaml, validated_locators, and metadata\n        \"\"\"\n        try:\n            if progress_callback:\n                progress_callback('planner_init', {\n                    'message': 'ðŸŽ­ Planner Agent: Analyzing automation goal...',\n                    'goal': goal,\n                    'start_url': start_url\n                })\n            \n            logger.info(f\"ðŸŽ­ Planner Agent: Creating plan for '{goal}' at {start_url}\")\n            \n            # Initialize conversation with system prompt\n            self.conversation_history = [\n                {\n                    \"role\": \"system\",\n                    \"content\": self._get_planner_system_prompt()\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": f\"\"\"Create an automation plan:\nGoal: {goal}\nStart URL: {start_url}\n\nNavigate to the URL, explore the page, identify elements, then generate a YAML plan with goal, start_url, and steps.\"\"\"\n                }\n            ]\n            \n            # Get available MCP tools\n            tools = self.mcp_client.get_tools_schema()\n            \n            if progress_callback:\n                progress_callback('planner_explore', {\n                    'message': 'ðŸŽ­ Planner Agent: Exploring application and identifying elements...'\n                })\n            \n            # Execute planning conversation loop\n            steps_taken = []\n            max_iterations = 15\n            iteration = 0\n            \n            while iteration < max_iterations:\n                iteration += 1\n                \n                # Get LLM response with tool access\n                response = self.llm_client.chat.completions.create(\n                    model=self.model,\n                    max_tokens=4096,\n                    tools=tools,\n                    messages=self.conversation_history\n                )\n                \n                # Get assistant message from OpenAI response\n                assistant_message = response.choices[0].message\n                \n                # Add assistant response to conversation (following OpenAI format)\n                assistant_entry = {\n                    \"role\": \"assistant\",\n                    \"content\": assistant_message.content if assistant_message.content else \"\"\n                }\n                # Only add tool_calls if they exist (don't include None)\n                if assistant_message.tool_calls:\n                    assistant_entry[\"tool_calls\"] = assistant_message.tool_calls\n                \n                self.conversation_history.append(assistant_entry)\n                \n                # Check if we have a final plan\n                has_tool_calls = assistant_message.tool_calls is not None and len(assistant_message.tool_calls) > 0\n                \n                if not has_tool_calls:\n                    # Extract the plan from the response\n                    text_content = assistant_message.content if assistant_message.content else \"\"\n                    \n                    if progress_callback:\n                        progress_callback('planner_complete', {\n                            'message': 'ðŸŽ­ Planner Agent: Plan generation complete!'\n                        })\n                    \n                    # Parse the YAML plan\n                    plan_data = self._extract_yaml_plan(text_content)\n                    \n                    if plan_data:\n                        # Validate and enhance locators using the locator engine\n                        plan_data = self._validate_and_enhance_plan(plan_data)\n                        \n                        logger.info(\"âœ… Planner Agent: Successfully created automation plan with validated locators\")\n                        return {\n                            'plan_yaml': yaml.dump(plan_data, default_flow_style=False),\n                            'validated_locators': json.dumps(self._extract_locators_from_plan(plan_data)),\n                            'metadata': json.dumps({\n                                'iterations': iteration,\n                                'steps_explored': len(steps_taken),\n                                'created_at': datetime.utcnow().isoformat()\n                            })\n                        }\n                    else:\n                        # No valid YAML found, treat as completion message\n                        logger.warning(\"No YAML plan found in response, creating basic plan\")\n                        basic_plan = self._create_basic_plan(goal, start_url, steps_taken)\n                        return {\n                            'plan_yaml': yaml.dump(basic_plan, default_flow_style=False),\n                            'validated_locators': json.dumps({}),\n                            'metadata': json.dumps({\n                                'iterations': iteration,\n                                'fallback': True\n                            })\n                        }\n                \n                # Execute tool calls\n                if has_tool_calls:\n                    tool_results = []\n                    for tool_call in assistant_message.tool_calls:\n                        tool_name = tool_call.function.name\n                        tool_input = json.loads(tool_call.function.arguments)\n                        \n                        logger.info(f\"ðŸ”§ Planner executing tool: {tool_name}\")\n                        steps_taken.append({\n                            'tool': tool_name,\n                            'input': tool_input\n                        })\n                        \n                        if progress_callback:\n                            progress_callback('planner_action', {\n                                'message': f'ðŸŽ­ Planner: Executing {tool_name}...',\n                                'tool': tool_name\n                            })\n                        \n                        # Execute the tool via MCP\n                        result = self.mcp_client.call_tool(tool_name, tool_input)\n                        \n                        tool_results.append({\n                            \"role\": \"tool\",\n                            \"tool_call_id\": tool_call.id,\n                            \"content\": json.dumps(result) if not isinstance(result, str) else result\n                        })\n                    \n                    # Add tool results to conversation\n                    if tool_results:\n                        self.conversation_history.extend(tool_results)\n            \n            # Max iterations reached\n            logger.warning(f\"âš ï¸ Planner Agent reached max iterations ({max_iterations})\")\n            basic_plan = self._create_basic_plan(goal, start_url, steps_taken)\n            \n            return {\n                'plan_yaml': yaml.dump(basic_plan, default_flow_style=False),\n                'validated_locators': json.dumps({}),\n                'metadata': json.dumps({\n                    'iterations': max_iterations,\n                    'timeout': True\n                })\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Planner Agent error: {e}\", exc_info=True)\n            raise\n    \n    def _get_planner_system_prompt(self) -> str:\n        \"\"\"Get system prompt for the planner agent\"\"\"\n        return \"\"\"Automation planner: explore pages, identify elements, create YAML plans.\n\n1. Navigate & snapshot to understand UI\n2. Validate locators (test-id, ARIA, text, selectors)\n3. Generate YAML:\ngoal: \"task\"\nstart_url: \"url\"\nsteps:\n  - step_number: N\n    action: navigate|click|fill|press|select|wait|screenshot\n    description: \"step info\"\n    target_url: \"url\" (navigate only)\n    element: {locator_strategy: \"type\", locator: \"selector\", text: \"label\"} (interactions)\n    value: \"input\" (fill/select)\n\nAfter exploration, output complete YAML plan.\"\"\"\n    \n    def _extract_text_from_response(self, response) -> str:\n        \"\"\"Extract text content from LLM response\"\"\"\n        text_parts = []\n        for block in response.content:\n            if block.type == \"text\":\n                text_parts.append(block.text)\n        return '\\n'.join(text_parts)\n    \n    def _extract_yaml_plan(self, text: str) -> Optional[Dict]:\n        \"\"\"Extract YAML plan from text response\"\"\"\n        try:\n            # Look for YAML code blocks\n            yaml_pattern = r'```(?:yaml|yml)?\\s*\\n(.*?)\\n```'\n            import re\n            matches = re.findall(yaml_pattern, text, re.DOTALL)\n            \n            if matches:\n                # Try to parse the first YAML block\n                plan = yaml.safe_load(matches[0])\n                if isinstance(plan, dict) and 'goal' in plan:\n                    return plan\n            \n            # Try parsing the entire text as YAML\n            plan = yaml.safe_load(text)\n            if isinstance(plan, dict) and 'goal' in plan:\n                return plan\n                \n        except Exception as e:\n            logger.debug(f\"Could not extract YAML plan: {e}\")\n        \n        return None\n    \n    def _extract_locators_from_plan(self, plan: Dict) -> Dict[str, Any]:\n        \"\"\"Extract all validated locators from the plan\"\"\"\n        locators = {}\n        \n        steps = plan.get('steps', [])\n        for step in steps:\n            if 'element' in step:\n                step_num = step.get('step_number', 'unknown')\n                locators[f\"step_{step_num}\"] = step['element']\n        \n        return locators\n    \n    def _validate_and_enhance_plan(self, plan: Dict) -> Dict:\n        \"\"\"\n        Validate and enhance plan with strict-mode locators from locator engine\n        \n        Args:\n            plan: The automation plan dictionary\n            \n        Returns:\n            Enhanced plan with validated locators\n        \"\"\"\n        steps = plan.get('steps', [])\n        enhanced_steps = []\n        \n        for step in steps:\n            # Skip steps without element interactions\n            if 'element' not in step:\n                enhanced_steps.append(step)\n                continue\n            \n            element_data = step['element']\n            \n            # Try to extract element metadata from the element data\n            # If the LLM provided good metadata, use it; otherwise, keep original\n            if isinstance(element_data, dict):\n                # Generate strict-mode locator using the locator engine\n                try:\n                    best_locator = self.locator_engine.generate_best_locator(element_data)\n                    \n                    # Validate the generated locator\n                    is_valid, reason = self.locator_engine.validate_locator(best_locator)\n                    \n                    if is_valid:\n                        # Update the element with validated locator\n                        element_data['locator'] = best_locator\n                        element_data['validation_status'] = 'validated'\n                        element_data['validation_reason'] = reason\n                        logger.info(f\"âœ… Validated locator for step {step.get('step_number')}: {reason}\")\n                    else:\n                        # Still use the generated locator if it's better than nothing\n                        # Mark it appropriately so Generator knows to improve it if possible\n                        if 'locator' not in element_data or not element_data.get('locator'):\n                            element_data['locator'] = best_locator\n                        element_data['validation_status'] = 'needs_improvement'\n                        element_data['validation_reason'] = reason\n                        logger.warning(f\"âš ï¸  Locator needs improvement for step {step.get('step_number')}: {reason}\")\n                except Exception as e:\n                    logger.warning(f\"âš ï¸  Error generating locator for step {step.get('step_number')}: {e}\")\n                    element_data['validation_status'] = 'error'\n            \n            step['element'] = element_data\n            enhanced_steps.append(step)\n        \n        plan['steps'] = enhanced_steps\n        return plan\n    \n    def _create_basic_plan(self, goal: str, start_url: str, steps_taken: List[Dict]) -> Dict:\n        \"\"\"Create a basic fallback plan\"\"\"\n        return {\n            'goal': goal,\n            'start_url': start_url,\n            'steps': [\n                {\n                    'step_number': 1,\n                    'action': 'navigate',\n                    'description': f'Navigate to {start_url}',\n                    'target_url': start_url\n                }\n            ],\n            'metadata': {\n                'fallback': True,\n                'exploration_steps': len(steps_taken)\n            }\n        }\n","size_bytes":14244},"app/engines/browser_use/engine_optimized.py":{"content":"\"\"\"\nOptimized Browser-Use Engine\nAI-powered browser automation with advanced features and optimizations\n\nNew Features:\n- Advanced browser capabilities (screenshots, PDFs, cookies, sessions)\n- Enhanced popup handling with configurable timeouts\n- Smart retry mechanism with exponential backoff\n- State management for complex workflows\n- Data extraction capabilities\n- Performance monitoring and metrics\n\"\"\"\nimport os\nimport asyncio\nimport configparser\nimport logging\nimport time\nfrom pathlib import Path\nfrom typing import Dict, Any, List, Optional\nfrom dotenv import load_dotenv\n\n# PRIVACY: Disable all external data transmission BEFORE importing browser-use\n# This prevents telemetry and cloud sync from being initialized\nos.environ.setdefault('ANONYMIZED_TELEMETRY', 'false')\nos.environ.setdefault('BROWSER_USE_CLOUD_SYNC', 'false')\nfrom browser_use import Agent, Browser\nfrom browser_use.llm import ChatOpenAI\nfrom auth.oauth_handler import get_oauth_token_with_retry\nfrom app.utils.logging_config import (\n    should_log_llm_requests, \n    should_log_llm_responses,\n    should_log_browser_actions,\n    should_log_page_state,\n    should_log_performance\n)\n\n# Import ChatBrowserUse for optimized browser automation (3-5x faster)\ntry:\n    from browser_use.llm import ChatBrowserUse\n    CHAT_BROWSER_USE_AVAILABLE = True\nexcept ImportError:\n    CHAT_BROWSER_USE_AVAILABLE = False\n\nfrom app.engines.browser_use.advanced_features import AdvancedBrowserFeatures\nfrom app.engines.browser_use.retry_mechanism import RetryConfig, RetryMechanism\nfrom app.engines.browser_use.state_manager import WorkflowState\nfrom app.engines.browser_use.data_extractor import DataExtractor\nfrom app.engines.browser_use.performance_monitor import PerformanceMonitor\n\nproject_root = Path(__file__).parent.parent\nenv_path = project_root / '.env'\nload_dotenv(dotenv_path=env_path, override=True)\n\nlogger = logging.getLogger(__name__)\n\n\nclass OptimizedBrowserUseEngine:\n    \"\"\"\n    Optimized browser automation engine with advanced capabilities\n    \n    Features:\n    - Screenshot capture and PDF generation\n    - Cookie and session management\n    - Smart retry with exponential backoff\n    - Workflow state persistence\n    - Data extraction (tables, lists, metadata)\n    - Performance monitoring\n    - Enhanced popup handling\n    \"\"\"\n    \n    def __init__(self, headless: bool = False, enable_advanced_features: bool = True):\n        \"\"\"\n        Initialize Optimized Browser-Use Engine\n        \n        Args:\n            headless: Run browser in headless mode\n            enable_advanced_features: Enable advanced capabilities\n        \"\"\"\n        self.headless = headless\n        self.enable_advanced_features = enable_advanced_features\n        \n        config = configparser.ConfigParser()\n        config.read('config/config.ini')\n        \n        gateway_base_url = os.environ.get('GW_BASE_URL')\n        if not gateway_base_url:\n            raise ValueError(\"GW_BASE_URL must be set as environment variable to connect to the gateway endpoint.\")\n        \n        try:\n            oauth_token = get_oauth_token_with_retry(max_retries=3)\n        except Exception as e:\n            raise ValueError(f\"Failed to obtain OAuth token: {str(e)}. Please check your OAuth configuration.\")\n        \n        model = config.get('openai', 'model', fallback='gpt-4.1-2025-04-14-eastus-dz')\n        timeout = int(config.get('openai', 'timeout', fallback='180'))\n        self.max_steps = int(config.get('agent', 'max_steps', fallback='25'))\n        \n        # Logging flags\n        self.log_llm_requests = should_log_llm_requests()\n        self.log_llm_responses = should_log_llm_responses()\n        self.log_browser_actions = should_log_browser_actions()\n        self.log_page_state = should_log_page_state()\n        self.log_performance = should_log_performance()\n        \n        # Verification keywords to detect validation requirements\n        self.verification_keywords = [\n            'verify', 'check', 'ensure', 'validate', 'assert', \n            'confirm', 'test', 'must', 'should contain', 'should have',\n            'expect', 'required', 'make sure', 'assert that'\n        ]\n        \n        # Browser performance settings - using reliable defaults\n        self.minimum_wait_page_load_time = float(config.get('browser_performance', 'minimum_wait_page_load_time', fallback='1.0'))\n        self.wait_for_network_idle_page_load_time = float(config.get('browser_performance', 'wait_for_network_idle_page_load_time', fallback='1.5'))\n        self.wait_between_actions = float(config.get('browser_performance', 'wait_between_actions', fallback='1.0'))\n        \n        # Use ChatBrowserUse model if enabled (3-5x faster for browser automation)\n        use_chat_browser_use = config.getboolean('openai', 'use_chat_browser_use', fallback=False)\n        \n        if use_chat_browser_use and CHAT_BROWSER_USE_AVAILABLE:\n            logger.info(\"ðŸš€ Using ChatBrowserUse optimized model (3-5x faster)\")\n            self.llm = ChatBrowserUse()\n        else:\n            if use_chat_browser_use and not CHAT_BROWSER_USE_AVAILABLE:\n                logger.warning(\"âš ï¸  ChatBrowserUse not available, falling back to standard OpenAI model\")\n            logger.info(f\"Using gateway model: {model} via {gateway_base_url}\")\n            self.llm = ChatOpenAI(\n                model=model,\n                base_url=gateway_base_url,\n                api_key=oauth_token,\n                default_headers={\n                    \"Authorization\": f\"Bearer {oauth_token}\"\n                },\n                timeout=timeout\n            )\n        \n        if enable_advanced_features:\n            output_dir = config.get('advanced_features', 'output_directory', fallback='automation_outputs')\n            self.enable_screenshots = config.getboolean('advanced_features', 'enable_screenshots', fallback=True)\n            self.enable_pdf_generation = config.getboolean('advanced_features', 'enable_pdf_generation', fallback=True)\n            self.enable_cookie_management = config.getboolean('advanced_features', 'enable_cookie_management', fallback=True)\n            self.enable_state_persistence = config.getboolean('advanced_features', 'enable_state_persistence', fallback=True)\n            \n            self.advanced_features = AdvancedBrowserFeatures(output_dir=output_dir)\n            \n            max_retries = int(config.get('retry', 'max_retries', fallback='3'))\n            initial_delay = float(config.get('retry', 'initial_delay', fallback='1.0'))\n            max_delay = float(config.get('retry', 'max_delay', fallback='30.0'))\n            backoff_factor = float(config.get('retry', 'backoff_factor', fallback='2.0'))\n            \n            retry_config = RetryConfig(\n                max_retries=max_retries,\n                initial_delay=initial_delay,\n                max_delay=max_delay,\n                backoff_factor=backoff_factor\n            )\n            self.retry_mechanism = RetryMechanism(retry_config)\n            \n            track_metrics = config.getboolean('performance', 'track_detailed_metrics', fallback=True)\n            self.performance_monitor = PerformanceMonitor(track_detailed_metrics=track_metrics)\n            \n            self.data_extractor = DataExtractor()\n            self.workflow_state = None\n            \n            logger.info(\"ðŸš€ Advanced features enabled: Screenshots, PDFs, Cookies, Retry, Performance Tracking\")\n        else:\n            logger.info(\"â„¹ï¸  Running in basic mode (advanced features disabled)\")\n    \n    def _has_verification_requirements(self, instruction: str) -> bool:\n        \"\"\"\n        Check if the instruction contains verification/validation requirements\n        \n        Args:\n            instruction: User's instruction\n            \n        Returns:\n            True if instruction contains verification keywords\n        \"\"\"\n        instruction_lower = instruction.lower()\n        return any(keyword in instruction_lower for keyword in self.verification_keywords)\n    \n    def _check_verification_failure(self, final_result: Any, steps: List[Dict], instruction: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Check if verification failed based on final result and steps\n        \n        Args:\n            final_result: Final result from agent execution\n            steps: List of executed steps\n            instruction: Original instruction\n            \n        Returns:\n            Dict with verification failure info if detected, None otherwise\n        \"\"\"\n        if not final_result:\n            return None\n        \n        result_str = str(final_result).lower()\n        \n        # First check for explicit success indicators - if found, verification passed\n        success_indicators = [\n            'verification passed', 'check passed', 'verified successfully',\n            'validation passed', 'assertion passed', 'confirmed successfully'\n        ]\n        if any(indicator in result_str for indicator in success_indicators):\n            return None  # Verification explicitly passed\n        \n        # More specific failure indicators to avoid false positives\n        failure_indicators = [\n            'verification failed', 'check failed', 'assertion failed',\n            'validation failed', 'not found', 'does not exist',\n            'could not find', 'unable to find', 'did not find',\n            'missing element', 'element missing', 'cannot locate',\n            'no such element', 'not present on', 'not visible',\n            'failed to verify', 'failed to validate', 'failed to confirm'\n        ]\n        \n        has_verification = self._has_verification_requirements(instruction)\n        has_failure = any(indicator in result_str for indicator in failure_indicators)\n        \n        if has_verification and has_failure:\n            return {\n                'verification_failed': True,\n                'reason': str(final_result)[:300],  # Limit length\n                'instruction': instruction,\n                'completed_steps': len(steps)\n            }\n        \n        return None\n    \n    async def execute_instruction(self, instruction: str, \n                                  workflow_id: Optional[str] = None,\n                                  save_screenshot: bool = False,\n                                  save_pdf: bool = False,\n                                  progress_callback=None) -> Dict[str, Any]:\n        \"\"\"\n        Execute a natural language instruction with advanced features\n        \n        Args:\n            instruction: User's natural language instruction\n            workflow_id: Optional workflow ID for state management\n            save_screenshot: Capture screenshot after completion\n            save_pdf: Generate PDF after completion\n            progress_callback: Optional callback for progress updates\n            \n        Returns:\n            Dictionary with execution results and advanced metrics\n        \"\"\"\n        # Input validation\n        if not instruction or not instruction.strip():\n            logger.error(\"âŒ Empty instruction provided\")\n            return {\n                \"success\": False,\n                \"error\": \"Instruction cannot be empty\",\n                \"error_type\": \"ValidationError\",\n                \"steps\": [],\n                \"iterations\": 0\n            }\n        \n        instruction = instruction.strip()\n        op_id = None\n        browser = None\n        if self.enable_advanced_features:\n            op_id = self.performance_monitor.start_operation(\"execute_instruction\")\n            \n            if workflow_id:\n                self.workflow_state = WorkflowState(workflow_id=workflow_id, persist_to_disk=True)\n        \n        try:\n            logger.info(\"ðŸ¤– Initializing Browser-Use Agent\")\n            logger.info(f\"ðŸ“‹ Task: {instruction}\")\n            logger.info(f\"ðŸ”¢ Max steps: {self.max_steps}\")\n            \n            # Send initialization progress\n            if progress_callback:\n                progress_callback('init', {'message': 'Initializing browser automation agent...', 'instruction': instruction})\n            \n            # System instructions optimized for efficiency while maintaining safety\n            # Fix from https://github.com/browser-use/browser-use/pull/235 to prevent going beyond task\n            system_instructions = f\"\"\"\nYOUR ULTIMATE TASK: \"{instruction}\"\n\nâš ï¸ CRITICAL - GOAL-BASED EXECUTION âš ï¸\nIdentify the GOAL of the task, then stop immediately once that goal is achieved.\nYou MAY make auxiliary decisions to achieve the goal (wait for pages, handle popups, retry actions).\nYou MUST NOT perform actions beyond achieving the stated goal.\n\nEXECUTION APPROACH:\n1. Parse the task to identify the GOAL (the end state to achieve)\n2. Make necessary auxiliary decisions to reach that goal:\n   âœ… Wait for pages to load\n   âœ… Handle popups or dialog boxes that block progress\n   âœ… Retry failed actions (element not found, slow page load)\n   âœ… Navigate through necessary intermediate steps\n3. Once the GOAL is achieved â†’ IMMEDIATELY use done()\n4. Do NOT perform additional \"helpful\" actions beyond the goal\n\nEXAMPLES OF GOAL-BASED EXECUTION:\n\nTask: \"open linkedin.com click join now\"\nâ†’ GOAL: Click the \"join now\" button on LinkedIn\nâ†’ âœ… Correct: Navigate to linkedin.com â†’ Wait for page â†’ Click \"join now\" â†’ Verify click succeeded â†’ done()\nâ†’ âŒ Wrong: Navigate â†’ Click \"join now\" â†’ Fill email â†’ Fill password (GOAL was already achieved after clicking!)\n\nTask: \"go to amazon.com and search for laptop\"\nâ†’ GOAL: Execute a search for \"laptop\" on Amazon\nâ†’ âœ… Correct: Navigate â†’ Wait for page â†’ Type \"laptop\" in search â†’ Click search button â†’ done()\nâ†’ âŒ Wrong: Navigate â†’ Search â†’ Click first result â†’ View product details (GOAL was achieved after search!)\n\nTask: \"fill in the email field with test@example.com and submit the form\"\nâ†’ GOAL: Submit form with email filled\nâ†’ âœ… Correct: Fill email â†’ Click submit â†’ Wait for submission â†’ done()\nâ†’ âŒ Wrong: Stop after filling email (GOAL requires submitting!)\n\nCRITICAL: STOP IMMEDIATELY AFTER GOAL IS ACHIEVED\nâ†’ Do NOT fill forms unless required to achieve the goal\nâ†’ Do NOT click buttons unless required to achieve the goal\nâ†’ Do NOT navigate to pages unless required to achieve the goal\nâ†’ Ask yourself: \"Have I achieved the stated goal?\" If yes â†’ done()\n\nAUXILIARY DECISIONS (ALLOWED):\n- Waiting for pages/elements to load\n- Handling popups that block the goal\n- Retrying actions that fail due to timing\n- Navigating to intermediate pages to reach the goal\n- Verifying that actions succeeded\n\nPAGE LOADING & ERRORS:\n- If element not found â†’ page still loading â†’ wait 2s â†’ retry with fresh page state\n- Verify critical actions succeeded before done()\n- If action fails after retries â†’ report failure and use done()\n\nâš ï¸ INTELLIGENT DROPDOWN HANDLING âš ï¸\nWhen interacting with dropdown lists or select elements, use these strategies:\n\n1. NATIVE HTML SELECT ELEMENTS:\n   - Use select_option() or click() to interact with <select> elements\n   - You can select by visible text, value attribute, or index\n   - Example: Select \"United States\" from country dropdown\n   \n2. CUSTOM JAVASCRIPT DROPDOWNS (Material-UI, Ant Design, etc.):\n   - First click to open the dropdown\n   - Wait for dropdown options to appear (wait 0.5-1s)\n   - Then click on the desired option\n   - For long dropdowns, scroll into view before clicking\n   \n3. DROPDOWN WITH SEARCH/FILTER:\n   - Click to open dropdown\n   - Type search text to filter options\n   - Wait for filtered results to appear\n   - Click the desired option\n   \n4. HANDLING LONG DROPDOWN LISTS:\n   - If option not visible, scroll within dropdown container\n   - Use hover() on options to scroll them into view\n   - For very long lists, use search/filter if available\n   \n5. MULTI-SELECT DROPDOWNS:\n   - Click each option to add to selection\n   - Don't close dropdown until all selections are made\n   - Look for \"Select All\" or \"Clear All\" buttons if available\n\nDROPDOWN TROUBLESHOOTING:\n- If click doesn't open dropdown â†’ try hovering first, then click\n- If option not found â†’ check if it's dynamically loaded, wait longer\n- If dropdown closes unexpectedly â†’ use longer waits between actions\n- For custom dropdowns, look for aria-expanded, role=\"listbox\", or similar attributes\n\nâš ï¸ VERIFICATION & VALIDATION REQUIREMENTS âš ï¸\nIf the task contains verification keywords (verify, check, ensure, validate, assert, confirm, must, should):\n- You MUST explicitly check the verification condition\n- If verification FAILS â†’ Report failure clearly with: \"Verification failed: [specific reason]\"\n- If verification SUCCEEDS â†’ Report success clearly with: \"Verification passed: [what was verified]\"\n- NEVER ignore verification requirements - they are critical to task success\n- Examples:\n  * \"verify the search button exists\" â†’ If button not found, report: \"Verification failed: search button not found\"\n  * \"ensure page contains 'Welcome'\" â†’ If text not found, report: \"Verification failed: 'Welcome' text not present on page\"\n\nSECURITY:\n- Never navigate to unintended domains\n- Confirm sensitive actions before executing\n            \"\"\"\n            \n            logger.info(\"âš™ï¸  Configuring agent with optimizations\")\n            \n            # Send browser initialization progress\n            if progress_callback:\n                progress_callback('browser_init', {'message': f'Starting browser (headless={self.headless})...'})\n            \n            # Create browser instance with optimized performance settings\n            # Browser accepts **data kwargs, type stubs might not reflect all parameters\n            browser = Browser(  # type: ignore\n                headless=self.headless,\n                disable_security=False,  # Keep security enabled for production\n                minimum_wait_page_load_time=self.minimum_wait_page_load_time,\n                wait_for_network_idle_page_load_time=self.wait_for_network_idle_page_load_time,\n                wait_between_actions=self.wait_between_actions\n            )\n            logger.info(f\"ðŸŒ Browser initialized (headless={self.headless})\")\n            \n            # Send agent creation progress\n            if progress_callback:\n                progress_callback('agent_create', {'message': 'Creating AI agent...'})\n            \n            agent = Agent(\n                task=instruction,\n                llm=self.llm,\n                browser=browser,  # Pass browser for proper popup/multi-window handling\n                extend_system_message=system_instructions.strip(),\n            )\n            \n            logger.info(\"â–¶ï¸  Starting agent execution...\")\n            \n            # Send execution start progress\n            if progress_callback:\n                progress_callback('execution_start', {'message': 'Agent is now executing automation steps...'})\n            \n            # Add detailed logging wrapper for agent.run()\n            if self.log_performance:\n                start_time = time.time()\n            \n            logger.debug(\"=\" * 80)\n            logger.debug(\"ðŸ”„ CALLING agent.run() - LLM will be invoked repeatedly\")\n            logger.debug(f\"Max steps: {self.max_steps}\")\n            logger.debug(f\"Task: {instruction}\")\n            logger.debug(\"=\" * 80)\n            \n            try:\n                if self.enable_advanced_features:\n                    @self.retry_mechanism.async_retry\n                    async def run_with_retry():\n                        return await agent.run(max_steps=self.max_steps)\n                    \n                    history = await run_with_retry()\n                else:\n                    history = await agent.run(max_steps=self.max_steps)\n            except Exception as e:\n                logger.error(\"=\" * 80)\n                logger.error(\"âŒ AGENT.RUN() FAILED\")\n                logger.error(f\"Error Type: {type(e).__name__}\")\n                logger.error(f\"Error Message: {str(e)}\")\n                logger.error(\"=\" * 80)\n                import traceback\n                logger.error(traceback.format_exc())\n                raise\n            \n            if self.log_performance:\n                elapsed = time.time() - start_time\n                logger.debug(f\"â±ï¸  agent.run() completed in {elapsed:.2f}s\")\n            \n            logger.info(f\"â¹ï¸  Agent execution completed\")\n            \n            logger.info(\"=\" * 80)\n            logger.info(\"ðŸ“‹ EXECUTION STEPS\")\n            logger.info(\"=\" * 80)\n            steps = []\n            screenshot_paths = []\n            \n            for i, item in enumerate(history.history):\n                step_num = i + 1\n                action = str(getattr(item, 'model_output', ''))\n                state = str(getattr(item, 'state', ''))\n                \n                # Concise step-based logging\n                logger.info(f\"Step {step_num}: {action[:120]}\")\n                \n                step = {\n                    \"tool\": \"browser_use_action\",\n                    \"arguments\": {\"action\": action},\n                    \"success\": True,\n                    \"result\": {\n                        \"state\": state,\n                        \"step_number\": step_num\n                    }\n                }\n                steps.append(step)\n                \n                # Send step progress update\n                if progress_callback:\n                    progress_callback('step', {\n                        'step_number': step_num,\n                        'action': action[:150],\n                        'total_steps': len(history.history)\n                    })\n                \n                if self.enable_advanced_features and self.workflow_state:\n                    self.workflow_state.add_step(\n                        step_name=f\"browser_action_{step_num}\",\n                        step_data={\"action\": action},\n                        success=True\n                    )\n            \n            final_result = history.final_result() if hasattr(history, 'final_result') else None\n            \n            # Check for verification failures\n            verification_failure = self._check_verification_failure(final_result, steps, instruction)\n            if verification_failure:\n                logger.error(\"=\" * 80)\n                logger.error(\"âŒ VERIFICATION FAILED\")\n                logger.error(f\"Instruction: {verification_failure['instruction']}\")\n                logger.error(f\"Reason: {verification_failure['reason']}\")\n                logger.error(f\"Completed Steps: {verification_failure['completed_steps']}\")\n                logger.error(\"=\" * 80)\n                \n                # Return verification failure result\n                return {\n                    \"success\": False,\n                    \"error\": f\"Verification failed: {verification_failure['reason']}\",\n                    \"error_type\": \"VerificationError\",\n                    \"verification_failed\": True,\n                    \"verification_details\": verification_failure,\n                    \"steps\": steps,\n                    \"iterations\": len(steps),\n                    \"final_result\": final_result\n                }\n            \n            # Screenshots are now captured automatically at each step above\n            \n            # Capture final screenshot at the end of automation\n            if self.enable_advanced_features and browser and len(steps) > 0:\n                try:\n                    page = await browser.get_current_page()\n                    if page:\n                        screenshot_name = \"final\"\n                        screenshot_result = await self.advanced_features.capture_screenshot(page, name=screenshot_name)\n                        if screenshot_result.get('success'):\n                            screenshot_path = screenshot_result.get('path')\n                            screenshot_paths.append(screenshot_path)\n                            logger.info(f\"ðŸ“¸ Final screenshot captured: {screenshot_path}\")\n                            \n                            # Send final screenshot event via progress callback\n                            if progress_callback:\n                                progress_callback('screenshot', {\n                                    'path': screenshot_path,\n                                    'url': screenshot_result.get('url', ''),\n                                    'step_number': 'Final'\n                                })\n                except Exception as screenshot_error:\n                    logger.warning(f\"âš ï¸  Final screenshot capture failed: {screenshot_error}\")\n            \n            logger.info(\"=\" * 80)\n            if len(steps) == 0:\n                logger.info(\"âŒ Execution Failed â€” No steps were executed successfully\")\n                logger.info(\"=\" * 80)\n                result = {\n                    \"success\": False,\n                    \"error\": \"Browser automation failed to execute any steps\",\n                    \"message\": \"No steps executed - browser may have failed to start\",\n                    \"steps\": [],\n                    \"iterations\": 0,\n                    \"final_result\": None\n                }\n            else:\n                logger.info(f\"âœ… Execution Completed Successfully\")\n                logger.info(f\"Total Steps: {len(steps)}\")\n                if final_result:\n                    logger.info(f\"Result: {str(final_result)[:150]}\")\n                logger.info(\"=\" * 80)\n                \n                result = {\n                    \"success\": True,\n                    \"message\": f\"Task completed successfully. Executed {len(steps)} steps.\",\n                    \"steps\": steps,\n                    \"iterations\": len(steps),\n                    \"final_result\": final_result,\n                    \"screenshot_paths\": screenshot_paths\n                }\n            \n            if self.enable_advanced_features:\n                if op_id:\n                    self.performance_monitor.end_operation(op_id, success=result[\"success\"])\n                \n                result[\"performance_metrics\"] = self.performance_monitor.get_summary()\n                \n                if self.workflow_state:\n                    result[\"workflow_state\"] = self.workflow_state.get_summary()\n                \n                result[\"retry_stats\"] = self.retry_mechanism.get_stats()\n            \n            return result\n            \n        except Exception as e:\n            error_msg = str(e)\n            logger.error(\"=\" * 80)\n            logger.error(f\"âŒ Execution Failed â€” {type(e).__name__}\")\n            logger.error(f\"Error: {error_msg}\")\n            logger.error(\"=\" * 80)\n            \n            if self.enable_advanced_features and op_id:\n                self.performance_monitor.end_operation(op_id, success=False)\n            \n            # Provide helpful error context\n            error_context = {\n                \"success\": False,\n                \"error\": error_msg,\n                \"error_type\": type(e).__name__,\n                \"steps\": [],\n                \"iterations\": 0\n            }\n            \n            # Add helpful hints based on error type\n            if \"timeout\" in error_msg.lower():\n                error_context[\"hint\"] = \"The operation timed out. Consider increasing the timeout or simplifying the task.\"\n            elif \"api\" in error_msg.lower() or \"oauth\" in error_msg.lower() or \"token\" in error_msg.lower():\n                error_context[\"hint\"] = \"Authentication error. Please check your OAuth configuration (OAUTH_TOKEN_URL, OAUTH_CLIENT_ID, OAUTH_CLIENT_SECRET, etc.).\"\n            elif \"playwright\" in error_msg.lower() or \"browser\" in error_msg.lower():\n                error_context[\"hint\"] = \"Browser initialization failed. Ensure Playwright is properly installed.\"\n            \n            if self.enable_advanced_features:\n                error_context[\"retry_stats\"] = self.retry_mechanism.get_stats()\n            \n            return error_context\n        finally:\n            # Clean up browser resources\n            if browser is not None:\n                try:\n                    # Browser cleanup is handled automatically by browser-use library\n                    # The Browser object manages its own lifecycle\n                    logger.debug(\"ðŸ§¹ Browser cleanup completed\")\n                except Exception as cleanup_error:\n                    logger.warning(f\"âš ï¸  Error during browser cleanup: {cleanup_error}\")\n    \n    def execute_instruction_sync(self, instruction: str, progress_callback=None, **kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Synchronous wrapper for execute_instruction\n        \n        Args:\n            instruction: User's natural language instruction\n            progress_callback: Optional callback for progress updates\n            **kwargs: Additional arguments for execute_instruction\n            \n        Returns:\n            Dictionary with execution results\n        \"\"\"\n        loop = None\n        try:\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            try:\n                return loop.run_until_complete(self.execute_instruction(instruction, progress_callback=progress_callback, **kwargs))\n            finally:\n                # Clean up pending tasks\n                pending = asyncio.all_tasks(loop)\n                for task in pending:\n                    task.cancel()\n                # Wait for cancelled tasks to finish\n                if pending:\n                    loop.run_until_complete(asyncio.gather(*pending, return_exceptions=True))\n                \n        except Exception as e:\n            logger.error(f\"Sync execution error: {str(e)}\", exc_info=True)\n            return {\n                \"success\": False,\n                \"error\": f\"Sync execution error: {str(e)}\",\n                \"steps\": [],\n                \"iterations\": 0\n            }\n        finally:\n            # Always close the event loop\n            if loop is not None:\n                try:\n                    loop.close()\n                    logger.debug(\"ðŸ§¹ Event loop closed successfully\")\n                except Exception as loop_error:\n                    logger.warning(f\"âš ï¸  Error closing event loop: {loop_error}\")\n    \n    def get_performance_summary(self) -> Dict[str, Any]:\n        \"\"\"Get performance monitoring summary\"\"\"\n        if self.enable_advanced_features:\n            return self.performance_monitor.get_summary()\n        return {\"error\": \"Advanced features not enabled\"}\n    \n    def get_retry_stats(self) -> Dict[str, Any]:\n        \"\"\"Get retry mechanism statistics\"\"\"\n        if self.enable_advanced_features:\n            return self.retry_mechanism.get_stats()\n        return {\"error\": \"Advanced features not enabled\"}\n    \n    def reset_metrics(self):\n        \"\"\"Reset all performance metrics and statistics\"\"\"\n        if self.enable_advanced_features:\n            self.performance_monitor.reset()\n            self.retry_mechanism.reset_stats()\n            logger.info(\"ðŸ”„ All metrics reset\")\n","size_bytes":31048},"app/static/js/navigation.js":{"content":"// Theme handling\nfunction initializeTheme() {\n    const savedTheme = localStorage.getItem('theme') || 'dark';\n    document.documentElement.setAttribute('data-theme', savedTheme);\n    updateThemeButton(savedTheme);\n}\n\nfunction updateThemeButton(theme) {\n    const themeToggle = document.getElementById('theme-toggle');\n    const themeIcon = document.getElementById('theme-icon');\n    const themeText = document.getElementById('theme-text');\n    \n    if (themeToggle && themeIcon && themeText) {\n        if (theme === 'light') {\n            themeIcon.setAttribute('data-feather', 'moon');\n            themeText.textContent = 'Dark';\n        } else {\n            themeIcon.setAttribute('data-feather', 'sun');\n            themeText.textContent = 'Light';\n        }\n        // Re-render feather icons\n        if (typeof feather !== 'undefined') {\n            feather.replace();\n        }\n    }\n}\n\nfunction toggleTheme() {\n    const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';\n    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';\n    \n    document.documentElement.setAttribute('data-theme', newTheme);\n    localStorage.setItem('theme', newTheme);\n    updateThemeButton(newTheme);\n}\n\n// Initialize theme immediately\ninitializeTheme();\n\n// Navigation and theme handling\ndocument.addEventListener('DOMContentLoaded', () => {\n    updateActiveNav();\n    initializeTheme();\n    \n    // Add theme toggle listener\n    const themeToggle = document.getElementById('theme-toggle');\n    if (themeToggle) {\n        themeToggle.addEventListener('click', toggleTheme);\n    }\n});\n\nfunction updateActiveNav() {\n    const currentPath = window.location.pathname;\n    const navItems = document.querySelectorAll('.nav-item');\n    \n    navItems.forEach(item => {\n        const href = item.getAttribute('href');\n        item.classList.remove('active');\n        if (href === currentPath || (currentPath === '/' && href === '/')) {\n            item.classList.add('active');\n        }\n    });\n}\n","size_bytes":2011},"app/services/intelligent_validator.py":{"content":"\"\"\"\nIntelligent Validation Service\nPerforms web scraping and validation to ensure accurate element locators and actions\n\"\"\"\nimport logging\nimport asyncio\nfrom typing import Dict, Any, List, Optional, Tuple\nfrom dataclasses import dataclass, field\nfrom playwright.async_api import async_playwright, Page, ElementHandle\nimport re\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass ElementValidation:\n    \"\"\"Result of element validation\"\"\"\n    exists: bool\n    locator: str\n    locator_strategy: str\n    confidence: float\n    element_info: Dict[str, Any]\n    alternatives: List[Dict[str, Any]] = field(default_factory=list)\n    warnings: List[str] = field(default_factory=list)\n    \n\n@dataclass\nclass PageValidation:\n    \"\"\"Result of page validation\"\"\"\n    url: str\n    title: str\n    is_accessible: bool\n    elements_found: List[ElementValidation]\n    page_structure: Dict[str, Any]\n    validation_time: float\n    \n\nclass IntelligentValidator:\n    \"\"\"\n    Validates web pages and elements through intelligent scraping\n    \n    Features:\n    - Scrapes pages to validate element existence\n    - Detects accurate locators with confidence scoring\n    - Provides alternative locators for robustness\n    - Analyzes page structure for better automation\n    - Suggests improvements for element targeting\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the validator\"\"\"\n        self.browser = None\n        self.context = None\n        self.page = None\n        \n    async def validate_task(\n        self,\n        url: str,\n        steps: List[Dict[str, Any]],\n        headless: bool = True\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Validate a complete automation task by scraping and verifying elements\n        \n        Args:\n            url: Target URL to validate\n            steps: List of steps with actions and targets\n            headless: Run browser in headless mode\n            \n        Returns:\n            Validation result with detailed element information\n        \"\"\"\n        logger.info(f\"ðŸ” Starting intelligent validation for {url}\")\n        \n        try:\n            # Initialize browser\n            await self._init_browser(headless)\n            \n            # Navigate and validate page\n            page_validation = await self._validate_page(url)\n            \n            if not page_validation.is_accessible:\n                return {\n                    'success': False,\n                    'error': f'Page {url} is not accessible',\n                    'page_validation': page_validation\n                }\n            \n            # Validate each step's elements\n            validated_steps = []\n            for step in steps:\n                validated_step = await self._validate_step(step, self.page)\n                validated_steps.append(validated_step)\n            \n            logger.info(f\"âœ… Validation complete: {len(validated_steps)} steps validated\")\n            \n            return {\n                'success': True,\n                'url': url,\n                'page_validation': page_validation,\n                'validated_steps': validated_steps,\n                'total_elements': len([s for s in validated_steps if s.get('element_valid')])\n            }\n            \n        except Exception as e:\n            logger.error(f\"âŒ Validation failed: {e}\", exc_info=True)\n            return {\n                'success': False,\n                'error': str(e)\n            }\n        finally:\n            await self._cleanup()\n    \n    async def _init_browser(self, headless: bool = True):\n        \"\"\"Initialize browser for validation\"\"\"\n        playwright = await async_playwright().start()\n        self.browser = await playwright.chromium.launch(headless=headless)\n        self.context = await self.browser.new_context(\n            viewport={'width': 1280, 'height': 720},\n            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n        )\n        self.page = await self.context.new_page()\n        \n    async def _cleanup(self):\n        \"\"\"Cleanup browser resources\"\"\"\n        if self.page:\n            await self.page.close()\n        if self.context:\n            await self.context.close()\n        if self.browser:\n            await self.browser.close()\n    \n    async def _validate_page(self, url: str) -> PageValidation:\n        \"\"\"Validate page accessibility and structure\"\"\"\n        import time\n        start_time = time.time()\n        \n        try:\n            # Navigate to page\n            response = await self.page.goto(url, wait_until='networkidle', timeout=30000)\n            \n            # Get page info\n            title = await self.page.title()\n            \n            # Analyze page structure\n            structure = await self._analyze_page_structure()\n            \n            elapsed = time.time() - start_time\n            \n            return PageValidation(\n                url=url,\n                title=title,\n                is_accessible=response.ok if response else False,\n                elements_found=[],\n                page_structure=structure,\n                validation_time=elapsed\n            )\n            \n        except Exception as e:\n            logger.error(f\"Page validation failed: {e}\")\n            return PageValidation(\n                url=url,\n                title='',\n                is_accessible=False,\n                elements_found=[],\n                page_structure={},\n                validation_time=time.time() - start_time\n            )\n    \n    async def _analyze_page_structure(self) -> Dict[str, Any]:\n        \"\"\"Analyze page structure for better automation\"\"\"\n        try:\n            # Count interactive elements\n            buttons = await self.page.locator('button').count()\n            links = await self.page.locator('a').count()\n            inputs = await self.page.locator('input').count()\n            selects = await self.page.locator('select').count()\n            \n            # Get forms\n            forms = await self.page.locator('form').count()\n            \n            # Check for common frameworks\n            frameworks = await self._detect_frameworks()\n            \n            return {\n                'interactive_elements': {\n                    'buttons': buttons,\n                    'links': links,\n                    'inputs': inputs,\n                    'selects': selects,\n                    'forms': forms\n                },\n                'frameworks': frameworks,\n                'has_spa': await self._detect_spa()\n            }\n            \n        except Exception as e:\n            logger.warning(f\"Page structure analysis failed: {e}\")\n            return {}\n    \n    async def _detect_frameworks(self) -> List[str]:\n        \"\"\"Detect frontend frameworks\"\"\"\n        frameworks = []\n        \n        try:\n            # Check for React\n            react_check = await self.page.evaluate(\n                \"() => !!window.React || !!document.querySelector('[data-reactroot]')\"\n            )\n            if react_check:\n                frameworks.append('React')\n            \n            # Check for Vue\n            vue_check = await self.page.evaluate(\n                \"() => !!window.Vue || !!document.querySelector('[data-v-]')\"\n            )\n            if vue_check:\n                frameworks.append('Vue')\n            \n            # Check for Angular\n            angular_check = await self.page.evaluate(\n                \"() => !!window.angular || !!document.querySelector('[ng-app], [ng-version]')\"\n            )\n            if angular_check:\n                frameworks.append('Angular')\n                \n        except Exception as e:\n            logger.debug(f\"Framework detection error: {e}\")\n        \n        return frameworks\n    \n    async def _detect_spa(self) -> bool:\n        \"\"\"Detect if page is a Single Page Application\"\"\"\n        try:\n            # Check for common SPA indicators\n            has_client_routing = await self.page.evaluate(\n                \"() => !!window.history.pushState && window.location.hash.length > 1\"\n            )\n            return has_client_routing\n        except:\n            return False\n    \n    async def _validate_step(\n        self,\n        step: Dict[str, Any],\n        page: Page\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Validate a single step by finding and verifying the target element\n        \n        Args:\n            step: Step dict with action, target, value, etc.\n            page: Playwright page object\n            \n        Returns:\n            Validated step with element information\n        \"\"\"\n        action = step.get('action', '').lower()\n        target = step.get('target', '')\n        \n        # Skip validation for navigation and wait actions\n        if action in ['navigate', 'wait', 'screenshot']:\n            return {\n                **step,\n                'element_valid': True,\n                'validation': ElementValidation(\n                    exists=True,\n                    locator='N/A',\n                    locator_strategy='N/A',\n                    confidence=1.0,\n                    element_info={}\n                )\n            }\n        \n        # Find and validate element\n        validation = await self._find_and_validate_element(page, target, action)\n        \n        return {\n            **step,\n            'element_valid': validation.exists,\n            'validation': validation,\n            'suggested_locator': validation.locator if validation.exists else None\n        }\n    \n    async def _find_and_validate_element(\n        self,\n        page: Page,\n        target: str,\n        action: str\n    ) -> ElementValidation:\n        \"\"\"\n        Find an element using multiple strategies and validate it\n        \n        Args:\n            page: Playwright page\n            target: Element description\n            action: Action type (click, fill, etc.)\n            \n        Returns:\n            ElementValidation result\n        \"\"\"\n        # Try multiple locator strategies in order of preference\n        strategies = [\n            ('role', self._try_role_locator),\n            ('text', self._try_text_locator),\n            ('label', self._try_label_locator),\n            ('placeholder', self._try_placeholder_locator),\n            ('css', self._try_css_locator)\n        ]\n        \n        alternatives = []\n        \n        for strategy_name, strategy_func in strategies:\n            try:\n                element, locator = await strategy_func(page, target, action)\n                \n                if element:\n                    # Get element information\n                    element_info = await self._extract_element_info(element)\n                    \n                    # Calculate confidence\n                    confidence = self._calculate_strategy_confidence(\n                        strategy_name, element_info, target\n                    )\n                    \n                    # This is our primary match\n                    if confidence > 0.7:\n                        return ElementValidation(\n                            exists=True,\n                            locator=locator,\n                            locator_strategy=strategy_name,\n                            confidence=confidence,\n                            element_info=element_info,\n                            alternatives=alternatives\n                        )\n                    else:\n                        # Add as alternative\n                        alternatives.append({\n                            'locator': locator,\n                            'strategy': strategy_name,\n                            'confidence': confidence\n                        })\n                        \n            except Exception as e:\n                logger.debug(f\"Strategy {strategy_name} failed: {e}\")\n                continue\n        \n        # No good match found\n        return ElementValidation(\n            exists=False,\n            locator='',\n            locator_strategy='none',\n            confidence=0.0,\n            element_info={},\n            alternatives=alternatives,\n            warnings=[f'Could not find element: {target}']\n        )\n    \n    async def _try_role_locator(\n        self,\n        page: Page,\n        target: str,\n        action: str\n    ) -> Tuple[Optional[ElementHandle], str]:\n        \"\"\"Try to find element using role-based locator\"\"\"\n        role = self._infer_role(target, action)\n        name = self._extract_name_from_target(target)\n        \n        if name:\n            locator = page.get_by_role(role, name=name)\n            locator_str = f'page.get_by_role(\"{role}\", name=\"{name}\")'\n        else:\n            locator = page.get_by_role(role).first\n            locator_str = f'page.get_by_role(\"{role}\").first'\n        \n        try:\n            await locator.wait_for(state='attached', timeout=2000)\n            element = await locator.element_handle(timeout=1000)\n            return element, locator_str\n        except:\n            return None, locator_str\n    \n    async def _try_text_locator(\n        self,\n        page: Page,\n        target: str,\n        action: str\n    ) -> Tuple[Optional[ElementHandle], str]:\n        \"\"\"Try to find element using text content\"\"\"\n        text = self._extract_name_from_target(target)\n        \n        if not text:\n            return None, ''\n        \n        locator = page.get_by_text(text, exact=False).first\n        locator_str = f'page.get_by_text(\"{text}\", exact=False).first'\n        \n        try:\n            await locator.wait_for(state='attached', timeout=2000)\n            element = await locator.element_handle(timeout=1000)\n            return element, locator_str\n        except:\n            return None, locator_str\n    \n    async def _try_label_locator(\n        self,\n        page: Page,\n        target: str,\n        action: str\n    ) -> Tuple[Optional[ElementHandle], str]:\n        \"\"\"Try to find element using label\"\"\"\n        label = self._extract_name_from_target(target)\n        \n        if not label or action not in ['fill', 'select']:\n            return None, ''\n        \n        locator = page.get_by_label(label, exact=False)\n        locator_str = f'page.get_by_label(\"{label}\", exact=False)'\n        \n        try:\n            await locator.wait_for(state='attached', timeout=2000)\n            element = await locator.element_handle(timeout=1000)\n            return element, locator_str\n        except:\n            return None, locator_str\n    \n    async def _try_placeholder_locator(\n        self,\n        page: Page,\n        target: str,\n        action: str\n    ) -> Tuple[Optional[ElementHandle], str]:\n        \"\"\"Try to find element using placeholder\"\"\"\n        placeholder = self._extract_name_from_target(target)\n        \n        if not placeholder or action != 'fill':\n            return None, ''\n        \n        locator = page.get_by_placeholder(placeholder, exact=False)\n        locator_str = f'page.get_by_placeholder(\"{placeholder}\", exact=False)'\n        \n        try:\n            await locator.wait_for(state='attached', timeout=2000)\n            element = await locator.element_handle(timeout=1000)\n            return element, locator_str\n        except:\n            return None, locator_str\n    \n    async def _try_css_locator(\n        self,\n        page: Page,\n        target: str,\n        action: str\n    ) -> Tuple[Optional[ElementHandle], str]:\n        \"\"\"Try to find element using CSS selector (last resort)\"\"\"\n        # Generate simple CSS based on action\n        if action == 'click':\n            selector = 'button, a, [role=\"button\"]'\n        elif action == 'fill':\n            selector = 'input[type=\"text\"], input[type=\"email\"], input[type=\"password\"], textarea'\n        elif action == 'select':\n            selector = 'select'\n        else:\n            selector = '*'\n        \n        text = self._extract_name_from_target(target)\n        if text:\n            selector = f'{selector}:has-text(\"{text[:30]}\")'\n        \n        locator = page.locator(selector).first\n        locator_str = f'page.locator(\"{selector}\").first'\n        \n        try:\n            await locator.wait_for(state='attached', timeout=2000)\n            element = await locator.element_handle(timeout=1000)\n            return element, locator_str\n        except:\n            return None, locator_str\n    \n    async def _extract_element_info(self, element: ElementHandle) -> Dict[str, Any]:\n        \"\"\"Extract detailed information about an element\"\"\"\n        try:\n            info = await element.evaluate('''(el) => ({\n                tag: el.tagName.toLowerCase(),\n                text: el.textContent?.trim() || '',\n                value: el.value || '',\n                type: el.type || '',\n                name: el.name || '',\n                id: el.id || '',\n                className: el.className || '',\n                placeholder: el.placeholder || '',\n                ariaLabel: el.getAttribute('aria-label') || '',\n                role: el.getAttribute('role') || '',\n                disabled: el.disabled || false,\n                visible: el.offsetWidth > 0 && el.offsetHeight > 0,\n                href: el.href || ''\n            })''')\n            return info\n        except Exception as e:\n            logger.warning(f\"Failed to extract element info: {e}\")\n            return {}\n    \n    def _calculate_strategy_confidence(\n        self,\n        strategy: str,\n        element_info: Dict[str, Any],\n        target: str\n    ) -> float:\n        \"\"\"Calculate confidence score for a strategy match\"\"\"\n        base_scores = {\n            'role': 0.90,\n            'label': 0.85,\n            'placeholder': 0.80,\n            'text': 0.75,\n            'css': 0.50\n        }\n        \n        score = base_scores.get(strategy, 0.50)\n        \n        # Bonus if element is visible\n        if element_info.get('visible'):\n            score += 0.05\n        \n        # Bonus if text matches well\n        elem_text = element_info.get('text', '').lower()\n        target_lower = target.lower()\n        if elem_text and target_lower in elem_text:\n            score += 0.05\n        \n        return min(1.0, score)\n    \n    def _infer_role(self, target: str, action: str) -> str:\n        \"\"\"Infer ARIA role from target and action\"\"\"\n        target_lower = target.lower()\n        \n        if any(kw in target_lower for kw in ['button', 'btn', 'submit']):\n            return 'button'\n        elif any(kw in target_lower for kw in ['link', 'anchor']):\n            return 'link'\n        elif any(kw in target_lower for kw in ['input', 'field', 'textbox']):\n            return 'textbox'\n        elif action == 'click':\n            return 'button'\n        elif action == 'fill':\n            return 'textbox'\n        else:\n            return 'button'\n    \n    def _extract_name_from_target(self, target: str) -> str:\n        \"\"\"Extract meaningful name from target description\"\"\"\n        # Remove noise words\n        noise = ['the', 'a', 'an', 'button', 'link', 'field', 'input', \n                 'box', 'element', 'form', 'select', 'dropdown']\n        \n        words = target.split()\n        filtered = [w for w in words if w.lower() not in noise]\n        \n        return ' '.join(filtered).strip() if filtered else target.strip()\n\n\ndef validate_task_sync(url: str, steps: List[Dict[str, Any]], headless: bool = True) -> Dict[str, Any]:\n    \"\"\"\n    Synchronous wrapper for validate_task\n    \n    Args:\n        url: Target URL\n        steps: List of automation steps\n        headless: Run headless\n        \n    Returns:\n        Validation result\n    \"\"\"\n    validator = IntelligentValidator()\n    return asyncio.run(validator.validate_task(url, steps, headless))\n","size_bytes":19597},"app/middleware/security.py":{"content":"\"\"\"\nSecurity Middleware\nAuthentication, rate limiting, and security utilities\n\"\"\"\nimport os\nimport time\nimport logging\nfrom functools import wraps\nfrom flask import request, jsonify\nfrom typing import Dict, Tuple, Optional\n\nlogger = logging.getLogger(__name__)\n\n\nclass RateLimiter:\n    \"\"\"Simple in-memory rate limiter\"\"\"\n    \n    def __init__(self, max_requests: int = 10, window_seconds: int = 60):\n        \"\"\"\n        Initialize rate limiter\n        \n        Args:\n            max_requests: Maximum requests allowed in the time window\n            window_seconds: Time window in seconds\n        \"\"\"\n        self.max_requests = max_requests\n        self.window_seconds = window_seconds\n        self.requests: Dict[str, list] = {}\n    \n    def is_allowed(self, client_id: str) -> Tuple[bool, Optional[int]]:\n        \"\"\"\n        Check if request is allowed for client\n        \n        Args:\n            client_id: Unique identifier for the client\n            \n        Returns:\n            Tuple of (is_allowed, retry_after_seconds)\n        \"\"\"\n        now = time.time()\n        \n        if client_id not in self.requests:\n            self.requests[client_id] = []\n        \n        requests = self.requests[client_id]\n        requests = [req_time for req_time in requests if now - req_time < self.window_seconds]\n        \n        if len(requests) >= self.max_requests:\n            oldest_request = min(requests)\n            retry_after = int(self.window_seconds - (now - oldest_request)) + 1\n            return False, retry_after\n        \n        requests.append(now)\n        self.requests[client_id] = requests\n        \n        self._cleanup_old_entries(now)\n        \n        return True, None\n    \n    def _cleanup_old_entries(self, now: float):\n        \"\"\"Clean up old entries to prevent memory bloat\"\"\"\n        clients_to_remove = []\n        for client_id, requests in self.requests.items():\n            active_requests = [req_time for req_time in requests if now - req_time < self.window_seconds]\n            if not active_requests:\n                clients_to_remove.append(client_id)\n            else:\n                self.requests[client_id] = active_requests\n        \n        for client_id in clients_to_remove:\n            del self.requests[client_id]\n\n\nrate_limiter = RateLimiter(max_requests=10, window_seconds=60)\n\n\ndef require_api_key(f):\n    \"\"\"\n    Decorator to require API key authentication\n    \n    Checks for API key in:\n    1. X-API-Key header\n    2. api_key query parameter\n    \n    Set API_KEY environment variable to enable authentication.\n    If API_KEY is not set, authentication is disabled (development mode).\n    \"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        expected_api_key = os.environ.get('API_KEY')\n        \n        if not expected_api_key:\n            logger.warning(\"âš ï¸  API_KEY not set - authentication disabled (development mode)\")\n            return f(*args, **kwargs)\n        \n        provided_api_key = request.headers.get('X-API-Key') or request.args.get('api_key')\n        \n        if not provided_api_key:\n            logger.warning(f\"ðŸ”’ Unauthorized request from {request.remote_addr} - no API key provided\")\n            return jsonify({\n                'success': False,\n                'error': 'Authentication required',\n                'message': 'Please provide an API key via X-API-Key header or api_key parameter'\n            }), 401\n        \n        if provided_api_key != expected_api_key:\n            logger.warning(f\"ðŸ”’ Unauthorized request from {request.remote_addr} - invalid API key\")\n            return jsonify({\n                'success': False,\n                'error': 'Invalid API key'\n            }), 403\n        \n        return f(*args, **kwargs)\n    \n    return decorated_function\n\n\ndef rate_limit(f):\n    \"\"\"\n    Decorator to apply rate limiting\n    \n    Uses IP address as client identifier\n    \"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        client_id = request.remote_addr or 'unknown'\n        \n        allowed, retry_after = rate_limiter.is_allowed(client_id)\n        \n        if not allowed:\n            logger.warning(f\"âš ï¸  Rate limit exceeded for {client_id}\")\n            return jsonify({\n                'success': False,\n                'error': 'Rate limit exceeded',\n                'message': f'Too many requests. Please try again in {retry_after} seconds.',\n                'retry_after': retry_after\n            }), 429\n        \n        return f(*args, **kwargs)\n    \n    return decorated_function\n\n\ndef validate_engine_type(engine_type: str) -> Tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate engine type parameter\n    \n    Args:\n        engine_type: Engine type to validate\n        \n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    valid_engines = ['browser_use', 'playwright_mcp']\n    \n    if engine_type not in valid_engines:\n        return False, f\"Invalid engine type '{engine_type}'. Must be one of: {', '.join(valid_engines)}\"\n    \n    return True, None\n\n\ndef validate_instruction(instruction: str) -> Tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate instruction parameter\n    \n    Args:\n        instruction: Instruction to validate\n        \n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    if not instruction or not instruction.strip():\n        return False, \"Instruction cannot be empty\"\n    \n    if len(instruction) > 5000:\n        return False, \"Instruction is too long (maximum 5000 characters)\"\n    \n    return True, None\n\n\ndef sanitize_error_message(error: Exception) -> str:\n    \"\"\"\n    Convert internal exception to user-safe error message\n    \n    Args:\n        error: Exception to sanitize\n        \n    Returns:\n        User-safe error message\n    \"\"\"\n    error_str = str(error).lower()\n    \n    if 'openai' in error_str or 'api' in error_str:\n        return \"AI service error. Please try again later.\"\n    \n    if 'browser' in error_str or 'playwright' in error_str:\n        return \"Browser automation error. Please try again.\"\n    \n    if 'timeout' in error_str:\n        return \"Operation timed out. The task took too long to complete.\"\n    \n    if 'permission' in error_str or 'denied' in error_str:\n        return \"Permission denied. Please check your access rights.\"\n    \n    return \"An unexpected error occurred. Please try again.\"\n","size_bytes":6336},"app/engines/playwright_mcp/server_manager.py":{"content":"\"\"\"\nPlaywright MCP Server Manager\nManages persistent MCP server instance when running in 'always_run' mode\n\"\"\"\nimport configparser\nimport logging\nimport threading\nfrom typing import Optional\nfrom app.engines.playwright_mcp.client.stdio_client import MCPStdioClient\n\nlogger = logging.getLogger(__name__)\n\n\nclass MCPServerManager:\n    \"\"\"\n    Singleton manager for Playwright MCP server\n    \n    Supports two modes:\n    - always_run: Keep server running continuously (faster, uses more resources)\n    - on_demand: Start server only when needed (saves resources)\n    \"\"\"\n    \n    _instance = None\n    _lock = threading.Lock()\n    _server_instance: Optional[MCPStdioClient] = None\n    _server_mode = \"on_demand\"\n    \n    def __new__(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super().__new__(cls)\n                    cls._instance._load_config()\n        return cls._instance\n    \n    def _load_config(self):\n        \"\"\"Load configuration from config.ini\"\"\"\n        config = configparser.ConfigParser()\n        try:\n            config.read('config/config.ini')\n            if config.has_section('playwright_mcp'):\n                self._server_mode = config.get('playwright_mcp', 'server_mode', fallback='on_demand')\n                logger.info(f\"ðŸ”§ MCP Server mode: {self._server_mode}\")\n            else:\n                logger.warning(\"âš ï¸  No [playwright_mcp] section in config, using on_demand mode\")\n        except Exception as e:\n            logger.error(f\"âŒ Failed to load MCP config: {e}, using on_demand mode\")\n    \n    def get_client(self, headless: bool = True, browser: str = 'chromium') -> MCPStdioClient:\n        \"\"\"\n        Get MCP client instance based on server mode\n        \n        Args:\n            headless: Run browser in headless mode\n            browser: Browser type to use\n            \n        Returns:\n            MCPStdioClient instance\n        \"\"\"\n        if self._server_mode == \"always_run\":\n            return self._get_persistent_client(headless, browser)\n        else:\n            return self._create_new_client(headless, browser)\n    \n    def _get_persistent_client(self, headless: bool, browser: str) -> MCPStdioClient:\n        \"\"\"\n        Get or create persistent MCP client for 'always_run' mode\n        \n        Args:\n            headless: Run browser in headless mode\n            browser: Browser type to use\n            \n        Returns:\n            Persistent MCPStdioClient instance\n        \"\"\"\n        with self._lock:\n            if self._server_instance is None:\n                logger.info(\"ðŸš€ Starting persistent MCP server (always_run mode)\")\n                self._server_instance = MCPStdioClient(headless=headless, browser=browser)\n                try:\n                    self._server_instance.initialize()\n                    logger.info(\"âœ… Persistent MCP server started and initialized\")\n                except Exception as e:\n                    logger.error(f\"âŒ Failed to initialize persistent MCP server: {e}\")\n                    self._server_instance = None\n                    raise\n            else:\n                # Check if server is still alive\n                if self._server_instance.process and self._server_instance.process.poll() is not None:\n                    logger.warning(\"âš ï¸  Persistent MCP server died, restarting...\")\n                    self._server_instance = MCPStdioClient(headless=headless, browser=browser)\n                    try:\n                        self._server_instance.initialize()\n                        logger.info(\"âœ… Persistent MCP server restarted\")\n                    except Exception as e:\n                        logger.error(f\"âŒ Failed to restart persistent MCP server: {e}\")\n                        self._server_instance = None\n                        raise\n            \n            return self._server_instance\n    \n    def _create_new_client(self, headless: bool, browser: str) -> MCPStdioClient:\n        \"\"\"\n        Create new MCP client for 'on_demand' mode\n        \n        Args:\n            headless: Run browser in headless mode\n            browser: Browser type to use\n            \n        Returns:\n            New MCPStdioClient instance\n        \"\"\"\n        logger.info(\"ðŸ”„ Creating on-demand MCP client\")\n        client = MCPStdioClient(headless=headless, browser=browser)\n        try:\n            client.initialize()\n            logger.info(\"âœ… On-demand MCP client initialized\")\n        except Exception as e:\n            logger.error(f\"âŒ Failed to initialize on-demand MCP client: {e}\")\n            raise\n        return client\n    \n    def shutdown_persistent_server(self):\n        \"\"\"Shutdown the persistent MCP server if running\"\"\"\n        with self._lock:\n            if self._server_instance is not None:\n                logger.info(\"ðŸ›‘ Shutting down persistent MCP server\")\n                try:\n                    self._server_instance.cleanup()\n                    logger.info(\"âœ… Persistent MCP server shut down\")\n                except Exception as e:\n                    logger.error(f\"âš ï¸  Error during server shutdown: {e}\")\n                finally:\n                    self._server_instance = None\n    \n    def get_server_mode(self) -> str:\n        \"\"\"Get current server mode (always_run or on_demand)\"\"\"\n        return self._server_mode\n    \n    def is_persistent_server_running(self) -> bool:\n        \"\"\"Check if persistent server is running\"\"\"\n        if self._server_mode != \"always_run\":\n            return False\n        \n        with self._lock:\n            if self._server_instance is None:\n                return False\n            \n            if self._server_instance.process is None:\n                return False\n            \n            return self._server_instance.process.poll() is None\n\n\n# Global instance\n_manager = MCPServerManager()\n\n\ndef get_mcp_client(headless: bool = True, browser: str = 'chromium') -> MCPStdioClient:\n    \"\"\"\n    Get MCP client instance (convenience function)\n    \n    Args:\n        headless: Run browser in headless mode\n        browser: Browser type to use\n        \n    Returns:\n        MCPStdioClient instance\n    \"\"\"\n    return _manager.get_client(headless=headless, browser=browser)\n\n\ndef shutdown_server():\n    \"\"\"Shutdown persistent MCP server if running (convenience function)\"\"\"\n    _manager.shutdown_persistent_server()\n\n\ndef get_server_status() -> dict:\n    \"\"\"Get server status information\"\"\"\n    return {\n        'mode': _manager.get_server_mode(),\n        'persistent_running': _manager.is_persistent_server_running()\n    }\n","size_bytes":6638},"app/static/js/dashboard.js":{"content":"// Load settings from localStorage\nlet currentMode = localStorage.getItem('browserMode') || 'headful';\nlet currentEngine = localStorage.getItem('automationEngine') || 'browser_use';\nlet isExecuting = false;\n\n// Function to toggle script panels visibility based on engine\nfunction toggleScriptPanels(engineType) {\n    const scriptPanelsContainer = document.getElementById('script-panels-container');\n    const browserUsePanelsContainer = document.getElementById('browser-use-panels-container');\n    const screenshotPanelSingle = document.getElementById('screenshot-panel-single');\n    \n    if (scriptPanelsContainer && browserUsePanelsContainer && screenshotPanelSingle) {\n        if (engineType === 'browser_use') {\n            scriptPanelsContainer.style.display = 'none';\n            browserUsePanelsContainer.style.display = 'grid';\n            screenshotPanelSingle.style.display = 'none';\n        } else {\n            scriptPanelsContainer.style.display = 'grid';\n            browserUsePanelsContainer.style.display = 'none';\n            screenshotPanelSingle.style.display = 'block';\n        }\n    }\n}\n\n// Helper function to get the active execution logs element\nfunction getActiveExecutionLogsElement() {\n    if (currentEngine === 'browser_use') {\n        return document.getElementById('execution-logs-single');\n    } else {\n        return document.getElementById('execution-logs-grid');\n    }\n}\n\n// Helper function to update execution logs in the active panel\nfunction updateExecutionLogs(htmlContent) {\n    const logsElement = getActiveExecutionLogsElement();\n    if (logsElement) {\n        logsElement.innerHTML = htmlContent;\n    }\n}\n\n// Helper function to get the active screenshot panel element\nfunction getActiveScreenshotPanelElement() {\n    if (currentEngine === 'browser_use') {\n        return document.getElementById('screenshot-panel-grid-content');\n    } else {\n        return document.getElementById('screenshot-panel-single-content');\n    }\n}\n\n// Function to show/hide healed script panel\nfunction toggleHealedScriptPanel(show) {\n    const healedContainer = document.getElementById('healed-script-container');\n    if (healedContainer) {\n        healedContainer.style.display = show ? 'block' : 'none';\n    }\n}\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    const executeBtn = document.getElementById('execute-automation');\n    const promptTextarea = document.getElementById('automation-prompt');\n    \n    // Initialize visibility on page load based on saved settings\n    toggleScriptPanels(currentEngine);\n    \n    if (executeBtn) {\n        executeBtn.addEventListener('click', async () => {\n            if (isExecuting) return;\n            \n            const instruction = promptTextarea.value.trim();\n            if (!instruction) {\n                alert('Please enter an automation instruction');\n                return;\n            }\n            \n            isExecuting = true;\n            executeBtn.disabled = true;\n            executeBtn.innerHTML = '<span class=\"spinner\"></span> Executing...';\n            \n            document.getElementById('generated-script').innerHTML = '<div style=\"color: var(--text-secondary);\">Waiting for automation to start...</div>';\n            getActiveExecutionLogsElement().innerHTML = '<div style=\"color: var(--text-secondary);\">Connecting to automation server...</div>';\n            \n            // Hide healed script panel at start (only show if healing occurs)\n            toggleHealedScriptPanel(false);\n            \n            // Hide copy button at start of execution\n            const copyBtn = document.getElementById('copy-playwright-code');\n            if (copyBtn) {\n                copyBtn.style.display = 'none';\n                copyBtn.onclick = null;\n            }\n            \n            let stepLogs = [];\n            \n            try {\n                const apiKey = localStorage.getItem('api_key');\n                \n                // Use Server-Sent Events for real-time streaming\n                const payload = {\n                    instruction: instruction,\n                    engine: currentEngine,\n                    headless: currentMode === 'headless'\n                };\n                \n                // Create SSE connection\n                const url = '/api/execute/stream';\n                const response = await fetch(url, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        ...(apiKey ? {'X-API-Key': apiKey} : {})\n                    },\n                    body: JSON.stringify(payload)\n                });\n                \n                // Handle non-OK HTTP responses before entering streaming loop\n                if (!response.ok) {\n                    let errorData;\n                    try {\n                        errorData = await response.json();\n                    } catch (e) {\n                        errorData = {error: 'Unknown error', message: 'Failed to get error details'};\n                    }\n                    \n                    // Reset script panel and hide copy button on error\n                    document.getElementById('generated-script').innerHTML = \n                        `<div class=\"empty-state\"><div>No script generated</div></div>`;\n                    const copyBtn = document.getElementById('copy-playwright-code');\n                    if (copyBtn) {\n                        copyBtn.style.display = 'none';\n                        copyBtn.onclick = null;\n                    }\n                    \n                    let errorMessage = '';\n                    if (response.status === 401 || response.status === 403) {\n                        errorMessage = 'ðŸ”’ Authentication Error<br>Please provide a valid API key.';\n                    } else if (response.status === 429) {\n                        errorMessage = 'â±ï¸ Rate Limit Exceeded<br>' + (errorData.message || 'Too many requests. Please try again later.');\n                    } else {\n                        errorMessage = `âŒ ${errorData.error || 'Error'}<br>${errorData.message || 'An unexpected error occurred'}`;\n                    }\n                    \n                    getActiveExecutionLogsElement().innerHTML = \n                        `<div style=\"color: var(--error-text);\">${errorMessage}</div>`;\n                    return;\n                }\n                \n                const reader = response.body.getReader();\n                const decoder = new TextDecoder();\n                let buffer = '';\n                \n                while (true) {\n                    const {done, value} = await reader.read();\n                    if (done) break;\n                    \n                    buffer += decoder.decode(value, {stream: true});\n                    const lines = buffer.split('\\n\\n');\n                    buffer = lines.pop() || '';\n                    \n                    for (const line of lines) {\n                        if (!line.trim() || !line.startsWith('data: ')) continue;\n                        \n                        try {\n                            const data = JSON.parse(line.substring(6));\n                            \n                            // Handle different event types from SSE stream\n                            if (data.type === 'start') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">ðŸš€ ${data.message || 'Starting...'}</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                                \n                                // Clear screenshot panel for new execution\n                                getActiveScreenshotPanelElement().innerHTML = '<div class=\"empty-state\"><div>Screenshots will appear here during execution</div></div>';\n                            } else if (data.type === 'init') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">âš™ï¸  Initializing automation...</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'browser_init') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">ðŸŒ Browser ready</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'agent_create') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">ðŸ¤– AI agent ready</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'execution_start') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">â–¶ï¸  Executing steps...</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'planner_init') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">ðŸŽ­ Planning automation...</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'generator_init') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">ðŸŽ¨ Preparing code generation...</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'generator_building') {\n                                stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 3px 0;\">ðŸ”§ Generating Python script...</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'generator_complete') {\n                                stepLogs.push(`<div style=\"color: var(--success-text); margin: 3px 0;\">âœ“ Script generated (${data.data.lines} lines)</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'healer_init') {\n                                stepLogs.push(`<div style=\"color: var(--warning-text); margin: 3px 0;\">ðŸ”§ Healing script...</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'healer_complete') {\n                                stepLogs.push(`<div style=\"color: var(--success-text); margin: 3px 0;\">âœ“ Script healed (${data.data.fixes} fixes applied)</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                            } else if (data.type === 'step') {\n                                stepLogs.push(`<div style=\"color: var(--success-text); margin: 3px 0;\">âœ“ ${data.data.action}</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                                // Auto-scroll to bottom\n                                const logsElement = getActiveExecutionLogsElement();\n                                logsElement.scrollTop = logsElement.scrollHeight;\n                            } else if (data.type === 'screenshot') {\n                                // Display screenshot in real-time - ACCUMULATE multiple screenshots\n                                const screenshotPanel = getActiveScreenshotPanelElement();\n                                const screenshotPath = data.data.path;\n                                const screenshotUrl = data.data.url || '';\n                                const stepNumber = data.data.step_number || 'N/A';\n                                \n                                // Convert local file path to URL (assuming static serving)\n                                const publicPath = screenshotPath.replace(/\\\\/g, '/');\n                                \n                                // Clear the empty state if it's the first screenshot\n                                if (screenshotPanel.querySelector('.empty-state')) {\n                                    screenshotPanel.innerHTML = '';\n                                }\n                                \n                                // Add screenshot to the panel (accumulate, don't replace)\n                                const screenshotDiv = document.createElement('div');\n                                screenshotDiv.style.cssText = 'margin-bottom: 15px; padding: 10px; border: 1px solid var(--border); border-radius: 4px; background: var(--panel-bg);';\n                                screenshotDiv.innerHTML = `\n                                    <div style=\"text-align: center;\">\n                                        <div style=\"margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem; font-weight: 600;\">Step ${stepNumber}</div>\n                                        <img src=\"/${publicPath}\" alt=\"Step ${stepNumber} Screenshot\" \n                                             style=\"max-width: 100%; height: auto; border-radius: 4px; cursor: pointer; border: 1px solid var(--border);\" \n                                             onclick=\"window.open('/${publicPath}', '_blank')\"\n                                             onerror=\"this.parentElement.innerHTML='<div style=\\\\'color: var(--error-text); padding: 20px;\\\\'>Screenshot capture failed</div>'\">\n                                        ${screenshotUrl ? `<div style=\"margin-top: 8px; color: var(--text-secondary); font-size: 0.85rem;\">ðŸ“ ${screenshotUrl}</div>` : ''}\n                                    </div>`;\n                                screenshotPanel.appendChild(screenshotDiv);\n                                \n                                // Auto-scroll to the latest screenshot\n                                screenshotPanel.scrollTop = screenshotPanel.scrollHeight;\n                                \n                                stepLogs.push(`<div style=\"color: var(--success-text); margin: 3px 0;\">ðŸ“¸ Screenshot saved</div>`);\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                                \n                                // Auto-scroll execution logs\n                                const logsElement = getActiveExecutionLogsElement();\n                                logsElement.scrollTop = logsElement.scrollHeight;\n                            } else if (data.type === 'done') {\n                                const result = data.result;\n                                \n                                // Display generated code in the Generated Script panel\n                                const scriptPanel = document.getElementById('generated-script');\n                                const copyBtn = document.getElementById('copy-playwright-code');\n                                \n                                if (result.playwright_code) {\n                                    // Show the code with syntax highlighting\n                                    scriptPanel.innerHTML = \n                                        `<pre style=\"color: var(--success-text); margin: 0; white-space: pre-wrap; font-size: 0.85rem; font-family: 'Monaco', 'Courier New', monospace; line-height: 1.5;\"><code class=\"language-python\">${escapeHtml(result.playwright_code)}</code></pre>`;\n                                    \n                                    // Show copy button\n                                    copyBtn.style.display = 'block';\n                                    copyBtn.onclick = () => copyToClipboard(result.playwright_code);\n                                } else {\n                                    // No code generated - reset to empty state\n                                    scriptPanel.innerHTML = \n                                        `<div class=\"empty-state\">\n                                            <div>No script generated for this automation</div>\n                                        </div>`;\n                                    \n                                    // Hide copy button and clear handler\n                                    copyBtn.style.display = 'none';\n                                    copyBtn.onclick = null;\n                                }\n                                \n                                // Display healed code in the Healed Script panel if available\n                                const healedScriptPanel = document.getElementById('healed-script');\n                                if (result.healed_code) {\n                                    // Show healed script panel since healing occurred\n                                    toggleHealedScriptPanel(true);\n                                    healedScriptPanel.innerHTML = \n                                        `<pre style=\"color: var(--warning-text); margin: 0; white-space: pre-wrap; font-size: 0.85rem; font-family: 'Monaco', 'Courier New', monospace; line-height: 1.5;\"><code class=\"language-python\">${escapeHtml(result.healed_code)}</code></pre>`;\n                                } else {\n                                    // No healed code - keep panel hidden\n                                    toggleHealedScriptPanel(false);\n                                }\n                                \n                                // Add final summary\n                                stepLogs.push(`<div style=\"color: var(--success-text); margin-top: 10px; font-weight: bold;\">âœ… Completed (${result.iterations || 0} steps)</div>`);\n                                if (result.final_result) {\n                                    stepLogs.push(`<div style=\"color: var(--success-text); margin-top: 5px;\">${result.final_result}</div>`);\n                                }\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                                \n                                // Auto-scroll to bottom\n                                const logsElement = getActiveExecutionLogsElement();\n                                logsElement.scrollTop = logsElement.scrollHeight;\n                                break;\n                            } else if (data.type === 'error') {\n                                // Reset script panel and hide copy button on error\n                                document.getElementById('generated-script').innerHTML = \n                                    `<div class=\"empty-state\"><div>No script generated due to error</div></div>`;\n                                const copyBtn = document.getElementById('copy-playwright-code');\n                                if (copyBtn) {\n                                    copyBtn.style.display = 'none';\n                                    copyBtn.onclick = null;\n                                }\n                                \n                                // Check if this is a verification failure\n                                const isVerificationError = data.error_type === 'VerificationError' || \n                                                           (data.error && data.error.includes('Verification failed'));\n                                \n                                if (isVerificationError) {\n                                    // Display verification failure with special formatting\n                                    stepLogs.push(`<div style=\"color: var(--error-text); font-weight: bold; margin-top: 10px; padding: 10px; border: 2px solid var(--error-text); border-radius: 4px; background: rgba(220, 38, 38, 0.1);\">âš ï¸ VERIFICATION FAILED</div>`);\n                                    stepLogs.push(`<div style=\"color: var(--error-text); margin: 5px 0; padding: 8px; background: rgba(220, 38, 38, 0.05); border-radius: 4px;\">${data.error || 'Verification step did not pass'}</div>`);\n                                    stepLogs.push(`<div style=\"color: var(--text-secondary); margin: 5px 0; font-size: 0.9rem;\">The automation detected that a required verification condition was not satisfied. Please review the execution logs above for details.</div>`);\n                                } else {\n                                    // Display regular error\n                                    stepLogs.push(`<div style=\"color: var(--error-text); font-weight: bold; margin-top: 10px;\">âŒ ${data.error || 'Execution failed'}</div>`);\n                                }\n                                \n                                if (data.message && !isVerificationError) {\n                                    stepLogs.push(`<pre style=\"color: var(--error-text); margin: 5px 0; white-space: pre-wrap; font-size: 0.85rem;\">${data.message}</pre>`);\n                                }\n                                getActiveExecutionLogsElement().innerHTML = stepLogs.join('');\n                                break;\n                            }\n                        } catch (parseError) {\n                            console.error('Failed to parse SSE data:', parseError);\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error('Execution error:', error);\n                // Reset script panel and hide copy button on network error\n                document.getElementById('generated-script').innerHTML = \n                    `<div class=\"empty-state\"><div>No script generated due to network error</div></div>`;\n                const copyBtn = document.getElementById('copy-playwright-code');\n                if (copyBtn) {\n                    copyBtn.style.display = 'none';\n                    copyBtn.onclick = null;\n                }\n                getActiveExecutionLogsElement().innerHTML = \n                    `<div style=\"color: var(--error-text);\">âŒ Network Error<br>Failed to execute automation: ${error.message}</div>`;\n            } finally {\n                isExecuting = false;\n                executeBtn.disabled = false;\n                executeBtn.innerHTML = '<span>â–¶ï¸</span> Execute Automation';\n            }\n        });\n    }\n});\n\n// Helper function to escape HTML\nfunction escapeHtml(text) {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n}\n\n// Helper function to copy text to clipboard\nasync function copyToClipboard(text) {\n    try {\n        await navigator.clipboard.writeText(text);\n        const copyBtn = document.getElementById('copy-playwright-code');\n        const originalContent = copyBtn.innerHTML;\n        copyBtn.innerHTML = '<i data-feather=\"check\"></i>';\n        feather.replace();\n        setTimeout(() => {\n            copyBtn.innerHTML = originalContent;\n            feather.replace();\n        }, 2000);\n    } catch (err) {\n        console.error('Failed to copy:', err);\n        alert('Failed to copy code to clipboard');\n    }\n}\n","size_bytes":23227},"app/engines/browser_use/__init__.py":{"content":"\"\"\"\nBrowser-Use Codebase\nAI-powered browser automation using browser-use library with LLM reasoning\n\"\"\"\nfrom app.engines.browser_use.engine_optimized import OptimizedBrowserUseEngine\n\n\ndef create_engine(headless: bool = False):\n    \"\"\"\n    Factory function to create an optimized Browser-Use engine instance\n    \n    The engine will automatically select the appropriate LLM model based on config.ini:\n    - If use_chat_browser_use=true, uses ChatBrowserUse (3-5x faster)\n    - Otherwise uses standard OpenAI models\n    \n    Args:\n        headless: Run browser in headless mode\n        \n    Returns:\n        OptimizedBrowserUseEngine instance with advanced features enabled\n    \"\"\"\n    return OptimizedBrowserUseEngine(headless=headless, enable_advanced_features=True)\n\n\n__all__ = ['OptimizedBrowserUseEngine', 'create_engine']\n","size_bytes":827},"app/engines/playwright_mcp/client/stdio_client.py":{"content":"\"\"\"\nSTDIO-based MCP Client for Playwright MCP Server\nLaunches MCP server as subprocess and communicates via JSON-RPC over stdio\n\"\"\"\nimport json\nimport os\nimport subprocess\nimport threading\nimport queue\nimport configparser\nfrom typing import Dict, List, Any, Optional\nimport time\n\n\nclass MCPStdioClient:\n    \"\"\"Client for Model Context Protocol communication via STDIO transport\"\"\"\n    \n    def __init__(self, headless: bool = True, browser: str = 'chromium'):\n        \"\"\"\n        Initialize MCP client with subprocess\n        \n        Args:\n            headless: Run browser in headless mode (defaults to True)\n            browser: Browser to use (defaults to 'chromium')\n        \"\"\"\n        # Only read browser type from config, not headless mode\n        # User's UI selection for headless should take precedence\n        config = configparser.ConfigParser()\n        try:\n            config.read('config/config.ini')\n            if config.has_section('browser'):\n                # Only override browser type, not headless setting\n                browser = config.get('browser', 'browser', fallback=browser)\n        except Exception:\n            # Use the provided defaults if config file is missing or invalid\n            pass\n        \n        self.request_id = 0\n        self.initialized = False\n        self.available_tools = []\n        self.process = None\n        self.response_queue = queue.Queue()\n        self.pending_requests = {}\n        self.reader_thread = None\n        self.stderr_thread = None\n        \n        args = [\"node\", \"integrations/playwright_mcp_node/cli.js\"]\n        if headless:\n            args.append(\"--headless\")\n        args.append(f\"--browser={browser}\")\n        \n        env = os.environ.copy()\n        env['PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS'] = '1'\n        \n        self.process = subprocess.Popen(\n            args,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            encoding='utf-8',\n            errors='replace',\n            bufsize=1,\n            env=env\n        )\n        \n        self.reader_thread = threading.Thread(target=self._read_responses, daemon=True)\n        self.reader_thread.start()\n        \n        self.stderr_thread = threading.Thread(target=self._read_stderr, daemon=True)\n        self.stderr_thread.start()\n        \n        time.sleep(0.2)\n    \n    def _read_responses(self):\n        \"\"\"Background thread to read responses from subprocess\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stdout.readline()\n                    if not line:\n                        break\n                        \n                    line = line.strip()\n                    if not line:\n                        continue\n                    \n                    try:\n                        response = json.loads(line)\n                        if \"id\" in response:\n                            req_id = response[\"id\"]\n                            if req_id in self.pending_requests:\n                                self.pending_requests[req_id].put(response)\n                        else:\n                            self.response_queue.put(response)\n                    except json.JSONDecodeError:\n                        pass\n                except UnicodeDecodeError:\n                    continue\n        except Exception as e:\n            print(f\"Reader thread error: {e}\")\n    \n    def _read_stderr(self):\n        \"\"\"Background thread to drain stderr and prevent deadlock\"\"\"\n        try:\n            while self.process and self.process.poll() is None:\n                try:\n                    line = self.process.stderr.readline()\n                    if not line:\n                        break\n                except Exception:\n                    continue\n        except Exception as e:\n            print(f\"Stderr thread error: {e}\")\n    \n    def _next_id(self) -> int:\n        \"\"\"Generate next request ID\"\"\"\n        self.request_id += 1\n        return self.request_id\n    \n    def _make_request(self, method: str, params: Optional[Dict] = None, timeout: int = 30) -> Dict:\n        \"\"\"\n        Make a JSON-RPC request via STDIO\n        \n        Args:\n            method: JSON-RPC method name\n            params: Optional parameters for the method\n            timeout: Request timeout in seconds\n            \n        Returns:\n            Response from the server\n        \"\"\"\n        if not self.process or self.process.poll() is not None:\n            raise Exception(\"MCP server process is not running\")\n        \n        request_id = self._next_id()\n        payload = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"id\": request_id\n        }\n        \n        if params is not None:\n            payload[\"params\"] = params\n        \n        response_queue = queue.Queue()\n        self.pending_requests[request_id] = response_queue\n        \n        try:\n            request_line = json.dumps(payload) + \"\\n\"\n            self.process.stdin.write(request_line)\n            self.process.stdin.flush()\n            \n            try:\n                response = response_queue.get(timeout=timeout)\n                \n                if \"error\" in response:\n                    raise Exception(f\"MCP Error: {response['error']}\")\n                \n                return response.get(\"result\", {})\n                \n            except queue.Empty:\n                raise Exception(f\"Request timeout after {timeout}s\")\n                \n        finally:\n            if request_id in self.pending_requests:\n                del self.pending_requests[request_id]\n    \n    def initialize(self) -> Dict:\n        \"\"\"Initialize the MCP connection\"\"\"\n        if self.initialized:\n            return {\"status\": \"already_initialized\"}\n        \n        result = self._make_request(\"initialize\", {\n            \"protocolVersion\": \"2024-11-05\",\n            \"capabilities\": {\n                \"roots\": {\"listChanged\": False}\n            },\n            \"clientInfo\": {\n                \"name\": \"playwright-web-agent\",\n                \"version\": \"1.0.0\"\n            }\n        })\n        \n        self.initialized = True\n        return result\n    \n    def list_tools(self) -> List[Dict]:\n        \"\"\"\n        List available tools from the MCP server\n        \n        Returns:\n            List of available tools with their schemas\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/list\", {})\n        self.available_tools = result.get(\"tools\", [])\n        return self.available_tools\n    \n    def call_tool(self, tool_name: str, arguments: Dict) -> Dict:\n        \"\"\"\n        Call a tool on the MCP server\n        \n        Args:\n            tool_name: Name of the tool to call\n            arguments: Arguments for the tool\n            \n        Returns:\n            Tool execution result\n        \"\"\"\n        if not self.initialized:\n            self.initialize()\n        \n        result = self._make_request(\"tools/call\", {\n            \"name\": tool_name,\n            \"arguments\": arguments\n        }, timeout=90)\n        \n        return result\n    \n    def get_tools_schema(self) -> List[Dict]:\n        \"\"\"\n        Get tools in OpenAI function calling format\n        \n        Returns:\n            List of tools formatted for OpenAI\n        \"\"\"\n        if not self.available_tools:\n            self.list_tools()\n        \n        openai_tools = []\n        for tool in self.available_tools:\n            openai_tool = {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": tool[\"name\"],\n                    \"description\": tool.get(\"description\", \"\"),\n                    \"parameters\": tool.get(\"inputSchema\", {\n                        \"type\": \"object\",\n                        \"properties\": {},\n                        \"required\": []\n                    })\n                }\n            }\n            openai_tools.append(openai_tool)\n        \n        return openai_tools\n    \n    def close(self):\n        \"\"\"Close the MCP client and subprocess\"\"\"\n        if self.process:\n            try:\n                self.call_tool(\"browser_close\", {})\n            except:\n                pass\n            \n            self.process.terminate()\n            self.process.wait(timeout=5)\n            self.process = None\n    \n    def __del__(self):\n        \"\"\"Cleanup on deletion\"\"\"\n        self.close()\n","size_bytes":8514},"app/static/css/dark-theme.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\n:root {\n    --bg-dark: #0a0e1a;\n    --bg-sidebar: #111827;\n    --bg-panel: #1a1f35;\n    --bg-panel-hover: #1e2640;\n    --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    --primary-blue: #667eea;\n    --primary-purple: #764ba2;\n    --primary-blue-hover: #5568d3;\n    --accent-cyan: #06b6d4;\n    --accent-pink: #ec4899;\n    --text-primary: #f8fafc;\n    --text-secondary: #94a3b8;\n    --text-muted: #64748b;\n    --border-color: #2d3748;\n    --success-bg: #065f46;\n    --success-text: #10b981;\n    --error-bg: #991b1b;\n    --error-text: #ef4444;\n    --warning-bg: #92400e;\n    --warning-text: #f59e0b;\n    --glow-purple: rgba(118, 75, 162, 0.4);\n    --glow-blue: rgba(102, 126, 234, 0.4);\n}\n\n[data-theme=\"light\"] {\n    --bg-dark: #f8fafc;\n    --bg-sidebar: #ffffff;\n    --bg-panel: #ffffff;\n    --bg-panel-hover: #f1f5f9;\n    --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    --primary-blue: #667eea;\n    --primary-purple: #764ba2;\n    --primary-blue-hover: #5568d3;\n    --accent-cyan: #06b6d4;\n    --accent-pink: #ec4899;\n    --text-primary: #0f172a;\n    --text-secondary: #475569;\n    --text-muted: #64748b;\n    --border-color: #e2e8f0;\n    --success-bg: #d1fae5;\n    --success-text: #059669;\n    --error-bg: #fee2e2;\n    --error-text: #dc2626;\n    --warning-bg: #fef3c7;\n    --warning-text: #d97706;\n    --glow-purple: rgba(118, 75, 162, 0.15);\n    --glow-blue: rgba(102, 126, 234, 0.15);\n}\n\nhtml {\n    background: var(--bg-dark);\n    transition: background-color 0.3s ease;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: var(--bg-dark);\n    color: var(--text-primary);\n    min-height: 100vh;\n    margin: 0;\n    padding: 0;\n    line-height: 1.6;\n    background-image: \n        radial-gradient(at 0% 0%, rgba(102, 126, 234, 0.05) 0px, transparent 50%),\n        radial-gradient(at 100% 100%, rgba(118, 75, 162, 0.05) 0px, transparent 50%);\n}\n\n@keyframes fadeIn {\n    from { opacity: 0; transform: translateY(10px); }\n    to { opacity: 1; transform: translateY(0); }\n}\n\n.main-content {\n    opacity: 1;\n    animation: fadeIn 0.5s ease-out;\n}\n\n.app-container {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    width: 260px;\n    background: var(--bg-sidebar);\n    padding: 24px 0;\n    display: flex;\n    flex-direction: column;\n    position: fixed;\n    height: 100vh;\n    left: 0;\n    top: 0;\n    border-right: 1px solid var(--border-color);\n    backdrop-filter: blur(10px);\n}\n\n.sidebar-header {\n    padding: 0 20px 24px;\n    display: flex;\n    align-items: center;\n    gap: 12px;\n}\n\n.sidebar-logo {\n    width: 40px;\n    height: 40px;\n    background: var(--primary-gradient);\n    border-radius: 10px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 1.2rem;\n    box-shadow: 0 4px 12px var(--glow-purple);\n    animation: pulse 3s ease-in-out infinite;\n}\n\n@keyframes pulse {\n    0%, 100% { box-shadow: 0 4px 12px var(--glow-purple); }\n    50% { box-shadow: 0 6px 20px var(--glow-blue); }\n}\n\n.sidebar-title {\n    font-size: 1.1rem;\n    font-weight: 700;\n    letter-spacing: -0.02em;\n    background: var(--primary-gradient);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n.sidebar-subtitle {\n    font-size: 0.65rem;\n    color: var(--accent-cyan);\n    font-weight: 600;\n    letter-spacing: 0.15em;\n    text-transform: uppercase;\n}\n\n.sidebar-nav {\n    flex: 1;\n    padding: 0 12px;\n}\n\n.nav-section {\n    margin-bottom: 32px;\n}\n\n.nav-section-title {\n    font-size: 0.65rem;\n    text-transform: uppercase;\n    color: var(--text-muted);\n    padding: 0 12px 12px;\n    letter-spacing: 0.1em;\n    font-weight: 700;\n}\n\n.nav-item {\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    padding: 12px 14px;\n    margin-bottom: 4px;\n    border-radius: 10px;\n    color: var(--text-secondary);\n    text-decoration: none;\n    transition: all 0.2s ease;\n    cursor: pointer;\n    font-size: 0.9rem;\n    font-weight: 500;\n    position: relative;\n    overflow: hidden;\n}\n\n.nav-item::before {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    height: 100%;\n    width: 0;\n    background: var(--primary-gradient);\n    transition: width 0.3s ease;\n    border-radius: 10px;\n}\n\n.nav-item:hover::before {\n    width: 4px;\n}\n\n.nav-item:hover {\n    background: var(--bg-panel-hover);\n    color: var(--text-primary);\n    transform: translateX(2px);\n}\n\n.nav-item.active {\n    background: var(--primary-gradient);\n    color: white;\n    box-shadow: 0 4px 12px var(--glow-purple);\n}\n\n.nav-item.active::before {\n    width: 0;\n}\n\n.nav-icon {\n    font-size: 1rem;\n    width: 20px;\n    text-align: center;\n}\n\n.sidebar-footer {\n    padding: 16px 20px;\n    border-top: 1px solid var(--border-color);\n}\n\n.version-info {\n    font-size: 0.75rem;\n    color: var(--text-muted);\n    font-weight: 600;\n}\n\n.main-content {\n    margin: 0 auto;\n    padding: 40px 48px;\n    padding-left: calc(260px + 48px);\n    max-width: calc(1400px + 260px);\n    width: 100%;\n}\n\n.page-header {\n    margin-bottom: 32px;\n}\n\n.page-title {\n    font-size: 2.25rem;\n    font-weight: 800;\n    margin-bottom: 8px;\n    letter-spacing: -0.03em;\n    background: linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n}\n\n.page-description {\n    color: var(--text-secondary);\n    font-size: 1rem;\n}\n\n.btn {\n    padding: 10px 20px;\n    border-radius: 10px;\n    font-size: 0.9rem;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    border: none;\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    position: relative;\n    overflow: hidden;\n}\n\n.btn::before {\n    content: '';\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 0;\n    height: 0;\n    border-radius: 50%;\n    background: rgba(255, 255, 255, 0.1);\n    transform: translate(-50%, -50%);\n    transition: width 0.6s, height 0.6s;\n}\n\n.btn:hover::before {\n    width: 300px;\n    height: 300px;\n}\n\n.btn-primary {\n    background: var(--primary-gradient);\n    color: white;\n    box-shadow: 0 4px 12px var(--glow-purple);\n}\n\n.btn-primary:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 6px 20px var(--glow-blue);\n}\n\n.btn-secondary {\n    background: var(--bg-panel);\n    color: var(--text-secondary);\n    border: 1px solid var(--border-color);\n}\n\n.btn-secondary:hover {\n    background: var(--bg-panel-hover);\n    color: var(--text-primary);\n    border-color: var(--primary-blue);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.panel {\n    background: var(--bg-panel);\n    border-radius: 16px;\n    padding: 28px;\n    border: 1px solid var(--border-color);\n    margin-bottom: 24px;\n    transition: all 0.3s ease;\n    position: relative;\n}\n\n.panel:hover {\n    border-color: var(--primary-blue);\n    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);\n}\n\n.panel-header {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-bottom: 20px;\n}\n\n.panel-title {\n    font-size: 1rem;\n    font-weight: 700;\n    color: var(--text-primary);\n}\n\n.panel-icon {\n    font-size: 1.1rem;\n    color: var(--primary-blue);\n}\n\n.textarea-large {\n    width: 100%;\n    background: var(--bg-dark);\n    border: 2px solid var(--border-color);\n    border-radius: 12px;\n    padding: 16px;\n    color: var(--text-primary);\n    font-family: inherit;\n    font-size: 0.95rem;\n    resize: vertical;\n    min-height: 180px;\n    line-height: 1.7;\n    transition: all 0.3s ease;\n}\n\n.textarea-large:focus {\n    outline: none;\n    border-color: var(--primary-blue);\n    box-shadow: 0 0 0 4px var(--glow-blue);\n    transform: scale(1.01);\n}\n\n.textarea-large::placeholder {\n    color: var(--text-muted);\n}\n\n.execute-btn {\n    width: 100%;\n    padding: 16px;\n    background: var(--primary-gradient);\n    color: white;\n    border: none;\n    border-radius: 12px;\n    font-size: 1.05rem;\n    font-weight: 700;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    margin-top: 20px;\n    box-shadow: 0 4px 16px var(--glow-purple);\n    position: relative;\n    overflow: hidden;\n}\n\n.execute-btn::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: -100%;\n    width: 100%;\n    height: 100%;\n    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);\n    transition: left 0.5s;\n}\n\n.execute-btn:hover::before {\n    left: 100%;\n}\n\n.execute-btn:hover:not(:disabled) {\n    transform: translateY(-3px);\n    box-shadow: 0 8px 24px var(--glow-blue);\n}\n\n.execute-btn:active {\n    transform: translateY(-1px);\n}\n\n.execute-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.grid-2 {\n    display: grid;\n    grid-template-columns: repeat(2, 1fr);\n    gap: 24px;\n}\n\n.output-panel {\n    background: var(--bg-dark);\n    border: 1px solid var(--border-color);\n    border-radius: 12px;\n    padding: 20px;\n    height: 350px;\n    overflow-y: auto;\n    overflow-x: auto;\n    color: var(--text-muted);\n    font-size: 0.875rem;\n}\n\n.output-panel .empty-state {\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0.5;\n}\n\n.output-panel pre,\n.output-panel code {\n    white-space: pre-wrap;\n    word-wrap: break-word;\n    margin: 0;\n    color: var(--success-text);\n}\n\n.output-panel img {\n    max-width: 100%;\n    height: auto;\n    display: block;\n    border-radius: 8px;\n}\n\n.badge {\n    display: inline-block;\n    padding: 6px 12px;\n    border-radius: 6px;\n    font-size: 0.7rem;\n    font-weight: 700;\n    text-transform: uppercase;\n    letter-spacing: 0.05em;\n}\n\n.badge-smart {\n    background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));\n    color: var(--primary-blue);\n    border: 1px solid var(--primary-blue);\n}\n\n.mode-toggle {\n    display: inline-flex;\n    background: var(--bg-dark);\n    border-radius: 12px;\n    padding: 4px;\n    gap: 4px;\n    border: 2px solid var(--border-color);\n}\n\n.mode-toggle-btn {\n    padding: 12px 20px;\n    border-radius: 10px;\n    background: transparent;\n    border: none;\n    color: var(--text-secondary);\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-size: 0.9rem;\n    font-weight: 600;\n    position: relative;\n    overflow: hidden;\n}\n\n.mode-toggle-btn::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: var(--primary-gradient);\n    opacity: 0;\n    transition: opacity 0.3s ease;\n    border-radius: 10px;\n}\n\n.mode-toggle-btn span {\n    position: relative;\n    z-index: 1;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.mode-toggle-btn.active {\n    color: white;\n    box-shadow: 0 4px 12px var(--glow-purple);\n    transform: scale(1.05);\n}\n\n.mode-toggle-btn.active::before {\n    opacity: 1;\n}\n\n.mode-toggle-btn:hover:not(.active) {\n    color: var(--text-primary);\n    background: var(--bg-panel-hover);\n}\n\n.theme-toggle {\n    background: var(--bg-panel);\n    border: 1px solid var(--border-color);\n    border-radius: 10px;\n    padding: 10px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.theme-toggle:hover {\n    transform: rotate(180deg);\n    border-color: var(--primary-blue);\n}\n\n.spinner {\n    display: inline-block;\n    width: 18px;\n    height: 18px;\n    border: 3px solid rgba(255, 255, 255, 0.2);\n    border-top-color: white;\n    border-radius: 50%;\n    animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n    to { transform: rotate(360deg); }\n}\n\n.history-card {\n    background: var(--bg-panel);\n    border: 1px solid var(--border-color);\n    border-radius: 16px;\n    padding: 28px;\n    margin-bottom: 24px;\n    transition: all 0.3s ease;\n    position: relative;\n}\n\n.history-card:hover {\n    border-color: var(--primary-blue);\n    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);\n    transform: translateY(-2px);\n}\n\n.history-status {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px 16px;\n    border-radius: 8px;\n    font-size: 0.875rem;\n    font-weight: 600;\n    margin-bottom: 12px;\n}\n\n.history-status.success {\n    background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.05));\n    color: var(--success-text);\n    border: 1px solid var(--success-text);\n}\n\n.history-status.error {\n    background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(239, 68, 68, 0.05));\n    color: var(--error-text);\n    border: 1px solid var(--error-text);\n}\n\n.info-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    background: var(--bg-dark);\n    padding: 8px 16px;\n    border-radius: 8px;\n    font-size: 0.85rem;\n    color: var(--text-secondary);\n    border: 1px solid var(--border-color);\n    transition: all 0.2s ease;\n}\n\n.info-badge:hover {\n    border-color: var(--primary-blue);\n    transform: translateY(-1px);\n}\n\n@media (max-width: 1024px) {\n    .sidebar {\n        width: 220px;\n    }\n    \n    .main-content {\n        margin-left: 220px;\n        width: calc(100% - 220px);\n    }\n    \n    .grid-2 {\n        grid-template-columns: 1fr;\n    }\n}\n\n@media (max-width: 768px) {\n    .sidebar {\n        width: 70px;\n    }\n    \n    .sidebar-title,\n    .sidebar-subtitle,\n    .nav-item span,\n    .nav-section-title,\n    .version-info {\n        display: none;\n    }\n    \n    .main-content {\n        margin-left: 70px;\n        width: calc(100% - 70px);\n        padding: 24px 20px;\n    }\n    \n    .page-title {\n        font-size: 1.75rem;\n    }\n}\n\n.sidebar-logo svg,\n.nav-icon svg,\n.btn-icon svg,\n.panel-icon svg {\n    display: inline-block;\n    vertical-align: middle;\n    stroke: currentColor;\n    stroke-width: 2;\n    stroke-linecap: round;\n    stroke-linejoin: round;\n    fill: none;\n}\n\n.sidebar-logo svg {\n    width: 22px;\n    height: 22px;\n    color: white;\n}\n\n.nav-icon svg {\n    width: 20px;\n    height: 20px;\n}\n\n.panel-icon svg {\n    width: 20px;\n    height: 20px;\n}\n\n.btn-icon svg {\n    width: 18px;\n    height: 18px;\n}\n\n.execute-btn svg {\n    width: 20px;\n    height: 20px;\n}\n\n.empty-state-icon svg {\n    width: 48px;\n    height: 48px;\n}\n\n::-webkit-scrollbar {\n    width: 8px;\n    height: 8px;\n}\n\n::-webkit-scrollbar-track {\n    background: var(--bg-dark);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb {\n    background: var(--border-color);\n    border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: var(--text-muted);\n}\n\n.input-group {\n    margin-bottom: 24px;\n}\n\n.input-label {\n    display: block;\n    font-size: 0.9rem;\n    font-weight: 600;\n    margin-bottom: 10px;\n    color: var(--text-primary);\n}\n\n.text-input {\n    width: 100%;\n    background: var(--bg-dark);\n    border: 2px solid var(--border-color);\n    border-radius: 10px;\n    padding: 12px 16px;\n    color: var(--text-primary);\n    font-size: 0.95rem;\n    transition: all 0.3s ease;\n}\n\n.text-input:focus {\n    outline: none;\n    border-color: var(--primary-blue);\n    box-shadow: 0 0 0 4px var(--glow-blue);\n}\n\n.alert {\n    padding: 16px;\n    border-radius: 12px;\n    margin-bottom: 24px;\n    display: flex;\n    align-items: start;\n    gap: 12px;\n    font-size: 0.95rem;\n    border: 1px solid;\n}\n\n.alert-warning {\n    background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(245, 158, 11, 0.05));\n    border-color: var(--warning-text);\n    color: var(--warning-text);\n}\n\n.code-block {\n    background: var(--bg-dark);\n    border: 1px solid var(--border-color);\n    border-radius: 12px;\n    padding: 16px;\n    font-family: 'Monaco', 'Menlo', 'Courier New', monospace;\n    font-size: 0.875rem;\n    color: var(--success-text);\n    overflow-x: auto;\n}\n\n.search-input {\n    width: 100%;\n    background: var(--bg-dark);\n    border: 2px solid var(--border-color);\n    border-radius: 10px;\n    padding: 12px 16px;\n    color: var(--text-primary);\n    font-size: 0.95rem;\n    transition: all 0.3s ease;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: var(--primary-blue);\n    box-shadow: 0 0 0 4px var(--glow-blue);\n}\n\n.search-input::placeholder {\n    color: var(--text-muted);\n}\n\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.8);\n    backdrop-filter: blur(8px);\n    align-items: center;\n    justify-content: center;\n}\n\n.modal-content {\n    background: var(--bg-panel);\n    border-radius: 16px;\n    border: 1px solid var(--border-color);\n    width: 90%;\n    max-width: 1200px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);\n}\n\n.modal-header {\n    padding: 28px;\n    border-bottom: 1px solid var(--border-color);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n.modal-title {\n    font-size: 1.5rem;\n    font-weight: 700;\n    margin: 0;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    color: var(--text-secondary);\n    cursor: pointer;\n    padding: 8px;\n    border-radius: 8px;\n    transition: all 0.2s ease;\n}\n\n.modal-close:hover {\n    background: var(--bg-panel-hover);\n    color: var(--text-primary);\n    transform: rotate(90deg);\n}\n\n#history-container {\n    min-height: 400px;\n    display: flex;\n    flex-direction: column;\n}\n\n.empty-state {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 20px;\n    margin: auto;\n    color: var(--text-muted);\n    text-align: center;\n}\n\n.empty-state-icon {\n    opacity: 0.3;\n    color: var(--text-muted);\n}\n\n.empty-state p {\n    font-size: 1.1rem;\n    font-weight: 500;\n    color: var(--text-secondary);\n    margin: 0;\n}\n","size_bytes":17682},"app/engines/playwright_mcp/client/__init__.py":{"content":"\"\"\"\nPlaywright MCP Client Module\n\"\"\"\nfrom app.engines.playwright_mcp.client.stdio_client import MCPStdioClient\n\n__all__ = ['MCPStdioClient']\n","size_bytes":141},"app/engines/browser_use/state_manager.py":{"content":"\"\"\"\nState Management for Complex Multi-Step Workflows\nPreserves context and state across automation steps\n\"\"\"\nimport json\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\n\nclass WorkflowState:\n    \"\"\"\n    Manages state for complex multi-step automation workflows\n    Preserves context, variables, and execution history\n    \"\"\"\n    \n    def __init__(self, workflow_id: Optional[str] = None, persist_to_disk: bool = False):\n        \"\"\"\n        Initialize workflow state manager\n        \n        Args:\n            workflow_id: Unique identifier for this workflow\n            persist_to_disk: Save state to disk for recovery\n        \"\"\"\n        self.workflow_id = workflow_id or f\"workflow_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        self.persist_to_disk = persist_to_disk\n        \n        self.state: Dict[str, Any] = {}\n        self.variables: Dict[str, Any] = {}\n        self.execution_history: List[Dict[str, Any]] = []\n        self.checkpoints: List[Dict[str, Any]] = []\n        \n        self.metadata = {\n            \"workflow_id\": self.workflow_id,\n            \"created_at\": datetime.now().isoformat(),\n            \"last_updated\": datetime.now().isoformat(),\n            \"step_count\": 0\n        }\n        \n        if self.persist_to_disk:\n            self.state_dir = Path(\"workflow_states\")\n            self.state_dir.mkdir(exist_ok=True)\n            self.state_file = self.state_dir / f\"{self.workflow_id}.json\"\n        \n        logger.info(f\"ðŸ”„ Workflow state initialized: {self.workflow_id}\")\n    \n    def set_variable(self, key: str, value: Any):\n        \"\"\"\n        Set a workflow variable\n        \n        Args:\n            key: Variable name\n            value: Variable value\n        \"\"\"\n        self.variables[key] = value\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.debug(f\"ðŸ“ Variable set: {key} = {value}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def get_variable(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a workflow variable\n        \n        Args:\n            key: Variable name\n            default: Default value if key doesn't exist\n            \n        Returns:\n            Variable value or default\n        \"\"\"\n        return self.variables.get(key, default)\n    \n    def set_state(self, key: str, value: Any):\n        \"\"\"\n        Set a state value\n        \n        Args:\n            key: State key\n            value: State value\n        \"\"\"\n        self.state[key] = value\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.debug(f\"ðŸ’¾ State set: {key}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def get_state(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        Get a state value\n        \n        Args:\n            key: State key\n            default: Default value if key doesn't exist\n            \n        Returns:\n            State value or default\n        \"\"\"\n        return self.state.get(key, default)\n    \n    def add_step(self, step_name: str, step_data: Dict[str, Any], success: bool = True):\n        \"\"\"\n        Record a workflow step\n        \n        Args:\n            step_name: Name of the step\n            step_data: Data associated with the step\n            success: Whether the step succeeded\n        \"\"\"\n        step_record = {\n            \"step_number\": self.metadata[\"step_count\"] + 1,\n            \"step_name\": step_name,\n            \"timestamp\": datetime.now().isoformat(),\n            \"success\": success,\n            \"data\": step_data\n        }\n        \n        self.execution_history.append(step_record)\n        self.metadata[\"step_count\"] += 1\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.info(f\"âœ… Step {self.metadata['step_count']} recorded: {step_name} (success: {success})\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def create_checkpoint(self, checkpoint_name: str):\n        \"\"\"\n        Create a checkpoint of current state\n        \n        Args:\n            checkpoint_name: Name for this checkpoint\n        \"\"\"\n        checkpoint = {\n            \"name\": checkpoint_name,\n            \"timestamp\": datetime.now().isoformat(),\n            \"state\": self.state.copy(),\n            \"variables\": self.variables.copy(),\n            \"step_count\": self.metadata[\"step_count\"]\n        }\n        \n        self.checkpoints.append(checkpoint)\n        logger.info(f\"ðŸ”– Checkpoint created: {checkpoint_name} (at step {self.metadata['step_count']})\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n    \n    def restore_checkpoint(self, checkpoint_name: str) -> bool:\n        \"\"\"\n        Restore state from a checkpoint\n        \n        Args:\n            checkpoint_name: Name of checkpoint to restore\n            \n        Returns:\n            True if restored successfully, False if checkpoint not found\n        \"\"\"\n        for checkpoint in reversed(self.checkpoints):\n            if checkpoint[\"name\"] == checkpoint_name:\n                self.state = checkpoint[\"state\"].copy()\n                self.variables = checkpoint[\"variables\"].copy()\n                \n                logger.info(f\"â™»ï¸  Restored checkpoint: {checkpoint_name} (from step {checkpoint['step_count']})\")\n                \n                if self.persist_to_disk:\n                    self._save_to_disk()\n                \n                return True\n        \n        logger.warning(f\"âš ï¸  Checkpoint not found: {checkpoint_name}\")\n        return False\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a summary of the workflow state\n        \n        Returns:\n            Dictionary with state summary\n        \"\"\"\n        return {\n            \"workflow_id\": self.workflow_id,\n            \"metadata\": self.metadata,\n            \"total_steps\": self.metadata[\"step_count\"],\n            \"total_checkpoints\": len(self.checkpoints),\n            \"variable_count\": len(self.variables),\n            \"state_keys\": list(self.state.keys()),\n            \"success_rate\": self._calculate_success_rate()\n        }\n    \n    def _calculate_success_rate(self) -> float:\n        \"\"\"Calculate success rate of executed steps\"\"\"\n        if not self.execution_history:\n            return 100.0\n        \n        successful = sum(1 for step in self.execution_history if step[\"success\"])\n        return (successful / len(self.execution_history)) * 100\n    \n    def _save_to_disk(self):\n        \"\"\"Save state to disk\"\"\"\n        try:\n            state_data = {\n                \"workflow_id\": self.workflow_id,\n                \"metadata\": self.metadata,\n                \"state\": self.state,\n                \"variables\": self.variables,\n                \"execution_history\": self.execution_history,\n                \"checkpoints\": self.checkpoints\n            }\n            \n            with open(self.state_file, 'w', encoding='utf-8') as f:\n                json.dump(state_data, f, indent=2)\n            \n            logger.debug(f\"ðŸ’¾ State saved to: {self.state_file}\")\n        except Exception as e:\n            logger.error(f\"âŒ Failed to save state: {str(e)}\")\n    \n    @classmethod\n    def load_from_disk(cls, workflow_id: str) -> Optional['WorkflowState']:\n        \"\"\"\n        Load workflow state from disk\n        \n        Args:\n            workflow_id: Workflow ID to load\n            \n        Returns:\n            WorkflowState instance or None if not found\n        \"\"\"\n        state_file = Path(\"workflow_states\") / f\"{workflow_id}.json\"\n        \n        if not state_file.exists():\n            logger.warning(f\"âš ï¸  Workflow state not found: {workflow_id}\")\n            return None\n        \n        try:\n            with open(state_file, 'r', encoding='utf-8') as f:\n                state_data = json.load(f)\n            \n            instance = cls(workflow_id=workflow_id, persist_to_disk=True)\n            instance.metadata = state_data[\"metadata\"]\n            instance.state = state_data[\"state\"]\n            instance.variables = state_data[\"variables\"]\n            instance.execution_history = state_data[\"execution_history\"]\n            instance.checkpoints = state_data[\"checkpoints\"]\n            \n            logger.info(f\"ðŸ“‚ Workflow state loaded: {workflow_id}\")\n            return instance\n            \n        except Exception as e:\n            logger.error(f\"âŒ Failed to load state: {str(e)}\")\n            return None\n    \n    def reset(self):\n        \"\"\"Reset workflow state\"\"\"\n        self.state.clear()\n        self.variables.clear()\n        self.execution_history.clear()\n        self.checkpoints.clear()\n        self.metadata[\"step_count\"] = 0\n        self.metadata[\"last_updated\"] = datetime.now().isoformat()\n        \n        logger.info(f\"ðŸ”„ Workflow state reset: {self.workflow_id}\")\n        \n        if self.persist_to_disk:\n            self._save_to_disk()\n","size_bytes":9056},"app/utils/encryption.py":{"content":"\"\"\"\nEncryption utilities for securely storing sensitive credentials\n\"\"\"\nimport os\nimport base64\nfrom cryptography.fernet import Fernet\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.backends import default_backend\n\n\nclass CredentialEncryption:\n    \"\"\"\n    Handles encryption and decryption of stored credentials.\n    Uses Fernet (symmetric encryption) with a key derived from an environment variable.\n    \"\"\"\n    \n    def __init__(self):\n        self._cipher = None\n        \n    def _get_cipher(self):\n        \"\"\"\n        Get or create the Fernet cipher instance.\n        Requires ENCRYPTION_KEY environment variable to be set.\n        \n        The ENCRYPTION_KEY should be a base64-encoded Fernet key.\n        To generate a secure key, run: python -c \"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\"\n        \n        Raises:\n            ValueError: If ENCRYPTION_KEY is not set or invalid\n        \"\"\"\n        if self._cipher is not None:\n            return self._cipher\n            \n        encryption_key = os.environ.get('ENCRYPTION_KEY')\n        \n        if not encryption_key:\n            raise ValueError(\n                \"ENCRYPTION_KEY environment variable is not set. \"\n                \"Credential vault requires a secure encryption key. \"\n                \"Generate one with: python -c \\\"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\\\" \"\n                \"Then set it as an environment variable or Replit Secret.\"\n            )\n        \n        try:\n            # Try to use it directly as a Fernet key\n            self._cipher = Fernet(encryption_key.encode())\n            return self._cipher\n        except Exception as e:\n            raise ValueError(\n                f\"Invalid ENCRYPTION_KEY format: {str(e)}. \"\n                \"The key must be a valid Fernet key (44 characters, base64-encoded). \"\n                \"Generate a new one with: python -c \\\"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\\\"\"\n            )\n    \n    def encrypt(self, plaintext: str) -> str:\n        \"\"\"\n        Encrypt a plaintext string\n        \n        Args:\n            plaintext: The string to encrypt\n            \n        Returns:\n            Base64-encoded encrypted string\n        \"\"\"\n        if not plaintext:\n            return ''\n            \n        cipher = self._get_cipher()\n        encrypted_bytes = cipher.encrypt(plaintext.encode('utf-8'))\n        return base64.urlsafe_b64encode(encrypted_bytes).decode('utf-8')\n    \n    def decrypt(self, encrypted: str) -> str:\n        \"\"\"\n        Decrypt an encrypted string\n        \n        Args:\n            encrypted: Base64-encoded encrypted string\n            \n        Returns:\n            Decrypted plaintext string\n        \"\"\"\n        if not encrypted:\n            return ''\n            \n        try:\n            cipher = self._get_cipher()\n            encrypted_bytes = base64.urlsafe_b64decode(encrypted.encode('utf-8'))\n            decrypted_bytes = cipher.decrypt(encrypted_bytes)\n            return decrypted_bytes.decode('utf-8')\n        except Exception as e:\n            raise ValueError(f\"Decryption failed: {str(e)}\")\n\n\ncredential_encryption = CredentialEncryption()\n","size_bytes":3314},"app/engines/browser_use/config/__init__.py":{"content":"\"\"\"\nBrowser-Use Configuration Module\n\"\"\"\n","size_bytes":41},"main.py":{"content":"\"\"\"\nMain entry point for the AI Browser Automation web application\n\"\"\"\nimport os\nimport sys\nfrom dotenv import load_dotenv\nfrom app import create_app\n\n# Force unbuffered output for better logging\nif hasattr(sys.stdout, 'reconfigure'):\n    sys.stdout.reconfigure(line_buffering=True)  # type: ignore\nos.environ['PYTHONUNBUFFERED'] = '1'\n\n# Load .env file and override any existing environment variables\nload_dotenv(override=True)\n\napp = create_app()\n\nif __name__ == '__main__':\n    print(\"=\"*80)\n    print(\"ðŸš€ AI BROWSER AUTOMATION - STARTING UP\")\n    print(\"=\"*80)\n    \n    # Validate OAuth configuration\n    required_oauth_vars = [\n        \"OAUTH_TOKEN_URL\",\n        \"OAUTH_CLIENT_ID\",\n        \"OAUTH_CLIENT_SECRET\",\n        \"OAUTH_GRANT_TYPE\",\n        \"OAUTH_SCOPE\",\n        \"GW_BASE_URL\"\n    ]\n    \n    missing_vars = [var for var in required_oauth_vars if not os.environ.get(var)]\n    \n    if missing_vars:\n        print(f\"\\nâš ï¸  WARNING: Missing OAuth environment variables: {', '.join(missing_vars)}\")\n        print(\"   The application will start but AI features will not work.\")\n        print(\"   Please set the required OAuth variables in your environment.\\n\")\n    else:\n        print(\"âœ… OAuth configuration found\")\n        print(f\"âœ… Gateway URL: {os.environ.get('GW_BASE_URL')}\")\n    \n    sys.stdout.flush()\n\n    print(\"\\nðŸŒ Starting Flask web server on port 5000...\")\n    print(\"=\"*80)\n    print(\"\\nðŸ’¡ TIP: Keep this console window open to see automation logs\\n\")\n    sys.stdout.flush()\n\n    # Start the web app with debug mode for better console output\n    app.run(host='0.0.0.0', port=5000, debug=True, use_reloader=False)\n","size_bytes":1648},"app/static/js/credentials.js":{"content":"/**\n * Credential Manager\n * Handles secure credential storage and management UI\n */\n\nconst credentialManager = {\n    /**\n     * Initialize the credential manager\n     */\n    init() {\n        this.loadCredentials();\n    },\n\n    /**\n     * Load and display all credentials\n     */\n    async loadCredentials() {\n        try {\n            const response = await fetch('/api/credentials');\n            const data = await response.json();\n\n            if (data.success) {\n                this.renderCredentials(data.credentials);\n            } else {\n                this.showError('Failed to load credentials: ' + data.message);\n            }\n        } catch (error) {\n            console.error('Error loading credentials:', error);\n            this.showError('Failed to load credentials. Please try again.');\n        }\n    },\n\n    /**\n     * Render credentials list\n     */\n    renderCredentials(credentials) {\n        const container = document.getElementById('credentials-list');\n\n        if (credentials.length === 0) {\n            container.innerHTML = `\n                <div class=\"empty-state\">\n                    <i data-feather=\"key\"></i>\n                    <h3 style=\"color: var(--text-primary); margin: 16px 0 8px 0;\">No credentials stored yet</h3>\n                    <p style=\"max-width: 400px; margin: 0 auto;\">\n                        Add your first credential to start using secure placeholders in your automation prompts.\n                    </p>\n                </div>\n            `;\n            feather.replace();\n            return;\n        }\n\n        container.innerHTML = credentials.map(cred => `\n            <div class=\"credential-card\">\n                <div class=\"credential-header\">\n                    <div>\n                        <div class=\"credential-name\">${this.escapeHtml(cred.name)}</div>\n                        <div class=\"credential-placeholder\">{{${this.escapeHtml(cred.name)}}}</div>\n                    </div>\n                    <div class=\"credential-actions\">\n                        <button class=\"btn btn-secondary btn-icon-only\" \n                                onclick=\"credentialManager.deleteCredential(${cred.id}, '${this.escapeHtml(cred.name)}')\"\n                                title=\"Delete credential\">\n                            <i data-feather=\"trash-2\"></i>\n                        </button>\n                    </div>\n                </div>\n                ${cred.service || cred.url || cred.username || cred.description ? `\n                    <div class=\"credential-info\">\n                        ${cred.service ? `\n                            <div class=\"credential-info-item\">\n                                <div class=\"credential-info-label\">Service</div>\n                                <div class=\"credential-info-value\">${this.escapeHtml(cred.service)}</div>\n                            </div>\n                        ` : ''}\n                        ${cred.url ? `\n                            <div class=\"credential-info-item\">\n                                <div class=\"credential-info-label\">URL</div>\n                                <div class=\"credential-info-value\">${this.escapeHtml(cred.url)}</div>\n                            </div>\n                        ` : ''}\n                        ${cred.username ? `\n                            <div class=\"credential-info-item\">\n                                <div class=\"credential-info-label\">Username</div>\n                                <div class=\"credential-info-value\">${this.escapeHtml(cred.username)}</div>\n                            </div>\n                        ` : ''}\n                        ${cred.description ? `\n                            <div class=\"credential-info-item\">\n                                <div class=\"credential-info-label\">Description</div>\n                                <div class=\"credential-info-value\">${this.escapeHtml(cred.description)}</div>\n                            </div>\n                        ` : ''}\n                    </div>\n                ` : ''}\n                <div style=\"margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 0.85rem; color: var(--text-secondary);\">\n                    <i data-feather=\"clock\" style=\"width: 14px; height: 14px;\"></i>\n                    Created: ${new Date(cred.created_at).toLocaleString()}\n                </div>\n            </div>\n        `).join('');\n\n        feather.replace();\n    },\n\n    /**\n     * Show the add credential modal\n     */\n    showAddCredentialModal() {\n        document.getElementById('add-credential-modal').style.display = 'flex';\n        document.getElementById('add-credential-form').reset();\n        document.getElementById('credential-name').focus();\n    },\n\n    /**\n     * Close the add credential modal\n     */\n    closeAddCredentialModal() {\n        document.getElementById('add-credential-modal').style.display = 'none';\n    },\n\n    /**\n     * Add a new credential\n     */\n    async addCredential(event) {\n        event.preventDefault();\n\n        const name = document.getElementById('credential-name').value.trim();\n        const service = document.getElementById('credential-service').value.trim();\n        const url = document.getElementById('credential-url').value.trim();\n        const username = document.getElementById('credential-username').value.trim();\n        const value = document.getElementById('credential-value').value.trim();\n        const description = document.getElementById('credential-description').value.trim();\n\n        if (!name || !url || !username || !value) {\n            this.showError('Name, URL, username, and password are required');\n            return;\n        }\n\n        try {\n            const response = await fetch('/api/credentials', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    name,\n                    service,\n                    url,\n                    username,\n                    value,\n                    description\n                })\n            });\n\n            const data = await response.json();\n\n            if (data.success) {\n                this.showSuccess('Credential added successfully');\n                this.closeAddCredentialModal();\n                this.loadCredentials();\n            } else {\n                this.showError(data.message || 'Failed to add credential');\n            }\n        } catch (error) {\n            console.error('Error adding credential:', error);\n            this.showError('Failed to add credential. Please try again.');\n        }\n    },\n\n    /**\n     * Delete a credential\n     */\n    async deleteCredential(id, name) {\n        if (!confirm(`Are you sure you want to delete the credential \"${name}\"?\\n\\nThis action cannot be undone.`)) {\n            return;\n        }\n\n        try {\n            const response = await fetch(`/api/credentials/${id}`, {\n                method: 'DELETE'\n            });\n\n            const data = await response.json();\n\n            if (data.success) {\n                this.showSuccess('Credential deleted successfully');\n                this.loadCredentials();\n            } else {\n                this.showError(data.message || 'Failed to delete credential');\n            }\n        } catch (error) {\n            console.error('Error deleting credential:', error);\n            this.showError('Failed to delete credential. Please try again.');\n        }\n    },\n\n    /**\n     * Show error message\n     */\n    showError(message) {\n        alert('Error: ' + message);\n    },\n\n    /**\n     * Show success message\n     */\n    showSuccess(message) {\n        // Simple alert for now - can be enhanced with a toast notification\n        alert(message);\n    },\n\n    /**\n     * Escape HTML to prevent XSS\n     */\n    escapeHtml(text) {\n        if (!text) return '';\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n};\n\n// Initialize when DOM is ready\ndocument.addEventListener('DOMContentLoaded', function() {\n    credentialManager.init();\n\n    // Close modal when clicking outside\n    document.getElementById('add-credential-modal')?.addEventListener('click', function(e) {\n        if (e.target === this) {\n            credentialManager.closeAddCredentialModal();\n        }\n    });\n\n    // Handle escape key to close modal\n    document.addEventListener('keydown', function(e) {\n        if (e.key === 'Escape') {\n            credentialManager.closeAddCredentialModal();\n        }\n    });\n});\n","size_bytes":8611},"app/engines/playwright_mcp/agents/__init__.py":{"content":"\"\"\"\nThree-Agent System for Playwright Python Code Generation\n\"\"\"\nfrom .locator_engine import StrictModeLocatorEngine\nfrom .planner_agent import PlannerAgent\nfrom .generator_agent import GeneratorAgent\nfrom .healer_agent import HealerAgent\n\n__all__ = [\n    'StrictModeLocatorEngine',\n    'PlannerAgent',\n    'GeneratorAgent',\n    'HealerAgent'\n]\n","size_bytes":345},"app/engines/browser_use/advanced_features.py":{"content":"\"\"\"\nAdvanced Browser Automation Features\nProvides screenshot capture, PDF generation, cookie management, and more\n\"\"\"\nimport os\nimport json\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nfrom datetime import datetime\nfrom browser_use import Browser\n\nlogger = logging.getLogger(__name__)\n\n\nclass AdvancedBrowserFeatures:\n    \"\"\"\n    Advanced capabilities for browser automation\n    Handles screenshots, PDFs, cookies, sessions, and more\n    \"\"\"\n    \n    def __init__(self, output_dir: str = \"automation_outputs\"):\n        \"\"\"\n        Initialize advanced browser features\n        \n        Args:\n            output_dir: Directory to save screenshots, PDFs, etc.\n        \"\"\"\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(exist_ok=True)\n        \n        self.screenshots_dir = self.output_dir / \"screenshots\"\n        self.pdfs_dir = self.output_dir / \"pdfs\"\n        self.cookies_dir = self.output_dir / \"cookies\"\n        \n        self.screenshots_dir.mkdir(exist_ok=True)\n        self.pdfs_dir.mkdir(exist_ok=True)\n        self.cookies_dir.mkdir(exist_ok=True)\n        \n        logger.info(f\"ðŸ“ Advanced features initialized with output dir: {self.output_dir}\")\n    \n    async def capture_screenshot(self, page, name: Optional[str] = None, full_page: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Capture screenshot of current page\n        \n        Args:\n            page: Playwright page object\n            name: Optional custom name for screenshot\n            full_page: Capture full scrollable page\n            \n        Returns:\n            Dictionary with screenshot path and metadata\n        \"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"{name}_{timestamp}.png\" if name else f\"screenshot_{timestamp}.png\"\n            filepath = self.screenshots_dir / filename\n            \n            await page.screenshot(path=str(filepath), full_page=full_page)\n            \n            logger.info(f\"ðŸ“¸ Screenshot saved: {filepath}\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"filename\": filename,\n                \"full_page\": full_page,\n                \"timestamp\": timestamp,\n                \"url\": page.url\n            }\n        except Exception as e:\n            logger.error(f\"âŒ Screenshot capture failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def generate_pdf(self, page, name: Optional[str] = None, \n                          landscape: bool = False, \n                          print_background: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Generate PDF of current page\n        \n        Args:\n            page: Playwright page object\n            name: Optional custom name for PDF\n            landscape: Use landscape orientation\n            print_background: Include background graphics\n            \n        Returns:\n            Dictionary with PDF path and metadata\n        \"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"{name}_{timestamp}.pdf\" if name else f\"page_{timestamp}.pdf\"\n            filepath = self.pdfs_dir / filename\n            \n            await page.pdf(\n                path=str(filepath),\n                format='A4',\n                landscape=landscape,\n                print_background=print_background,\n                margin={'top': '20px', 'right': '20px', 'bottom': '20px', 'left': '20px'}\n            )\n            \n            logger.info(f\"ðŸ“„ PDF generated: {filepath}\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"filename\": filename,\n                \"landscape\": landscape,\n                \"timestamp\": timestamp,\n                \"url\": page.url\n            }\n        except Exception as e:\n            logger.error(f\"âŒ PDF generation failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def save_cookies(self, context, session_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Save browser cookies for session persistence\n        \n        Args:\n            context: Playwright browser context\n            session_name: Name for this session\n            \n        Returns:\n            Dictionary with save status and path\n        \"\"\"\n        try:\n            cookies = await context.cookies()\n            \n            filepath = self.cookies_dir / f\"{session_name}_cookies.json\"\n            \n            with open(filepath, 'w', encoding='utf-8') as f:\n                json.dump(cookies, f, indent=2)\n            \n            logger.info(f\"ðŸª Cookies saved: {filepath} ({len(cookies)} cookies)\")\n            \n            return {\n                \"success\": True,\n                \"path\": str(filepath),\n                \"session_name\": session_name,\n                \"cookie_count\": len(cookies)\n            }\n        except Exception as e:\n            logger.error(f\"âŒ Cookie save failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def load_cookies(self, context, session_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Load previously saved cookies to restore session\n        \n        Args:\n            context: Playwright browser context\n            session_name: Name of session to restore\n            \n        Returns:\n            Dictionary with load status\n        \"\"\"\n        try:\n            filepath = self.cookies_dir / f\"{session_name}_cookies.json\"\n            \n            if not filepath.exists():\n                return {\n                    \"success\": False,\n                    \"error\": f\"Session '{session_name}' not found\"\n                }\n            \n            with open(filepath, 'r', encoding='utf-8') as f:\n                cookies = json.load(f)\n            \n            await context.add_cookies(cookies)\n            \n            logger.info(f\"ðŸª Cookies loaded: {filepath} ({len(cookies)} cookies)\")\n            \n            return {\n                \"success\": True,\n                \"session_name\": session_name,\n                \"cookie_count\": len(cookies)\n            }\n        except Exception as e:\n            logger.error(f\"âŒ Cookie load failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def get_local_storage(self, page) -> Dict[str, Any]:\n        \"\"\"\n        Extract localStorage data from page\n        \n        Args:\n            page: Playwright page object\n            \n        Returns:\n            Dictionary with localStorage contents\n        \"\"\"\n        try:\n            storage_data = await page.evaluate(\"\"\"() => {\n                let data = {};\n                for (let i = 0; i < localStorage.length; i++) {\n                    let key = localStorage.key(i);\n                    data[key] = localStorage.getItem(key);\n                }\n                return data;\n            }\"\"\")\n            \n            logger.info(f\"ðŸ’¾ LocalStorage extracted: {len(storage_data)} items\")\n            \n            return {\n                \"success\": True,\n                \"data\": storage_data,\n                \"item_count\": len(storage_data)\n            }\n        except Exception as e:\n            logger.error(f\"âŒ LocalStorage extraction failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def set_local_storage(self, page, data: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"\n        Set localStorage data on page\n        \n        Args:\n            page: Playwright page object\n            data: Dictionary of key-value pairs to set\n            \n        Returns:\n            Dictionary with operation status\n        \"\"\"\n        try:\n            for key, value in data.items():\n                await page.evaluate(f\"\"\"() => {{\n                    localStorage.setItem('{key}', '{value}');\n                }}\"\"\")\n            \n            logger.info(f\"ðŸ’¾ LocalStorage set: {len(data)} items\")\n            \n            return {\n                \"success\": True,\n                \"item_count\": len(data)\n            }\n        except Exception as e:\n            logger.error(f\"âŒ LocalStorage set failed: {str(e)}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    def list_sessions(self) -> List[str]:\n        \"\"\"\n        List all saved cookie sessions\n        \n        Returns:\n            List of session names\n        \"\"\"\n        sessions = []\n        for file in self.cookies_dir.glob(\"*_cookies.json\"):\n            session_name = file.stem.replace(\"_cookies\", \"\")\n            sessions.append(session_name)\n        \n        return sessions\n    \n    def cleanup_old_files(self, days: int = 7):\n        \"\"\"\n        Clean up old screenshots and PDFs\n        \n        Args:\n            days: Delete files older than this many days\n        \"\"\"\n        from datetime import timedelta\n        cutoff = datetime.now() - timedelta(days=days)\n        \n        deleted_count = 0\n        for directory in [self.screenshots_dir, self.pdfs_dir]:\n            for file in directory.glob(\"*\"):\n                if file.stat().st_mtime < cutoff.timestamp():\n                    file.unlink()\n                    deleted_count += 1\n        \n        logger.info(f\"ðŸ—‘ï¸  Cleaned up {deleted_count} old files\")\n        return deleted_count\n","size_bytes":9646},"app/engines/playwright_mcp/config/__init__.py":{"content":"\"\"\"\nPlaywright MCP Configuration Module\n\"\"\"\n","size_bytes":44},"app/static/js/configuration.js":{"content":"// Initialize detection when script loads\ndetectClientEnvironment();\n\n// Also initialize on DOMContentLoaded for direct page loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    detectClientEnvironment();\n    initializeSettings();\n});\n\nfunction detectClientEnvironment() {\n    const userAgent = navigator.userAgent;\n    const platform = navigator.platform;\n    \n    // Detect Operating System\n    let os = 'Unknown';\n    if (platform.indexOf('Win') !== -1) {\n        os = 'Windows';\n    } else if (platform.indexOf('Mac') !== -1) {\n        os = 'macOS';\n    } else if (platform.indexOf('Linux') !== -1) {\n        os = 'Linux';\n    } else if (/Android/.test(userAgent)) {\n        os = 'Android';\n    } else if (/iPhone|iPad|iPod/.test(userAgent)) {\n        os = 'iOS';\n    }\n    \n    // Detect Browser\n    let browser = 'Unknown';\n    if (/Edg/.test(userAgent)) {\n        browser = 'Microsoft Edge';\n    } else if (/Chrome/.test(userAgent) && !/Edg/.test(userAgent)) {\n        browser = 'Google Chrome';\n    } else if (/Safari/.test(userAgent) && !/Chrome/.test(userAgent)) {\n        browser = 'Safari';\n    } else if (/Firefox/.test(userAgent)) {\n        browser = 'Firefox';\n    } else if (/MSIE|Trident/.test(userAgent)) {\n        browser = 'Internet Explorer';\n    }\n    \n    // Update the page\n    const osElement = document.getElementById('client-os');\n    const browserElement = document.getElementById('client-browser');\n    \n    if (osElement) {\n        osElement.textContent = os;\n    }\n    \n    if (browserElement) {\n        browserElement.textContent = browser;\n    }\n}\n\nfunction initializeSettings() {\n    // Load saved settings from localStorage\n    const savedMode = localStorage.getItem('browserMode') || 'headful';\n    const savedEngine = localStorage.getItem('automationEngine') || 'browser_use';\n    \n    const headlessBtn = document.getElementById('headless-btn');\n    const headfulBtn = document.getElementById('headful-btn');\n    const browserUseBtn = document.getElementById('browser-use-btn');\n    const playwrightMcpBtn = document.getElementById('playwright-mcp-btn');\n    \n    // Set initial states based on saved settings\n    if (headlessBtn && headfulBtn) {\n        if (savedMode === 'headless') {\n            headlessBtn.classList.add('active');\n            headfulBtn.classList.remove('active');\n        } else {\n            headfulBtn.classList.add('active');\n            headlessBtn.classList.remove('active');\n        }\n        \n        headlessBtn.addEventListener('click', () => {\n            localStorage.setItem('browserMode', 'headless');\n            headlessBtn.classList.add('active');\n            headfulBtn.classList.remove('active');\n        });\n        \n        headfulBtn.addEventListener('click', () => {\n            localStorage.setItem('browserMode', 'headful');\n            headfulBtn.classList.add('active');\n            headlessBtn.classList.remove('active');\n        });\n    }\n    \n    if (browserUseBtn && playwrightMcpBtn) {\n        if (savedEngine === 'playwright_mcp') {\n            playwrightMcpBtn.classList.add('active');\n            browserUseBtn.classList.remove('active');\n        } else {\n            browserUseBtn.classList.add('active');\n            playwrightMcpBtn.classList.remove('active');\n        }\n        \n        browserUseBtn.addEventListener('click', () => {\n            localStorage.setItem('automationEngine', 'browser_use');\n            browserUseBtn.classList.add('active');\n            playwrightMcpBtn.classList.remove('active');\n        });\n        \n        playwrightMcpBtn.addEventListener('click', () => {\n            localStorage.setItem('automationEngine', 'playwright_mcp');\n            playwrightMcpBtn.classList.add('active');\n            browserUseBtn.classList.remove('active');\n        });\n    }\n}\n\n// Make function globally available for manual calls\nwindow.detectClientEnvironment = detectClientEnvironment;\n","size_bytes":3914},"app/engines/browser_use/popup_handler.py":{"content":"\"\"\"\nEnhanced Popup Window Handler for Browser-Use\nAutomatically detects and switches to new popup windows with advanced features\n\"\"\"\nimport asyncio\nimport logging\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime\nfrom playwright.async_api import Page, BrowserContext\n\nlogger = logging.getLogger(__name__)\n\n\nclass PopupWindowHandler:\n    \"\"\"\n    Enhanced popup window handler with advanced detection and management\n    Features:\n    - Automatic popup detection and switching\n    - Configurable timeouts\n    - Detailed logging and tracking\n    - Multi-popup orchestration\n    - Popup priority rules\n    \"\"\"\n    \n    def __init__(self, context: BrowserContext, popup_timeout: int = 10000, \n                 auto_switch: bool = True, log_verbose: bool = True):\n        \"\"\"\n        Initialize the enhanced popup handler\n        \n        Args:\n            context: Playwright browser context to monitor\n            popup_timeout: Timeout in milliseconds for popup operations (default: 10000ms)\n            auto_switch: Automatically switch to new popups (default: True)\n            log_verbose: Enable detailed logging (default: True)\n        \"\"\"\n        self.context = context\n        self.current_page = None\n        self.popup_detected = False\n        self.new_pages = []\n        self.popup_timeout = popup_timeout\n        self.auto_switch = auto_switch\n        self.log_verbose = log_verbose\n        \n        self.popup_history: List[Dict[str, Any]] = []\n        self.popup_count = 0\n        \n        context.on(\"page\", self._on_new_page)\n        \n        if self.log_verbose:\n            logger.info(f\"ðŸ” Enhanced popup handler initialized (timeout: {popup_timeout}ms, auto_switch: {auto_switch})\")\n    \n    def _on_new_page(self, page: Page):\n        \"\"\"\n        Enhanced event handler for new pages/windows with tracking\n        \n        Args:\n            page: Newly created page object\n        \"\"\"\n        self.popup_count += 1\n        popup_info = {\n            \"popup_number\": self.popup_count,\n            \"url\": page.url or \"about:blank\",\n            \"timestamp\": datetime.now().isoformat(),\n            \"auto_switched\": self.auto_switch\n        }\n        \n        self.popup_history.append(popup_info)\n        self.new_pages.append(page)\n        self.popup_detected = True\n        \n        if self.log_verbose:\n            logger.info(f\"ðŸ†• Popup #{self.popup_count} detected: {popup_info['url']}\")\n            logger.info(f\"ðŸ“Š Total popups opened: {self.popup_count}\")\n    \n    async def get_active_page(self) -> Optional[Page]:\n        \"\"\"\n        Get the currently active page with enhanced timeout handling\n        \n        Returns:\n            Active page object or None\n        \"\"\"\n        if self.new_pages and self.auto_switch:\n            latest_page = self.new_pages[-1]\n            \n            try:\n                await latest_page.wait_for_load_state(\"domcontentloaded\", timeout=self.popup_timeout)\n                \n                if self.log_verbose:\n                    logger.info(f\"âœ… Switched to popup window: {latest_page.url}\")\n                \n                return latest_page\n            except Exception as e:\n                logger.warning(f\"âš ï¸ Popup not ready within {self.popup_timeout}ms: {str(e)}\")\n        \n        all_pages = self.context.pages\n        if all_pages:\n            return all_pages[-1]\n        \n        return None\n    \n    async def wait_for_popup(self, timeout: Optional[int] = None) -> Optional[Page]:\n        \"\"\"\n        Wait for a popup to appear\n        \n        Args:\n            timeout: Optional custom timeout in milliseconds\n            \n        Returns:\n            New popup page or None if timeout\n        \"\"\"\n        wait_timeout = timeout or self.popup_timeout\n        start_time = datetime.now()\n        \n        while (datetime.now() - start_time).total_seconds() * 1000 < wait_timeout:\n            if self.new_pages:\n                new_page = self.new_pages[-1]\n                if self.log_verbose:\n                    logger.info(f\"âœ… Popup appeared: {new_page.url}\")\n                return new_page\n            await asyncio.sleep(0.1)\n        \n        logger.warning(f\"â±ï¸  No popup appeared within {wait_timeout}ms\")\n        return None\n    \n    def get_popup_stats(self) -> Dict[str, Any]:\n        \"\"\"\n        Get statistics about popup handling\n        \n        Returns:\n            Dictionary with popup statistics\n        \"\"\"\n        return {\n            \"total_popups\": self.popup_count,\n            \"active_popups\": len(self.new_pages),\n            \"popup_history\": self.popup_history,\n            \"auto_switch_enabled\": self.auto_switch,\n            \"timeout_ms\": self.popup_timeout\n        }\n    \n    def reset(self):\n        \"\"\"Reset the handler state with enhanced logging\"\"\"\n        previous_count = self.popup_count\n        self.new_pages.clear()\n        self.popup_detected = False\n        \n        if self.log_verbose:\n            logger.info(f\"ðŸ”„ Popup handler reset (processed {previous_count} popups this session)\")\n    \n    def has_popup(self) -> bool:\n        \"\"\"Check if a popup window was detected\"\"\"\n        return self.popup_detected\n    \n    def get_all_pages(self):\n        \"\"\"Get all open pages\"\"\"\n        return self.context.pages\n","size_bytes":5279},"app/services/__init__.py":{"content":"\"\"\"\nFlask Services Module\n\"\"\"\nfrom app.services.engine_orchestrator import EngineOrchestrator\n\n__all__ = ['EngineOrchestrator']\n","size_bytes":128},"app/engines/browser_use/retry_mechanism.py":{"content":"\"\"\"\nSmart Retry Mechanism for Browser Automation\nImplements exponential backoff and intelligent retry logic\n\"\"\"\nimport time\nimport logging\nimport asyncio\nfrom typing import Callable, Any, Optional, List\nfrom functools import wraps\n\nlogger = logging.getLogger(__name__)\n\n\nclass RetryConfig:\n    \"\"\"Configuration for retry behavior\"\"\"\n    \n    def __init__(self, \n                 max_retries: int = 3,\n                 initial_delay: float = 1.0,\n                 max_delay: float = 30.0,\n                 backoff_factor: float = 2.0,\n                 retry_on_exceptions: Optional[List[type]] = None):\n        \"\"\"\n        Initialize retry configuration\n        \n        Args:\n            max_retries: Maximum number of retry attempts\n            initial_delay: Initial delay in seconds before first retry\n            max_delay: Maximum delay between retries\n            backoff_factor: Multiplier for exponential backoff\n            retry_on_exceptions: List of exception types to retry on (None = all)\n        \"\"\"\n        self.max_retries = max_retries\n        self.initial_delay = initial_delay\n        self.max_delay = max_delay\n        self.backoff_factor = backoff_factor\n        self.retry_on_exceptions = retry_on_exceptions or [Exception]\n\n\nclass RetryMechanism:\n    \"\"\"\n    Smart retry handler with exponential backoff\n    Handles both sync and async operations\n    \"\"\"\n    \n    def __init__(self, config: Optional[RetryConfig] = None):\n        \"\"\"\n        Initialize retry mechanism\n        \n        Args:\n            config: Retry configuration (uses defaults if None)\n        \"\"\"\n        self.config = config or RetryConfig()\n        self.retry_stats = {\n            \"total_attempts\": 0,\n            \"total_retries\": 0,\n            \"successful_retries\": 0,\n            \"failed_operations\": 0\n        }\n    \n    def retry(self, func: Callable) -> Callable:\n        \"\"\"\n        Decorator for synchronous functions with retry logic\n        \n        Args:\n            func: Function to wrap with retry logic\n            \n        Returns:\n            Wrapped function with retry capability\n        \"\"\"\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            return self._execute_with_retry(func, *args, **kwargs)\n        \n        return wrapper\n    \n    def async_retry(self, func: Callable) -> Callable:\n        \"\"\"\n        Decorator for asynchronous functions with retry logic\n        \n        Args:\n            func: Async function to wrap with retry logic\n            \n        Returns:\n            Wrapped async function with retry capability\n        \"\"\"\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            return await self._execute_async_with_retry(func, *args, **kwargs)\n        \n        return wrapper\n    \n    def _execute_with_retry(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Execute synchronous function with retry logic\n        \n        Args:\n            func: Function to execute\n            *args: Positional arguments\n            **kwargs: Keyword arguments\n            \n        Returns:\n            Function result\n            \n        Raises:\n            Last exception if all retries fail\n        \"\"\"\n        last_exception = None\n        delay = self.config.initial_delay\n        \n        for attempt in range(self.config.max_retries + 1):\n            self.retry_stats[\"total_attempts\"] += 1\n            \n            try:\n                result = func(*args, **kwargs)\n                \n                if attempt > 0:\n                    self.retry_stats[\"successful_retries\"] += 1\n                    logger.info(f\"âœ… Operation succeeded after {attempt} retries\")\n                \n                return result\n                \n            except Exception as e:\n                last_exception = e\n                \n                if not self._should_retry(e):\n                    logger.error(f\"âŒ Non-retryable exception: {type(e).__name__}\")\n                    self.retry_stats[\"failed_operations\"] += 1\n                    raise\n                \n                if attempt < self.config.max_retries:\n                    self.retry_stats[\"total_retries\"] += 1\n                    logger.warning(f\"âš ï¸  Attempt {attempt + 1}/{self.config.max_retries + 1} failed: {str(e)}\")\n                    logger.info(f\"ðŸ”„ Retrying in {delay:.1f}s...\")\n                    \n                    time.sleep(delay)\n                    delay = min(delay * self.config.backoff_factor, self.config.max_delay)\n                else:\n                    self.retry_stats[\"failed_operations\"] += 1\n                    logger.error(f\"âŒ All {self.config.max_retries + 1} attempts failed\")\n        \n        if last_exception:\n            raise last_exception\n        else:\n            raise RuntimeError(\"All retry attempts exhausted without capturing an exception\")\n    \n    async def _execute_async_with_retry(self, func: Callable, *args, **kwargs) -> Any:\n        \"\"\"\n        Execute asynchronous function with retry logic\n        \n        Args:\n            func: Async function to execute\n            *args: Positional arguments\n            **kwargs: Keyword arguments\n            \n        Returns:\n            Function result\n            \n        Raises:\n            Last exception if all retries fail\n        \"\"\"\n        last_exception = None\n        delay = self.config.initial_delay\n        \n        for attempt in range(self.config.max_retries + 1):\n            self.retry_stats[\"total_attempts\"] += 1\n            \n            try:\n                result = await func(*args, **kwargs)\n                \n                if attempt > 0:\n                    self.retry_stats[\"successful_retries\"] += 1\n                    logger.info(f\"âœ… Async operation succeeded after {attempt} retries\")\n                \n                return result\n                \n            except Exception as e:\n                last_exception = e\n                \n                if not self._should_retry(e):\n                    logger.error(f\"âŒ Non-retryable exception: {type(e).__name__}\")\n                    self.retry_stats[\"failed_operations\"] += 1\n                    raise\n                \n                if attempt < self.config.max_retries:\n                    self.retry_stats[\"total_retries\"] += 1\n                    logger.warning(f\"âš ï¸  Async attempt {attempt + 1}/{self.config.max_retries + 1} failed: {str(e)}\")\n                    logger.info(f\"ðŸ”„ Retrying in {delay:.1f}s...\")\n                    \n                    await asyncio.sleep(delay)\n                    delay = min(delay * self.config.backoff_factor, self.config.max_delay)\n                else:\n                    self.retry_stats[\"failed_operations\"] += 1\n                    logger.error(f\"âŒ All {self.config.max_retries + 1} async attempts failed\")\n        \n        if last_exception:\n            raise last_exception\n        else:\n            raise RuntimeError(\"All async retry attempts exhausted without capturing an exception\")\n    \n    def _should_retry(self, exception: Exception) -> bool:\n        \"\"\"\n        Determine if an exception should trigger a retry\n        \n        Args:\n            exception: The caught exception\n            \n        Returns:\n            True if should retry, False otherwise\n        \"\"\"\n        for exc_type in self.config.retry_on_exceptions:\n            if isinstance(exception, exc_type):\n                return True\n        return False\n    \n    def get_stats(self) -> dict:\n        \"\"\"\n        Get retry statistics\n        \n        Returns:\n            Dictionary with retry statistics\n        \"\"\"\n        return {\n            **self.retry_stats,\n            \"success_rate\": (\n                (self.retry_stats[\"total_attempts\"] - self.retry_stats[\"failed_operations\"]) \n                / max(self.retry_stats[\"total_attempts\"], 1) * 100\n            ),\n            \"config\": {\n                \"max_retries\": self.config.max_retries,\n                \"initial_delay\": self.config.initial_delay,\n                \"max_delay\": self.config.max_delay,\n                \"backoff_factor\": self.config.backoff_factor\n            }\n        }\n    \n    def reset_stats(self):\n        \"\"\"Reset retry statistics\"\"\"\n        self.retry_stats = {\n            \"total_attempts\": 0,\n            \"total_retries\": 0,\n            \"successful_retries\": 0,\n            \"failed_operations\": 0\n        }\n        logger.info(\"ðŸ“Š Retry statistics reset\")\n\n\ndef create_retry_mechanism(max_retries: int = 3, \n                          initial_delay: float = 1.0,\n                          backoff_factor: float = 2.0) -> RetryMechanism:\n    \"\"\"\n    Factory function to create a retry mechanism with custom settings\n    \n    Args:\n        max_retries: Maximum number of retry attempts\n        initial_delay: Initial delay in seconds\n        backoff_factor: Multiplier for exponential backoff\n        \n    Returns:\n        Configured RetryMechanism instance\n    \"\"\"\n    config = RetryConfig(\n        max_retries=max_retries,\n        initial_delay=initial_delay,\n        backoff_factor=backoff_factor\n    )\n    return RetryMechanism(config)\n","size_bytes":9108},"integrations/playwright_mcp_node/index.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { createConnection } = require('playwright/lib/mcp/index');\nmodule.exports = { createConnection };\n","size_bytes":728},"app/routes/__init__.py":{"content":"\"\"\"\nFlask Routes Module\n\"\"\"\nfrom app.routes.api import create_api_routes\n\n__all__ = ['create_api_routes']\n","size_bytes":106},"integrations/playwright_mcp_node/cli.js":{"content":"#!/usr/bin/env node\n/**\n * Copyright (c) Microsoft Corporation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { program } = require('playwright-core/lib/utilsBundle');\nconst { decorateCommand } = require('playwright/lib/mcp/program');\n\nconst packageJSON = require('./package.json');\nconst p = program.version('Version ' + packageJSON.version).name('Playwright MCP');\ndecorateCommand(p, packageJSON.version)\nvoid program.parseAsync(process.argv);\n","size_bytes":965},"docs/PERFORMANCE_GUIDE.md":{"content":"# Browser Automation Performance Guide\n\n## Current Performance Optimizations\n\nYour browser automation is configured for **BALANCED PERFORMANCE** - optimized for speed while maintaining reliability.\n\n### âš¡ Speed Improvements Applied\n\n#### 1. **Optimized Wait Times** (40-50% faster than defaults)\n- **Page Load Wait**: `0.5s` (default 1.0s)\n- **Network Idle Wait**: `1.0s` (default 1.5s) \n- **Action Wait**: `0.5s` (default 1.0s)\n\n**Impact**: Actions execute 40-50% faster while maintaining reliability on most websites\n\nâš ï¸ **Important**: These settings work well for most sites but may need adjustment for:\n- Heavy JavaScript frameworks (React, Angular, Vue)\n- Sites with slow CDNs or cascading AJAX calls\n- Authentication redirects or API-heavy dashboards\n- Sites behind captive portals or with anti-bot protection\n\n#### 2. **ChatBrowserUse Model** âœ… ENABLED (3-5x faster)\n- Using specialized browser automation model\n- Optimized for browser tasks vs general OpenAI models\n- Better task completion accuracy\n\n#### 3. **Balanced Retry Mechanism**\n- **Max Retries**: `3` (handles transient failures)\n- **Initial Delay**: `1.0s`\n- **Max Delay**: `30s`\n\n**Impact**: Reliable failure recovery for network hiccups and rate limits\n\n#### 4. **Appropriate Max Steps**\n- **Max Steps**: `25` (good for most workflows)\n- Adjust down to 15-20 for simple tasks, up to 30-40 for complex workflows\n\n---\n\n## Performance by Task Complexity\n\n| Task Type | Expected Speed | Recommended Settings |\n|-----------|---------------|---------------------|\n| Simple (1-3 actions) | **5-10 seconds** | Current (Ultra-Fast) |\n| Medium (4-8 actions) | **15-30 seconds** | Current (Ultra-Fast) |\n| Complex (9+ actions) | **30-60 seconds** | Increase max_steps to 25-30 |\n| Heavy JS sites | **May need tuning** | Increase network idle to 0.8s |\n\n---\n\n## ðŸŽ¯ When to Adjust Settings\n\n### If you experience issues:\n\n**Problem: Pages not loading completely**\n```ini\n# Increase network idle wait\nwait_for_network_idle_page_load_time = 0.8  # from 0.5\n```\n\n**Problem: Actions failing intermittently**\n```ini\n# Increase action wait time\nwait_between_actions = 0.3  # from 0.2\n```\n\n**Problem: Complex workflows timing out**\n```ini\n# Increase max steps\nmax_steps = 30  # from 20\n```\n\n**Problem: Heavy JavaScript websites**\n```ini\n# Increase all wait times by 2x\nminimum_wait_page_load_time = 0.4\nwait_for_network_idle_page_load_time = 1.0\nwait_between_actions = 0.4\n```\n\n---\n\n## ðŸ”§ Manual Tuning Guide\n\n### Conservative (Most Reliable)\n```ini\nminimum_wait_page_load_time = 1.0\nwait_for_network_idle_page_load_time = 2.0\nwait_between_actions = 1.0\nmax_steps = 30\n```\n\n### Balanced (Default)\n```ini\nminimum_wait_page_load_time = 0.5\nwait_for_network_idle_page_load_time = 1.0\nwait_between_actions = 0.5\nmax_steps = 25\n```\n\n### Fast (Current)\n```ini\nminimum_wait_page_load_time = 0.2\nwait_for_network_idle_page_load_time = 0.5\nwait_between_actions = 0.2\nmax_steps = 20\n```\n\n### Ultra-Fast (Experimental)\n```ini\nminimum_wait_page_load_time = 0.1\nwait_for_network_idle_page_load_time = 0.3\nwait_between_actions = 0.1\nmax_steps = 15\n```\nâš ï¸ **Warning**: Ultra-fast may cause instability on slow websites\n\n---\n\n## ðŸ“Š Performance Monitoring\n\nCheck execution metrics in the response:\n```json\n{\n  \"performance_metrics\": {\n    \"total_duration\": \"12.5s\",\n    \"operations\": {...}\n  },\n  \"retry_stats\": {\n    \"total_retries\": 0,\n    \"success_rate\": \"100%\"\n  }\n}\n```\n\n---\n\n## ðŸ’¡ Pro Tips\n\n1. **ChatBrowserUse is KEY**: Keep `use_chat_browser_use = true` for 3-5x speed boost\n2. **Headless mode**: Always use `headless = true` in production (already enabled)\n3. **Disable features you don't need**: Turn off screenshots/PDFs if not required\n4. **Clear task instructions**: More precise instructions = fewer steps = faster execution\n5. **Use the optimized engine**: The system defaults to optimized engine (good!)\n\n---\n\n## ðŸš€ Extreme Performance Mode\n\nFor **maximum speed** at the cost of some reliability:\n\n```ini\n[agent]\nmax_steps = 15\n\n[browser_performance]\nminimum_wait_page_load_time = 0.1\nwait_for_network_idle_page_load_time = 0.3\nwait_between_actions = 0.1\n\n[retry]\nmax_retries = 1\ninitial_delay = 0.3\n\n[advanced_features]\nenable_screenshots = false\nenable_pdf_generation = false\nenable_state_persistence = false\ntrack_detailed_metrics = false\n```\n\nOnly use for simple, fast websites where speed is critical.\n\n---\n\n## ðŸ“ Configuration File Location\n\nEdit: `config/config.ini`\n\nAfter making changes, restart the application to apply them.\n","size_bytes":4510},"app/utils/__init__.py":{"content":"\"\"\"Utilities package\"\"\"\n","size_bytes":24},"auth/__init__.py":{"content":"\"\"\"\nOAuth Authentication Module\nProvides centralized OAuth 2.0 token-based authentication for gateway access\n\"\"\"\nfrom .oauth_handler import OAuthConfig, OAuthTokenFetcher, enable_certs\n\n__all__ = ['OAuthConfig', 'OAuthTokenFetcher', 'enable_certs']\n","size_bytes":249},"app/middleware/__init__.py":{"content":"\"\"\"Middleware package\"\"\"\n","size_bytes":25},"app/utils/logging_config.py":{"content":"\"\"\"\nCentralized logging configuration for the application\n\"\"\"\nimport logging\nimport configparser\nimport sys\nfrom pathlib import Path\n\n\nclass LoggingConfigurator:\n    \"\"\"Configure logging based on config.ini settings\"\"\"\n    \n    def __init__(self, config_path: str = 'config/config.ini'):\n        self.config = configparser.ConfigParser()\n        self.config.read(config_path)\n        \n        # Get logging settings\n        self.detailed_logging_enabled = self.config.getboolean('logging', 'enable_detailed_logging', fallback=False)\n        self.app_log_level = self.config.get('logging', 'app_log_level', fallback='INFO')\n        self.browser_use_log_level = self.config.get('logging', 'browser_use_log_level', fallback='INFO')\n        self.agent_log_level = self.config.get('logging', 'agent_log_level', fallback='INFO')\n        self.llm_log_level = self.config.get('logging', 'llm_log_level', fallback='INFO')\n        self.playwright_log_level = self.config.get('logging', 'playwright_log_level', fallback='WARNING')\n        \n        self.log_llm_requests = self.config.getboolean('logging', 'log_llm_requests', fallback=False)\n        self.log_llm_responses = self.config.getboolean('logging', 'log_llm_responses', fallback=False)\n        self.log_browser_actions = self.config.getboolean('logging', 'log_browser_actions', fallback=False)\n        self.log_page_state = self.config.getboolean('logging', 'log_page_state', fallback=False)\n        self.log_performance = self.config.getboolean('logging', 'log_performance', fallback=False)\n    \n    def configure(self):\n        \"\"\"Apply logging configuration\"\"\"\n        if not self.detailed_logging_enabled:\n            # Simple logging\n            logging.basicConfig(\n                level=logging.INFO,\n                format='%(levelname)s:%(name)s:%(message)s',\n                handlers=[logging.StreamHandler(sys.stdout)]\n            )\n            return\n        \n        # Detailed logging with timestamps\n        log_format = '%(asctime)s [%(name)s] %(levelname)s: %(message)s'\n        date_format = '%Y-%m-%d %H:%M:%S'\n        \n        logging.basicConfig(\n            level=getattr(logging, self.app_log_level, logging.INFO),\n            format=log_format,\n            datefmt=date_format,\n            handlers=[logging.StreamHandler(sys.stdout)],\n            force=True  # Override any existing configuration\n        )\n        \n        # Configure specific loggers\n        logging.getLogger('app').setLevel(getattr(logging, self.app_log_level, logging.INFO))\n        logging.getLogger('browser_use').setLevel(getattr(logging, self.browser_use_log_level, logging.INFO))\n        logging.getLogger('Agent').setLevel(getattr(logging, self.agent_log_level, logging.INFO))\n        logging.getLogger('service').setLevel(getattr(logging, self.agent_log_level, logging.INFO))\n        logging.getLogger('tools').setLevel(getattr(logging, self.agent_log_level, logging.INFO))\n        logging.getLogger('BrowserSession').setLevel(getattr(logging, self.browser_use_log_level, logging.INFO))\n        logging.getLogger('openai').setLevel(getattr(logging, self.llm_log_level, logging.INFO))\n        logging.getLogger('httpx').setLevel(getattr(logging, self.llm_log_level, logging.INFO))\n        logging.getLogger('playwright').setLevel(getattr(logging, self.playwright_log_level, logging.WARNING))\n        \n        # Log configuration status\n        root_logger = logging.getLogger()\n        root_logger.info(\"=\" * 80)\n        root_logger.info(\"ðŸ”§ DETAILED LOGGING ENABLED\")\n        root_logger.info(\"=\" * 80)\n        root_logger.info(f\"App Log Level: {self.app_log_level}\")\n        root_logger.info(f\"Browser-Use Log Level: {self.browser_use_log_level}\")\n        root_logger.info(f\"Agent Log Level: {self.agent_log_level}\")\n        root_logger.info(f\"LLM Log Level: {self.llm_log_level}\")\n        root_logger.info(f\"Playwright Log Level: {self.playwright_log_level}\")\n        root_logger.info(f\"Log LLM Requests: {self.log_llm_requests}\")\n        root_logger.info(f\"Log LLM Responses: {self.log_llm_responses}\")\n        root_logger.info(f\"Log Browser Actions: {self.log_browser_actions}\")\n        root_logger.info(f\"Log Page State: {self.log_page_state}\")\n        root_logger.info(f\"Log Performance: {self.log_performance}\")\n        root_logger.info(\"=\" * 80)\n\n\n# Global configurator instance\n_configurator = None\n\n\ndef get_logging_config():\n    \"\"\"Get the global logging configurator\"\"\"\n    global _configurator\n    if _configurator is None:\n        _configurator = LoggingConfigurator()\n    return _configurator\n\n\ndef should_log_llm_requests():\n    \"\"\"Check if LLM requests should be logged\"\"\"\n    return get_logging_config().log_llm_requests\n\n\ndef should_log_llm_responses():\n    \"\"\"Check if LLM responses should be logged\"\"\"\n    return get_logging_config().log_llm_responses\n\n\ndef should_log_browser_actions():\n    \"\"\"Check if browser actions should be logged\"\"\"\n    return get_logging_config().log_browser_actions\n\n\ndef should_log_page_state():\n    \"\"\"Check if page state should be logged\"\"\"\n    return get_logging_config().log_page_state\n\n\ndef should_log_performance():\n    \"\"\"Check if performance metrics should be logged\"\"\"\n    return get_logging_config().log_performance\n","size_bytes":5229},"app/engines/playwright_mcp/__init__.py":{"content":"\"\"\"\nPlaywright MCP Codebase\nTool-based browser automation using Playwright's Model Context Protocol\n\"\"\"\nfrom app.engines.playwright_mcp.client.stdio_client import MCPStdioClient\nfrom app.engines.playwright_mcp.agent.conversation_agent import BrowserAgent\nfrom app.engines.playwright_mcp.server_manager import get_mcp_client, get_server_status, shutdown_server\n\n\ndef create_engine(headless: bool = False):\n    \"\"\"\n    Factory function to create a Playwright MCP engine instance\n    \n    Uses server manager to handle both 'always_run' and 'on_demand' modes.\n    The server mode is configured in config/config.ini under [playwright_mcp].\n    \n    Args:\n        headless: Run browser in headless mode\n        \n    Returns:\n        Tuple of (mcp_client, browser_agent)\n    \"\"\"\n    mcp_client = get_mcp_client(headless=headless)\n    browser_agent = BrowserAgent(mcp_client)\n    return mcp_client, browser_agent\n\n\n__all__ = ['MCPStdioClient', 'BrowserAgent', 'create_engine', 'get_server_status', 'shutdown_server']\n","size_bytes":1010}},"version":2}